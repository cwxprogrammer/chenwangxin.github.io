<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-16T10:49:11.895Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring事务处理API</title>
    <link href="http://example.com/2020/12/16/spring%E7%9A%84aop%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86API%EF%BC%8C%E4%BB%A3%E6%9B%BF%E4%B9%8B%E5%89%8D%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2020/12/16/spring%E7%9A%84aop%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86API%EF%BC%8C%E4%BB%A3%E6%9B%BF%E4%B9%8B%E5%89%8D%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2020-12-16T10:07:28.869Z</published>
    <updated>2020-12-16T10:49:11.895Z</updated>
    
    <content type="html"><![CDATA[<p>清楚其中事务处理的原理，而后懂API，才能不至于根基不牢，问啥啥不会<br>使用Spring 事务管理API的步骤<br>1、配置事务管理器<br>        2、配置事务的通知<br>                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的<br>                使用tx:advice标签配置事务通知<br>                    属性：<br>                        id：给事务通知起一个唯一标识<br>                        transaction-manager：给事务通知提供一个事务管理器引用<br>        3、配置AOP中的通用切入点表达式<br>        4、建立事务通知和切入点表达式的对应关系<br>        5、配置事务的属性<br>               是在事务的通知tx:advice标签的内部</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置业务层--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;accountService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置账户的持久层--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;accountDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- spring中基于XML的声明式事务控制配置步骤</span><br><span class="line">        <span class="number">1</span>、配置事务管理器</span><br><span class="line">        <span class="number">2</span>、配置事务的通知</span><br><span class="line">                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的</span><br><span class="line">                使用tx:advice标签配置事务通知</span><br><span class="line">                    属性：</span><br><span class="line">                        id：给事务通知起一个唯一标识</span><br><span class="line">                        transaction-manager：给事务通知提供一个事务管理器引用</span><br><span class="line">        <span class="number">3</span>、配置AOP中的通用切入点表达式</span><br><span class="line">        <span class="number">4</span>、建立事务通知和切入点表达式的对应关系</span><br><span class="line">        <span class="number">5</span>、配置事务的属性</span><br><span class="line">               是在事务的通知tx:advice标签的内部</span><br><span class="line"></span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transactionManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置事务的通知--&gt;</span><br><span class="line">    &lt;tx:advice id=<span class="string">&quot;txAdvice&quot;</span> transaction-manager=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 配置事务的属性</span><br><span class="line">                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</span><br><span class="line">                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</span><br><span class="line">                read-only：用于指定事务是否只读。只有查询方法才能设置为<span class="keyword">true</span>。默认值是<span class="keyword">false</span>，表示读写。</span><br><span class="line">                timeout：用于指定事务的超时时间，默认值是-<span class="number">1</span>，表示永不超时。如果指定了数值，以秒为单位。</span><br><span class="line">                rollback-<span class="keyword">for</span>：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</span><br><span class="line">                no-rollback-<span class="keyword">for</span>：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">&quot;*&quot;</span> propagation=<span class="string">&quot;REQUIRED&quot;</span> read-only=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置aop--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- 配置切入点表达式--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;清楚其中事务处理的原理，而后懂API，才能不至于根基不牢，问啥啥不会&lt;br&gt;使用Spring 事务管理API的步骤&lt;br&gt;1、配置事务管理器&lt;br&gt;        2、配置事务的通知&lt;br&gt;                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的&lt;br&gt;                使用tx:advice标签配置事务通知&lt;br&gt;                    属性：&lt;br&gt;                        id：给事务通知起一个唯一标识&lt;br&gt;                        transaction-manager：给事务通知提供一个事务管理器引用&lt;br&gt;        3、配置AOP中的通用切入点表达式&lt;br&gt;        4、建立事务通知和切入点表达式的对应关系&lt;br&gt;        5、配置事务的属性&lt;br&gt;               是在事务的通知tx:advice标签的内部&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring AOP</title>
    <link href="http://example.com/2020/12/14/Spring%20AOP-2/"/>
    <id>http://example.com/2020/12/14/Spring%20AOP-2/</id>
    <published>2020-12-14T12:35:04.313Z</published>
    <updated>2020-12-14T12:37:33.704Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行期间，不修改源码对已有方法进行增强<br>优势：<br>    减少重复代码<br>    提高开发效率<br>    维护方便<br>AOP实现方法：<br>    使用动态代理（1.基于接口2.基于子类）</p><p>Spring AOP（基于注解）<br>    通过配置的方式来实现我们前面创建代理的代码<br>    相关术语：<br>        <strong>Joinpoint(连接点)</strong><br>        业务层接口，看到的方法都是连接点（有事务支持）<br>         <strong>Pointcut(切入点)</strong><br>         被增强的方法<br>         Advice（通知）<br>         Introduction(引介)</p><a id="more"></a><p>总结：切面应该是通过注解实现所有事务的执行顺序以及解决重复事务的功能</p><p>我们应该做的：<br>编写核心业务代码（开发主线）：大部分程序员做，要求熟悉业务员需求<br>把公用代码抽取出来，制作成通知。（开发阶段最后来做）：AOP编程人员来做<br>在配置文件中，生命切入点与通知间的关系，即切面</p><p>Spring基于XML的AOP配置<br>    spring任何一个内容，都需要IOC的配置或者注解文件<br>    构想:<br>    创建一个spring项目很简单：<br>    1.三层架构，加上ioc注解<br>    2.aop解决冗余业务层代码问题<br>    3.mybatis解决持久层查询问题（注解or配置文件查询）<br>    注：AOP集成了动态代理<br>通知的其他类型：<br> spring中基于xml的aop步骤<br>        1.把通知的bean也交spring来管理<br>        2.使用aop:config标签表明开始AOP的配置<br>        3.使用aop:aspect标签配置切面<br>            id属性：是给切面提供一个唯一标识<br>            ref属性：指定通知类bean的Id<br>        4.在aop:aspect标签的内部使用对应标签来配置通知的类型<br>            我们现在示例是让printLog方法在切入点方法执行之前执行：所以是前置通知<br>            aop:before：表示配置前置通知<br>                method属性：用于指定Logger类中那个方法是前置通知<br>                pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强<br>            切入点表达式的写法：<br>                关键字：execution(表达式)<br>                表达式：<br>                    访问修饰符 返回值  包名.包名.包名…类名.方法名（参数列表）<br>                     public void com.bjut.service.impl.AccountServiceImpl.saveAccount()<br>                     访问修饰符课省略<br>                     返回值可以使用通配符，表示任意返回值<br>                     包名可以使用通配符，表示任意包<br>                     全通配写法<br>                     * <em>..</em>.<em>(..)<br>                     实际开发中：通常写法：<br>                     切到业务层实现类下的所有方法<br>                      <em>com.bjut.service.impl.</em>.</em>(..)</p><p>可以配置全类名，且可以任意切面使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">              此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">              它还可以写在aop:aspect外面，此时就变成了所有切面可用</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>环绕通知：<br>配置环绕通知</p><pre><code> * 环绕通知 * 问题： *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */</code></pre><p><strong>AOP实际上就是方法增强器！！！！</strong><br>通过注解+代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将一些繁琐的重复的代码在切面先行执行！</p><p>环绕通知可以准确的帮程序员实现AOP的提醒顺序<br>放在切入点方法前面就是就是前置通知（同样的，可以提前执行某些方法，不一定是通知）<br>放在切入点方法后面就是后置通知（同样的，可以过后执行某些方法，不一定是通知）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在程序运行期间，不修改源码对已有方法进行增强&lt;br&gt;优势：&lt;br&gt;    减少重复代码&lt;br&gt;    提高开发效率&lt;br&gt;    维护方便&lt;br&gt;AOP实现方法：&lt;br&gt;    使用动态代理（1.基于接口2.基于子类）&lt;/p&gt;
&lt;p&gt;Spring AOP（基于注解）&lt;br&gt;    通过配置的方式来实现我们前面创建代理的代码&lt;br&gt;    相关术语：&lt;br&gt;        &lt;strong&gt;Joinpoint(连接点)&lt;/strong&gt;&lt;br&gt;        业务层接口，看到的方法都是连接点（有事务支持）&lt;br&gt;         &lt;strong&gt;Pointcut(切入点)&lt;/strong&gt;&lt;br&gt;         被增强的方法&lt;br&gt;         Advice（通知）&lt;br&gt;         Introduction(引介)&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring AOP前置，Spring AOP解决的问题和痛点？</title>
    <link href="http://example.com/2020/12/14/Spring%20AOP/"/>
    <id>http://example.com/2020/12/14/Spring%20AOP/</id>
    <published>2020-12-14T06:49:13.991Z</published>
    <updated>2020-12-14T07:00:47.022Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP前置，Spring AOP解决的问题和痛点？</p><ol><li>完善account案例</li><li>分析案例中问题</li><li>回顾之前讲过的一个技术：动态代理，proxy</li><li>动态代理另一种实现方式</li><li>解决案例中的问题</li><li>AOP的概念</li><li>spring中的AOP相关术语</li><li>spring中基于xml和注解的AOP配置<a id="more"></a>前面五步:就是我们写代码时需要一直重复的一些问题：动态代理<br>后面三步:我们可以将前面五步集成为一个AOP的切面平台<br>，将业务层彻底简化。<br>这将是我们达到的目的<br>1.案例中将添加转账方法并演示事务问题</li></ol><p>我们需要一个处理事务整体只和数据库连接一次，回滚也可以<br>1.我们建立一个utils包<br>        先将线程独立出来,而后形成一个工具类，因为工具类占用线程池的线程，天然绑定一个连接（事务管理），所以最后要关闭（close）+剔除（remove）<br>        获取线程–&gt;事务控制+remove连接<br><strong>bean.xml配置：</strong><br>1.首先控制线程与数据库连接的工具类只有一个。那就是ConnectionUtils,事务管理bean（业务层service专用）也是connectionUtils的一个延伸，所以要注入connectionUtils</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.utils.TransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionUtils&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事务控制成功<br>总结：<br>1.先有线程与数据库连接的工具类<br>2.而后通过线程工具类实现事务可视化控制</p><p>但是有缺点：<br>就是事务控制层的方法调用，太耦合。<br>解决办法：动态代理<br>Java中的动态代理机制<br>    proxy要求必须实现一个借口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">               producer.getClass().getInterfaces(),</span><br></pre></td></tr></table></figure><p>而另一种基于jar包的cglib动态代理机制，可以实现普通java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>总结：<br>1.为了避免线程自动与数据库的数次交互，我们采用了两个工具类，一个摘取线程，一个是在线程的基础上控制事务。<br>2.但是此刻不可避免的遗漏了一个情况：就是每一次事务执行都得配套所有的事务执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.开启事务</span></span><br><span class="line">                            txManager.beginTransaction();</span><br><span class="line">                            <span class="comment">//2.执行操作</span></span><br><span class="line">                            rtValue = method.invoke(accountService, args);</span><br><span class="line">                            <span class="comment">//3.提交事务</span></span><br><span class="line">                            txManager.commit();</span><br><span class="line">                            <span class="comment">//4.返回结果</span></span><br><span class="line">                            <span class="keyword">return</span> rtValue;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//5.回滚操作</span></span><br><span class="line">                            txManager.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//6.释放连接</span></span><br><span class="line">                            txManager.release();</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>所以我们通过动态代理对象形成一个代理处理事务的类，帮助我们处理一系列事务，使得serviceImpl代码清洁，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer acccountId)</span> </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(acccountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);<span class="comment">//事务处理</span></span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int i=1/0;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是随之而来的配置文件比较头疼：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置代理的service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;proxyAccountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置beanfactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.BeanFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入service --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入事务管理器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以这就是spring aop诞生的原因，即简化了业务层的事务代码，又简化了代理对象的配置文件！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring AOP前置，Spring AOP解决的问题和痛点？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完善account案例&lt;/li&gt;
&lt;li&gt;分析案例中问题&lt;/li&gt;
&lt;li&gt;回顾之前讲过的一个技术：动态代理，proxy&lt;/li&gt;
&lt;li&gt;动态代理另一种实现方式&lt;/li&gt;
&lt;li&gt;解决案例中的问题&lt;/li&gt;
&lt;li&gt;AOP的概念&lt;/li&gt;
&lt;li&gt;spring中的AOP相关术语&lt;/li&gt;
&lt;li&gt;spring中基于xml和注解的AOP配置</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring整合junit的配置</title>
    <link href="http://example.com/2020/12/13/Spring%E6%95%B4%E5%90%88junit%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/12/13/Spring%E6%95%B4%E5%90%88junit%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2020-12-13T08:24:00.869Z</published>
    <updated>2020-12-13T08:25:50.660Z</updated>
    
    <content type="html"><![CDATA[<p>1.应用程序的入口<br>    main方法<br>2.junit单元测试中，没有main方法也能执行<br>    junit就会判断当前测试类中哪些方法有@Test注解<br>    junit就让有注解的方法执行<br>3.junit不会管我们是否使用了spring框架<br>4.当测试方法执行时，没有IOC容器，就算写@Autowried注解，也会产生空指针异常</p><a id="more"></a><p>解决方法：<br>    Spring整合junit的配置<br>        1.导入Spring整合junit的jar包<br>        2.使用junit提供的一个注解把原有的main方法替换了，替换成spring提供的@Runwith<br>        3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置<br>        基于注解的：@ContextConfiguration(classes = SpringConfiguration.class)<br>        基于配置文件的：@ContextConfiguration(locations = “classpath:bean.xml”) </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.应用程序的入口&lt;br&gt;    main方法&lt;br&gt;2.junit单元测试中，没有main方法也能执行&lt;br&gt;    junit就会判断当前测试类中哪些方法有@Test注解&lt;br&gt;    junit就让有注解的方法执行&lt;br&gt;3.junit不会管我们是否使用了spring框架&lt;br&gt;4.当测试方法执行时，没有IOC容器，就算写@Autowried注解，也会产生空指针异常&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之基于Spring的常用注解IOC以及IOC的案例</title>
    <link href="http://example.com/2020/12/13/%E5%9F%BA%E4%BA%8ESpring%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3IOC%E4%BB%A5%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2020/12/13/%E5%9F%BA%E4%BA%8ESpring%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3IOC%E4%BB%A5%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B/</id>
    <published>2020-12-13T08:02:17.748Z</published>
    <updated>2020-12-13T08:04:38.489Z</updated>
    
    <content type="html"><![CDATA[<p> 基于Spring的常用注解IOC以及IOC的案例<br>     1.SpringIOC的常用注解<br>     2.案例使用xml方式和注解方式实现单表的CRUD操作<br>         持久层技术选择：dbutils<br>     3.改造基于注解的IOC案例，使用纯注解的方式实现<br>         Spring的一些新注解</p><a id="more"></a><p>xml配置与IOC注解配置：<br>    注解分为四类：<br>        1.用于创建对象的<br>        2.用于注入数据的<br>        3.用于改变作用范围的<br>        4.和生命周期相关<br>        @component<br>    注解必须用context的 component-scan base-package=”com.itheima.xxx”<br>    开始扫描所有类上和接口上的注解<br>        xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a><br>    告知spring在创建容器式要扫描的包，配置需要的标签不是在beans标签的约束中，而是在一个名称为context的名称空间和约束中。<br>这些注解是生成实例的：<br>    @controller一般用于表现层<br>    @service 一般用于业务层<br>    @Repository一般用于持久层</p><p>依赖反转+依赖注入</p><p>用于注入数据的：<br>@Autowired（方法）<br>自动按照类型注入，找到数据类型就可以注入（只有唯一一个符合的bean时）。<br>@Qualifier不能独立用，与@Autowired一起使用<br>    但是有一种特殊情况，就是给方法注入时可以单独使用@Qualifier，比如使用不同的数据库源头时。</p><p>@Resource:直接按照bean的id注入，可以独立使用</p><p>以上三个只能进行其他bean类型的数据.<br>基本类型和String类型怎么注入？<br>    用value，有个属性value可以指定数据的值，可以使用spring的spEL表达式<br>        sPEL的写法：${表达式}<br>    用于改变作用范围的Scope<br>    value=singleton  or prototype</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 基于Spring的常用注解IOC以及IOC的案例&lt;br&gt;     1.SpringIOC的常用注解&lt;br&gt;     2.案例使用xml方式和注解方式实现单表的CRUD操作&lt;br&gt;         持久层技术选择：dbutils&lt;br&gt;     3.改造基于注解的IOC案例，使用纯注解的方式实现&lt;br&gt;         Spring的一些新注解&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之mybatis中的一对多（多表）查询</title>
    <link href="http://example.com/2020/12/08/mybatis%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%A4%9A%E8%A1%A8%EF%BC%89%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/12/08/mybatis%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%A4%9A%E8%A1%A8%EF%BC%89%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-12-08T13:17:38.623Z</published>
    <updated>2020-12-08T13:20:34.927Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis中的一对多（多表）查询<br>  如果拿出每一个订单，他都只能属于一个用户。<br>  所以mybatis就把多对一看成一对一<br>  步骤;<br>      1.用户表和账户表:<br>          一个用户可以有多个账户<br>          一个账户只能属于一个用户<br>      2.建立两个实体类：用户实体类和账户实体类<br>          让用户和账户的实体类都能体现出一对多的关系<br>      3.建立两个配置文件<br>          用户配置文件<br>          账户配置文件<br>      4.实现配置<br>          当我们查询用户时，可以同时得到用户下所包含的账户信息<br>          当我们查询账户时，可以得到账户所属用户信息</p><a id="more"></a><pre><code>  怎么说呢？  学的sql语句没有卵用，还得在实际情况下面学！！！  你比如说account(账户的ID)有个外键就是（userid）  关联子查询：用很多次</code></pre><p>  column是代表从哪获取的</p><p>  一对多关系映射，主表实体应该包含在从表实体的集合引用</p><pre><code>private List&lt;Account&gt; accounts;public List&lt;Account&gt; getAccounts() &#123;    return accounts;&#125;public void setAccounts(List&lt;Account&gt; accounts) &#123;    this.accounts = accounts;&#125;写IuserDao.xml &lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;    &lt;!-- 配置user对象中accounts集合的映射 --&gt;    &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;        &lt;id column=&quot;aid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有(修改一下sql语句) --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;    select * from user u left outer join account a on u.id = a.uid&lt;/select&gt;接下来直接查询，就可以将一个用户下的多个账户都查询出来。</code></pre><p> /**<br>     * 测试查询所有<br>     */<br>    @Test<br>    public void testFindAll(){<br>        List<User> users = userDao.findAll();<br>        for(User user : users){<br>            System.out.println(“—–每个用户的信息——“);<br>            System.out.println(user);<br>            System.out.println(user.getAccounts());<br>        }<br>    }</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;mybatis中的一对多（多表）查询&lt;br&gt;  如果拿出每一个订单，他都只能属于一个用户。&lt;br&gt;  所以mybatis就把多对一看成一对一&lt;br&gt;  步骤;&lt;br&gt;      1.用户表和账户表:&lt;br&gt;          一个用户可以有多个账户&lt;br&gt;          一个账户只能属于一个用户&lt;br&gt;      2.建立两个实体类：用户实体类和账户实体类&lt;br&gt;          让用户和账户的实体类都能体现出一对多的关系&lt;br&gt;      3.建立两个配置文件&lt;br&gt;          用户配置文件&lt;br&gt;          账户配置文件&lt;br&gt;      4.实现配置&lt;br&gt;          当我们查询用户时，可以同时得到用户下所包含的账户信息&lt;br&gt;          当我们查询账户时，可以得到账户所属用户信息&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之mybatis的连接池与事务控制（原理部分了解）</title>
    <link href="http://example.com/2020/12/08/mybatis%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2020/12/08/mybatis%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</id>
    <published>2020-12-08T13:10:07.062Z</published>
    <updated>2020-12-08T13:21:19.668Z</updated>
    
    <content type="html"><![CDATA[<p>1.mybatis的连接池与事务控制（原理部分了解）<br>    连接池的使用和分析<br>    mybatis事务控制的分析<br>2.mybatis基于xml配置的动态SQL语句使用<br>    mappers配置文件中的几个标签：</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;if&gt;</span><br><span class="line">&lt;whrere&gt;</span><br><span class="line">&lt;foreach&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryvo&quot;&gt;</span><br><span class="line">        &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">                &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                    <span class="comment">#&#123;uid&#125;</span></span><br><span class="line">                &lt;/foreach&gt;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>3.mybatis中的多表操作（right/left join on ）<br>        一对多<br>        一对一（？）<br>        多对多<br>回顾：UserDao.xml 就是一个mapper层</p><p>我们实际开发过程中都会使用连接池<br>因为它可以减少我们获取连接所消耗的时间<br>1.pooled:采用传统的javax.sql.datasource的连接池，由明确规范<br>2.unpooled:传统的获取连接方式，并没有使用池的思想，没有容器的概念</p><p>事务的四大特性（mysql）<br>ACID：一个事务就是一个整体<br>原子性：不可分割<br>一致性：事务操作回滚不会破坏约束<br>隔离性：每个事务都是彼此独立，不会受其他事务的约束<br>持久性：事务提交之后对数据的修改是持久性的，数据修改依旧有效</p><p>隔离级别：脏读，幻读，不可重复读，可重复读</p><p>那我做小程序的时候<br>也可以在mapper层，设置if。（定向查找）<br>如果等于“某个id”,那么就直接返回这个id的所有内容，在配合上其他的条件，就在前端显示就完事儿</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;where&gt;</span><br><span class="line">      &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">            &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                    <span class="comment">#&#123;uid&#125;</span></span><br><span class="line">           &lt;/foreach&gt;</span><br><span class="line">       &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindInIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       list.add(<span class="number">41</span>);</span><br><span class="line">       list.add(<span class="number">42</span>);</span><br><span class="line">       list.add(<span class="number">46</span>);</span><br><span class="line">       vo.setIds(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.执行查询所有方法</span></span><br><span class="line">       List&lt;User&gt; users = userDao.findUserInIds(vo);</span><br><span class="line">       <span class="keyword">for</span>(User user : users)&#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>筛选</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>提取重复代码！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.mybatis的连接池与事务控制（原理部分了解）&lt;br&gt;    连接池的使用和分析&lt;br&gt;    mybatis事务控制的分析&lt;br&gt;2.mybatis基于xml配置的动态SQL语句使用&lt;br&gt;    mappers配置文件中的几个标签：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Mybatis传递的参数类型：</title>
    <link href="http://example.com/2020/12/08/Mybatis%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/12/08/Mybatis%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-12-08T13:03:38.106Z</published>
    <updated>2020-12-08T13:22:34.661Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis传递的参数类型：<br>    1.输入类型：parameterType<br>    （1）传递简单类型，传递pojo对象，传递pojo包装对象<br>        OGNL表达式：Object Graphic Navigation Language 对象图导航语言<br>        它是通过对象的取值方法来获取数据<br>        在写法上把get给省略了</p><a id="more"></a><pre><code>    比如:我们获取用户的名称。类中的写法：user.getUsername();                          OGNL表达式写法:user.username     mybatis中为什么能直接写username,而不用user.呢？        因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名（2）由多个对象组成一个实际的查询条件，可以使用包装对象，外面再套一层        （pojo对象）2.输出类型:resultType （1）int  (2)实体类  解决实体类属性和数据库列明不对应的问题  1.在sql语句的层面上起别名  2.配置查询结果的列名和实体类的属性名的对应关系  &lt;resultMap id =&quot;userMap&quot; type =&quot;com.itheima.domain.User&quot;&gt;       &lt;!--主键字段的对应--&gt;          &lt;id property=&quot;userId&quot; column =&quot;id&quot; &gt;&lt;/id&gt; 前面是从实体类导入的，后面是对应数据库的字段          &lt;!--非主键的对应--&gt;          &lt;result property =&quot;userName&quot; column =&quot;username&quot;&gt;&lt;/result&gt;  &lt;/resultMap&gt;  改完以后所有sql语句的resultType都得改成resultMap，而且id值必须对应</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis传递的参数类型：&lt;br&gt;    1.输入类型：parameterType&lt;br&gt;    （1）传递简单类型，传递pojo对象，传递pojo包装对象&lt;br&gt;        OGNL表达式：Object Graphic Navigation Language 对象图导航语言&lt;br&gt;        它是通过对象的取值方法来获取数据&lt;br&gt;        在写法上把get给省略了&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JSON</title>
    <link href="http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/"/>
    <id>http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/</id>
    <published>2020-12-01T10:20:12.365Z</published>
    <updated>2020-12-01T10:21:52.235Z</updated>
    
    <content type="html"><![CDATA[<p>json<br>W3school<br>JSON 是存储和交换文本信息的语法<br>比xml更小，更方便</p><a id="more"></a><p>语法：<br>1.基本规则<br>数据在名称/值对中：由键值对构成。<br>    *键用引号引起来，也可以不使用引号；<br>    *值的取值类型：数字（整数或浮点数）<br>        a.字符串（在双引号中）<br>        b.逻辑值（true 或 false）<br>        c.数组（在方括号中）如：{“persons”:[{},{}]}<br>        d.对象（在花括号中）如：{“address”:{“province”:”陕西”…}}<br>        e.null<br>数据由逗号分隔：多个键值对由逗号分隔<br>花括号保存对象：使用{}定义json格式<br>方括号保存数组<br>2.获取数据<br> *使用json对象.键名<br> *json对象[“键名”]<br> *数组对象[]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>json数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//1.定义基本格式</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> person =&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(person)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// for(var key in person)&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     alert(key+&quot;:&quot;+person[key]);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式： 数组[]----&gt;&#123;&#125;Json对象里面有数组</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> persons= &#123;<span class="string">&quot;psersons&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;]&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(persons);</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式&#123;&#125;--&gt;[]本身就是数组，里面存放json对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ps=[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(ps);</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ps.length;i++</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p =ps[i];</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> p</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(key+<span class="string">&quot;:&quot;</span>+p[key]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Json当做数据的载体，转换为java对象（可以转换为任何对象）</p><p> 1.java转换成JSON<br>  json解析器：jsonlab,Gson,fastjson,jsckson(springmvc)<br> .使用步骤：<br> *导入jackson的相关jar包<br> *创键jackson核心对象ObjectMapper<br> *调用ObjectMapper的WriteValue方法来进行转换</p><p> 2.JSON 转换为 java<br>  readvalue(json,class对象)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package JSON.test;</span><br><span class="line"></span><br><span class="line">import JSON.domain.Person;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Jackson &#123;</span><br><span class="line"></span><br><span class="line">    //java对象转为JSON字符串1.字符串2.键：数组3 数组</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() throws IOException &#123;</span><br><span class="line">        //1.创建几个Person对象</span><br><span class="line">        Person p =new Person();</span><br><span class="line">        p.setName(&quot;张山&quot;);</span><br><span class="line">        p.setAge(23);</span><br><span class="line">        p.setGender(&quot;男&quot;);</span><br><span class="line">        //2.创建Jackson的核心对象  ObjectMapper</span><br><span class="line">        ObjectMapper mapper =new ObjectMapper();</span><br><span class="line">        //3.转换</span><br><span class="line">        /**</span><br><span class="line">         * 转换方法：</span><br><span class="line">         * writevalue (参数1,obj):</span><br><span class="line">         *      参数1：</span><br><span class="line">         *        File:将obj对象转换成JSON字符串，并保存到指定文件中</span><br><span class="line">         *        Writer:将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</span><br><span class="line">         *        OutputStream；将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</span><br><span class="line">         * writeValueAsString(obj):将对象转换为json</span><br><span class="line">         */</span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        //System.out.println(json);</span><br><span class="line">        mapper.writeValue(new FileWriter(&quot;/Users/chenwangxin/Desktop/a.txt&quot;),p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        //1.初始化JSON字符串</span><br><span class="line">        String json =&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23,\&quot;gender\&quot;:true&#125;&quot;;</span><br><span class="line">        //2.创建objectMapper</span><br><span class="line">        ObjectMapper  ob =new ObjectMapper();</span><br><span class="line">        //3.调用readValue()</span><br><span class="line">        Person person=ob.readValue(json,Person.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;json&lt;br&gt;W3school&lt;br&gt;JSON 是存储和交换文本信息的语法&lt;br&gt;比xml更小，更方便&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JQUERY实现AJAX</title>
    <link href="http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-01T10:11:57.504Z</published>
    <updated>2020-12-01T10:22:36.994Z</updated>
    
    <content type="html"><![CDATA[<p>JQUERY实现AJAX:</p><p>AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML<br>1.异步和同步  客户端和服务器端同步通信的基础上<br>2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术<br>提升用户的体验</p><a id="more"></a><p>实现方式：<br>JQuery实现方式<br>1.$.ajax()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//使用$.ajax()发送异步请求</span></span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;ajaxServlet&quot;</span>,<span class="comment">//请求路径</span></span></span><br><span class="line"><span class="javascript">                type:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">                    alert(data)</span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//响应成功后的回调函数</span></span></span><br><span class="line"><span class="javascript">                error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;出错啦。。&quot;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//请求响应失败会执行回调函数</span></span></span><br><span class="line"><span class="javascript">                dataType:<span class="string">&quot;text&quot;</span><span class="comment">//设置接受到的响应数据的格式</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.$.get()：发送get请求<br>    参数：<br>    url:请求路径<br>    data:请求参数<br>    callback:回调函数<br>    type：响应结果的类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">         $.get(<span class="string">&quot;ajaxServlet&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;rose&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">             alert(data);</span><br><span class="line"><span class="javascript">         &#125;,<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.$.post()：发送post请求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JQUERY实现AJAX:&lt;/p&gt;
&lt;p&gt;AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML&lt;br&gt;1.异步和同步  客户端和服务器端同步通信的基础上&lt;br&gt;2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术&lt;br&gt;提升用户的体验&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Jquery</title>
    <link href="http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/"/>
    <id>http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/</id>
    <published>2020-12-01T10:08:20.626Z</published>
    <updated>2020-12-01T10:23:05.575Z</updated>
    
    <content type="html"><![CDATA[<p>Jquery是一个优秀的js框架<br>优化了DOM的操作，事件处理、动画设计、Ajax交互<br>JQuery对象和JS对象区别与转换？<br>divs.html(“bbb”)<br>jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）</p><a id="more"></a><p>转换一下：js—&gt;jq: $(js对象) 就可以转换了<br>             jq—&gt;js: jq对象[索引]或者jq对象.get(索引)<br>选择器:筛选具有相似特征的元素（标签）<br>//jquery入口函数（dom文档加载完成之后执行入口函数）<br>        $(function () {<br>            //$(“#div1”).css(“background-color”,”red”);<br>            $(“#div1”).css(“backgroundColor”,”pink”);</p><pre><code>    &#125;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jquery是一个优秀的js框架&lt;br&gt;优化了DOM的操作，事件处理、动画设计、Ajax交互&lt;br&gt;JQuery对象和JS对象区别与转换？&lt;br&gt;divs.html(“bbb”)&lt;br&gt;jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之HTTPServlet的解释</title>
    <link href="http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2020-11-27T10:40:41.376Z</published>
    <updated>2020-11-27T10:43:47.033Z</updated>
    
    <content type="html"><![CDATA[<p>将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象<br>将来定义servlet类时，可以继承GenericServlet，实现service()方法即可</p><a id="more"></a><p>HTTPServlet（有七种解决方式）<br>不用再去判断请求方式，对http协议的一种封装<br>复写doGet(){}方法，浏览器直接请求是get方式<br>复写doPost(){}方法，表单请求是POST方式</p><p>注解配置<br>ServletDemo4<br>一个Servlet可以定义多个访问路径<br>路径定义规则：</p><ol><li> /xxx</li><li> /xxx/xxx:多层路径,目录结构</li><li> *.do<br>调用Servlet，就可以将自己的信息提交到后台了</li></ol><p>基于TCP/IP的高级协议<br>端口号：80<br>基于请求响应模型，一次请求一次响应<br>无状态：每次请求相互独立，不能交互数据</p><p>向服务器发送请求，js  css 图片  都是单独的请求。<br>1.0：每一次请求都会建立新的连接<br>1.1：复用连接（建立连接后，请求完gif图片，等一会儿，没有数据发送了，连接释放掉）</p><p>请求消息数据格式<br>1.请求行<br>2.请求头<br>3.请求空行<br>4.请求体</p><p>请求的是谁？是客户端</p><p>响应消息数据格式<br>GET:1.请求参数在请求行中，在url后  2.请求的url长度有限制  不安全<br>POST: 请求参数在请求体中 2.url长度没有限制，比如文件上传等大文件只能用post</p><p>请求头：浏览器告诉了服务器我个人的一些信息啊<br>告诉服务器使用的浏览器版本信息，可以解决兼容性的问题</p><p>Request:<br>原理：1.tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo的对象<br>2.tomcat服务器，会创建request和response对象，request对象中封装请求消息数据<br>3.tomcat将request和response两个对象传递给Service方法，并且调用service方法<br>代码如下：<br>@WebServlet(“/demo1”)<br>public class ServletDemo1 implements Servlet{<br>    service(servletRequest,servletResponse){<br>    4.程序员可以通过request对象获取请求数据消息，通过response对象设置响应消息数据<br>    }<br>}<br>5.服务器回传响应消息会从response对象中拿程序员设置的响应消息格式、</p><p>继承体系结构：<br>tomcat创建的</p><p>功能：<br>       //1.获取请求方式： GET<br>        String method =req.getMethod();<br>        System.out.println(method);<br>        //2.(*)获取虚拟目录页<br>        String contextPath=req.getContextPath();<br>        System.out.println(contextPath);<br>        //3.获取Servlet路径 ：/demo1<br>        String servletPath=req.getServletPath();<br>        System.out.println(servletPath);<br>        //4.获取get方式请求参数:name=zhangsan<br>        String queryString=req.getQueryString();<br>        System.out.println(queryString);<br>        //5.获取请求URL<br>        String requesURI=req.getRequestURI();<br>        StringBuffer requestURL =req.getRequestURL();<br>        System.out.println(requesURI);<br>        System.out.println(requestURL);<br>        //6.客户的协议和版本<br>        String protocol=req.getProtocol();<br>        System.out.println(protocol);<br>        //7.获取客户机的IP<br>        String remoteAddr=req.getRemoteAddr();<br>        System.out.println(remoteAddr);</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象&lt;br&gt;将来定义servlet类时，可以继承GenericServlet，实现service()方法即可&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JDBC快速抽取工具类</title>
    <link href="http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-27T10:33:21.969Z</published>
    <updated>2020-11-27T10:44:37.774Z</updated>
    
    <content type="html"><![CDATA[<p>jdbc抽取工具类<br>1.注册驱动抽取<br>2.连接对象方法抽取<br>3.释放资源方法抽取</p><a id="more"></a><p>不想传递参数，还得保证工具类的通用性，<br>解决:配置文件<br>src目录下面：<br>public class JDBCUtils{<br>   private static String url;<br>   private static String user;<br>   private static String password;<br>   private static String driver;<br>    文件的读取，只需要读取一次即可拿到这些值，使用静态代码块<br>    static{<br>    1.创建Properties集合类<br>       properties pro =new  properties();<br>    获取src路径下的文件的方式–&gt;ClassLoader类加载器<br>    ClassLoader classloader =JDBCUtils.class.getClassLoader();<br>    URL res =classLoader.getResource(jdbc.properties);<br>    String path =res.getPath();</p><pre><code>2.加载文件  //pro.load(new FileReader(fileNmae:&quot;src/jdbc.properties&quot;));   pro.load(path); 3.获取数据，赋值  url =pro.getProperty(&quot;url&quot;);  user =pro.getProperty(&quot;user&quot;);  password =pro.getProperty(&quot;password&quot;);  driver=pro.getProperty(&quot;driver&quot;);4.获取驱动  Class.forName(&quot;driver&quot;);&#125;</code></pre><p>}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;jdbc抽取工具类&lt;br&gt;1.注册驱动抽取&lt;br&gt;2.连接对象方法抽取&lt;br&gt;3.释放资源方法抽取&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决小伙伴们深度学习时模型训练的硬件问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T09:01:35.461Z</published>
    <updated>2020-11-25T09:19:54.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习YOLOv3来训练voc模型<br>可想而知一个15年的mac或者老版本的Windows电脑难堪重负。<br>在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！<br><img src="https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。<br>几番抉择后，选择了滴滴云服务器,因为价格！！！<br><a href="https://www.didiyun.com/">https://www.didiyun.com</a></p><a id="more"></a><p>一、大家可以使用云服务器（带GPU）,我顺便搞了个大师码：8996，还给打了⑨折<br>而且最重要的是他家的时间 是按照你用的时间算，你结束时它不会给你计费，意思说你按小时买也特别划算，经济实惠。<br><img src="https://img-blog.csdnimg.cn/20201125163558908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201125164349470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注：大家如果使用云服务器训练。可以参考这篇博文：<br><a href="https://blog.csdn.net/ForeeverF/article/details/103651924%EF%BC%8C%E6%91%98%E8%87%AA">https://blog.csdn.net/ForeeverF/article/details/103651924，摘自</a> Byronnar博主<br>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p><p>需要自己配置环境</p><p>二、还可以使用network，这个就很香，你可以直接跑<br><img src="https://img-blog.csdnimg.cn/20201125164852326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020112516504538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我买个4核处理器的GPU云算力，一小时才三块钱，就可以运行我的项目，还不用担心自己电脑宕机，而我们的所有代码操作都可以在本机上操作，将其利用，具体操作请参考。<br><a href="https://help.didiyun.com/hc/kb/section/1151520/">https://help.didiyun.com/hc/kb/section/1151520/</a><br>三、接下来附上我的学习路径，供大家参考<br><strong>这位大佬讲得特别好，利用VOC2012的训练集训练</strong><br>具体代码以及步骤：<a href="https://github.com/cwxprogrammer/deep-learning-for-image-processing.git">https://github.com/cwxprogrammer/deep-learning-for-image-processing.git</a></p><p>视频理论讲解：<br><a href="https://www.bilibili.com/video/BV1yi4y1g7ro?p=1">https://www.bilibili.com/video/BV1yi4y1g7ro?p=1</a><br>源码讲解：<br><a href="https://www.bilibili.com/video/BV1t54y1C7ra?t=250">https://www.bilibili.com/video/BV1t54y1C7ra?t=250</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习YOLOv3来训练voc模型&lt;br&gt;可想而知一个15年的mac或者老版本的Windows电脑难堪重负。&lt;br&gt;在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。&lt;br&gt;几番抉择后，选择了滴滴云服务器,因为价格！！！&lt;br&gt;&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决部署前后端分离时运行内存太小的问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T07:55:10.290Z</published>
    <updated>2020-11-25T09:18:39.425Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常都会用前后端分离部署我们的项目<br>1.需要使用虚拟机<br>2.内存不够用（因为每个虚拟机最少需要2G内存）<br>3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响<br>4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天</p><p>我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201125155056501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>会自动给你IP<br><img src="https://img-blog.csdnimg.cn/20201125155237451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>重点：我发现云服务器恰好解决了我的燃眉之急，解决了我囊中羞涩不能买高配电脑的痛苦。</p><p>我用的是滴滴云服务器，便宜。<br>你租一个云服务器，自带centos7.6<br>才不到几毛钱。<br>而且买时长，你只要关了就不算时长，很nice。</p><p>解决了硬件问题<br>具体部署视频羊哥已经讲得很详细了：<br>贴个视频链接：<br><a href="https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710">https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们通常都会用前后端分离部署我们的项目&lt;br&gt;1.需要使用虚拟机&lt;br&gt;2.内存不够用（因为每个虚拟机最少需要2G内存）&lt;br&gt;3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响&lt;br&gt;4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天&lt;/p&gt;
&lt;p&gt;我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测②传统检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:49:55.278Z</published>
    <updated>2020-11-24T05:58:14.207Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务</p><p><strong>什么是传统目标检测？</strong><br>首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？<br>传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器</p><a id="more"></a><p>即首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。下面我们对这三个阶段分别进行介绍</p><p>2.2.1区域选取<br>这一步是为了对目标的位置进行定位。由于目标可能出现在图像的任何位置，而且目标的大小、长宽比例也不确定，所以最初采用滑动窗口的策略对整幅图像进行遍历，而且需要设置不同的尺度，不同的长宽比。这种穷举的策略虽然包含了目标所有可能出现的位置，但是缺点也是显而易见的：时间复杂度太高，产生冗余窗口太多，这也严重影响后续特征提取和分类的速度和性能。（实际上由于受到时间复杂度的问题，滑动窗口的长宽比一般都是固定的设置几个，所以对于长宽比浮动较大的多类别目标检测，即便是滑动窗口遍历也不能得到很好的区域）</p><p>2.2.2特征的设计<br>传统检测方法的特征提取算法主要有两种:HOG特征和lbp算法<br>HOG：方向梯度直方图（Histogram of Oriented Gradient, HOG）。使用梯度直方图来描述的形状特征。主要在行人检测方面。从名字可知，主要将图像中的pixel的方向变化作为特征。因为梯度变化主要是发生在物体边缘，这样就可以知道物体的大致形状。可以进行物体分类或者检测。经典的特征提取一般需要一些超参，比如窗口大小等。<br>提取方法：讲一个image灰度化—&gt;颜色空间的标准化—&gt;计算图像每个像素的梯度        —&gt;将图像划分成小cells—&gt;统计每个cell的梯度直方图    —&gt; 将每几个cell组成一个block—&gt;将图像image内的所有block的HOG特征descriptor串联起来。                                                                                       Lbp算法：LBP（Local Binary Pattern，局部二值模式），反映了局部的纹理特征，跟一个像素的邻域有关。对每个像素的邻域做减法，大于用1表示，否则用0表示则产生了一个二进制数来表示这个像素的局部纹理。这个邻域其实也相当于一个window，window的形状也是可以改变的。</p><p>2.2.3分类器的设计<br>一、利用AdaBoost算法进行训练<br>并不是所有特征都是有用的，AdaBoost特征分类器具有特征选择的能力。<br>AdaBoost 将一系列的弱分类器通过线性组合，构成一个强分类器，<br>如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20201124101332709.gif#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201124101404821.gif#pic_center" alt="在这里插入图片描述"><br>是一个强分类器。</p><p><img src="https://img-blog.csdnimg.cn/2020112410144766.gif#pic_center" alt="在这里插入图片描述">是一个弱分类器，其为一个简单的阈值函数<br><img src="https://img-blog.csdnimg.cn/20201124101601130.gif#pic_center" alt="在这里插入图片描述">为阈值，<br><img src="https://img-blog.csdnimg.cn/20201124101640957.gif#pic_center" alt="在这里插入图片描述">，<br><img src="https://img-blog.csdnimg.cn/20201124101705301.gif#pic_center" alt="在这里插入图片描述">为系数。</p><p>二、训练弱分类器<br>计算所有训练样本的特征值，并将其从小到大排序，随机选取一个特征值作为阈值，把所有元素分为两部分，小于阈值的一部分分类为人脸，大于阈值的一部分分类为非人脸。如下图所示，红色表示人脸，蓝色表示非人脸。</p><p>假如有5个样本，前两个为人脸，后三个为非人脸，用11000表示。如果阈值在第一个之前，通过弱分类器判定为：00000，有两个误差，如果阈值在第一个和第二个之间，通过弱分类器判定为：10000，有1个误差，如果阈值在第二个和第三个之间，通过弱分类器判定为：11000，有0个误差，依次类推，这样共有6个误差，然后从中找到一个误差最小的当成阈值，这样就训练好了一个最优的弱分类器。</p><p><img src="https://img-blog.csdnimg.cn/20201124101841712.gif#pic_center" alt="在这里插入图片描述"><br>三、训练强分类器<br>假设有N个训练样本</p><p><img src="https://img-blog.csdnimg.cn/20201124101922423.gif#pic_center" alt="在这里插入图片描述"><br>,其中有M个正样本，L个负样本，如果<img src="https://img-blog.csdnimg.cn/20201124102024949.gif#pic_center" alt="在这里插入图片描述"></p><p>是人脸图像，则<img src="https://img-blog.csdnimg.cn/20201124102039875.gif#pic_center" alt="在这里插入图片描述"></p><p>, 否则<img src="https://img-blog.csdnimg.cn/20201124102051958.gif#pic_center" alt="在这里插入图片描述"></p><p>其步骤如下：<img src="https://img-blog.csdnimg.cn/20201124102108830.gif#pic_center" alt="在这里插入图片描述"></p><p>每一级分类器使用的训练集中的负样本，都是上一级被错分的，即false positive，误检率或假阳性。这使得下一级分类器更加关注那些更难的（容易被错分的）样本。</p><p>2、2、4 总结：<br>传统检测历史久远，然而一直以来存在着两个主要问题：<br>1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余<br>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是传统目标检测？&lt;/strong&gt;&lt;br&gt;首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？&lt;br&gt;传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测①创建数据集</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-11-24T05:49:37.858Z</published>
    <updated>2020-11-24T05:57:49.491Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务<br>一、研究问题<br>目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。</p><a id="more"></a><p>目标检测的任务是找出图像中所有感兴趣的目标，确定它们的位置和类别。<br>图像识别有四大类任务：<br>分类（Classification）： 解决”what”。<br>定位（Location）：解决”where“。<br>检测（Detection）：解决”what &amp; where“。<br>分割（Segmentation）：分为 实例分割（Instance-level）和 语义分割（semantic segmentation）。解决“每一个像素属于哪个实例或哪一类”。</p><p><img src="https://img-blog.csdnimg.cn/2020112316015579.png#pic_center" alt="在这里插入图片描述"></p><p>1.2 问题特性<br>由于各类物体有不同的外观、形状、姿态，加上成像时光照，遮挡等因素的干扰，目标检测一直是计算机视觉领域最具有挑战的问题。<br>除了图像分类以外，目标检测要解决的核心问题是：<br>1、目标可能出现在图像的任何位置。<br>2、目标有各种不同的大小。<br>3、目标有各种不同的形状。<br>则如果用矩形框来定义目标，则矩形框需要有不同的宽高比。由于目标的宽高比不同，因此采用传统的滑动窗口+图像缩放的方案解决通用目标检测问题的成本太高。</p><p>二、算法分析<br>2.1 目标检测数据集<br>Pascal Voc和COCO是目标检测任务最常用的数据集</p><p>2.1.1 PASCAL VOC<br>Pascal 的全程是 Pattern Analysis, Statical Modeling and Computational Learning。<br>PASCAL VOC 挑战赛是视觉对象的分类识别和检测的一个基准测试，提供了检测算法和学习性能的标准图像注释数据集和标准的评估系统。<br><a href="https://pjreddie.com/media/files/VOC2012_doc.pdf">https://pjreddie.com/media/files/VOC2012_doc.pdf</a><br>2.1.1.1Pascal Voc数据集格式分析<br>1）文件结构<br><img src="https://img-blog.csdnimg.cn/20201123191037131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>数据集下载后解压得到一个名为VOCdevkit的文件夹，该文件夹结构如下：<br>Annotations //xml文件，该文件是对图片的解释，每张图片都对应一个同名的xml文件。<br>ImageSets //txt文件，txt文件中每行都包含图片的名称，末尾会加上±1表示正负样本<br>针对目标检测主要看Main<br>——Action<br>——Layout<br>——Main<br>——Segmentation<br>JPEGImages //数据集的原图片<br>SegmentationClass //图片，语义分割相关<br>SegmentationObject //图片，实例分割相关</p><p> 2.1.1.2 创建自己的pascal voc数据集<br> 下载图像标记软件<br>  git clone  <a href="https://github.com/tzutalin/labelimg">https://github.com/tzutalin/labelimg</a><br>  步骤：<br>  anaconda+pip install labelImg<br>  注：在这里我要说一句：python是Python，anaconda是anaconda,你选择环境时候可以二选一，个人建议anaconda,确实省力。<br>如下截图：</p><p><img src="https://img-blog.csdnimg.cn/20201123190056211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>修改标注类别信息—&gt;设置图像文件所在目录以及标注文件保存目录-&gt;标注图像并保存-&gt;打开labelImg<br>利用create/nRectBox截取并生成xml<br>具体代码：<br>1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchRename</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    批量重命名文件夹中的图片文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 我的图片文件夹路径</span></span><br><span class="line">        self.path = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        total_num = <span class="built_in">len</span>(filelist)</span><br><span class="line">        i = <span class="number">1</span>       <span class="comment"># 设置第一个文件名</span></span><br><span class="line">        n = <span class="number">6</span>       <span class="comment"># 设置文件名长度，如000001，长度为6</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment"># 这里修改的是jpg文件，如果要修改其他类型的文件，请手动将下面两个&#x27;.jpg&#x27;修改为对应的文件后缀</span></span><br><span class="line">            <span class="keyword">if</span> item.endswith(<span class="string">&#x27;.jpg&#x27;</span>):</span><br><span class="line">                n = <span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">str</span>(i))</span><br><span class="line">                src = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">                dst = os.path.join(os.path.abspath(self.path), <span class="built_in">str</span>(<span class="number">0</span>) * n + <span class="built_in">str</span>(i) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.rename(src, dst)</span><br><span class="line">                    print(<span class="string">&#x27;converting %s to %s ...&#x27;</span> % (src, dst))</span><br><span class="line">                    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;total %d to rename &amp; converted %d jpgs&#x27;</span> % (total_num, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = BatchRename()</span><br><span class="line">    demo.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若之后想加图片，只需要把i改了<br>2）<br>labelImg打标签，把图片保存到Annotations文件夹<br>3)<br>生成Main文件夹下面的txt文件<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">trainval_percent = <span class="number">0.7</span>      <span class="comment"># 训练集和验证集 占 数据集 的比例</span></span><br><span class="line">train_percent = <span class="number">0.6</span>         <span class="comment"># 训练集 占 训练集和验证集 的比例</span></span><br><span class="line"><span class="comment"># 把xml路径修改为自己的Annotations文件夹路径</span></span><br><span class="line">xmlfilepath = <span class="string">&#x27;E:/xxx/VOC/Annotations&#x27;</span></span><br><span class="line"><span class="comment"># 把保存路径修改为自己的Main文件夹路径</span></span><br><span class="line">savepath = <span class="string">&#x27;E:/xxx/VOC/ImageSets/Main&#x27;</span></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(<span class="built_in">list</span>, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line"></span><br><span class="line">ftrainval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/trainval.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftest = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftrain = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/train.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/val.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    name = total_xml[i][:<span class="number">-4</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        ftrainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            ftrain.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fval.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ftest.write(name)</span><br><span class="line"></span><br><span class="line">ftrainval.close()</span><br><span class="line">ftrain.close()</span><br><span class="line">fval.close()</span><br><span class="line">ftest.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，我们理解了Pascal voc的格式，并且可以创造属于自己的数据集进行对图片进行目标检测任务的实现。</p><p>2.1.2 COCO<br>这里简单说一下coco<br>MS COCO的全称是Microsoft Common Objects in Context，起源于微软于2014年出资标注的Microsoft COCO数据集，与ImageNet竞赛一样，被视为是计算机视觉领域最受关注和最权威的比赛之一。<br>COCO数据集是一个大型的、丰富的物体检测，分割和字幕数据集。这个数据集以scene understanding为目标，主要从复杂的日常场景中截取，图像中的目标通过精确的segmentation进行位置的标定。图像包括91类目标，328,000影像和2,500,000个label。目前为止有语义分割的最大数据集，提供的类别有80 类，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。</p><p>总的来说,无论数据集以什么格式存储在txt，xml甚至是工作表中。我们需要在算法的实现代码中实现能定位并使用这些各类数据的表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;br&gt;一、研究问题&lt;br&gt;目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法（续）</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/</id>
    <published>2020-11-24T05:49:20.680Z</published>
    <updated>2020-11-24T05:59:05.379Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型</p><p><img src="https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>相比于之前的网络架构，Yolov3有两点提升：<br> <a id="more"></a><br>1)残差结构<br>神经网络训练的过程就是调整参数的过程，可以调整的参数越多，意味着调整的自由度越大，从而逼近效果越好。因此层次越深，可以表示的特征抽象程度越高，可以做出很多只有人类才能做到的需要高度抽象理解能力的事情，在某些特定任务上“效果越好”。<br>然而随着网络深度增加，准确度增加，神经网络会产生梯度消失/梯度爆炸的问题。<br>梯度消失/梯度爆炸指本质上因为梯度反向传播中的连乘效应，造成网络权值更新不稳定，从而使此深层网络的学习几乎等价于只有后几层的浅层网络的学习了，造成网络退化问题。</p><p>Darknet的残差结构(在resnet论文提出的概念)解决了这个问题<br><img src="https://img-blog.csdnimg.cn/20201124125953185.gif#pic_center" alt="在这里插入图片描述"></p><p>在上图的残差网络结构图中，通过 “shortcut connections (捷径连接)” 的方式，直接把输入 x 传到输出作为初始结果，输出结果为 H(x)=F(x)+x，当 F(x)=0 时，那么 H(x)=x，也就是上面所提到的恒等映射。于是，残差结构相当于将学习目标改变了，不再是学习一个完整的输出，而是目标值H(X) 和 x 的差值，也就是所谓的残差 F(x) = H(x)-x，因此，后面的训练目标就是要将残差结果逼近于 0，使到随着网络加深，准确率不下降。<br>resnet论文：<a href="https://arxiv.org/pdf/1512.03385v1.pdf">https://arxiv.org/pdf/1512.03385v1.pdf</a><br>《Deep Residual Learning》——何恺明2016cvpr<br><img src="https://img-blog.csdnimg.cn/20201124130034244.gif#pic_center" alt="在这里插入图片描述"></p><p>feature map 通过 Residual 残差模块前后其 shape 不变。并且，在输入的参数中，要保证 input_channel = filter_num2，否则相加的操作会因为 shape 不同而无法进行。<br>2)多尺度预测<br>同时，yolov3也在多尺度预测上做出改进(类似于FPN)<br>多尺度预测实现了从基础网络输出多个不同尺度作为输入，解决图像中待检测物体大小不同的问题。<br>利用网络对物体进行检测时，浅层网络分辨率高，学到的是图片的细节特征，深层网络，分辨率低，学到的更多的是语义特征，如报告2、3、2提到。<br>因此我们选择利用图像的各个尺度进行训练和测试。可以通过缩放图片提取多组特征图预测，但是想必这样及其消耗时间——因此直接使用卷积网络中产生的各层特征图分别进行预测<br><img src="https://img-blog.csdnimg.cn/20201124130119618.gif#pic_center" alt="在这里插入图片描述"></p><p>《Feature Pyramid Networks for Object Detection》——2017CVPR<br>如上页图Darknet53，以scale2为例，从尺度1中的倒数第二层的卷积层上采样（× 2），再与最后一个 16 × 16 大小的特征图相加，再次通过多个卷积后输出box信息，相比尺度1变大两倍。</p><p>上采样的作用是在后面 YOLOv3 网络中进行相加操作时保证两个 feature map 的宽和高相同，其具体操作为：将输入的 feature map 的宽高都乘 2，得到新的 feature map。如下图代码</p><p>可以看到，route_1，route_2，input_data三个不同尺度的输出到后续网络</p><p><img src="https://img-blog.csdnimg.cn/20201124130202892.gif#pic_center" alt="在这里插入图片描述"></p><p>3.2.2输出定义<br>先来看yolov3的整体结构，随后具体介绍yolov3输出各个维度定义<br>在结构中，我们设置用的数据集类别为80种。<br>下图中左半部分虚线框内即为Darknet-53网络机构，可以看到该网络结构的输入为 416×416×3，之后通过一个3×3的卷积层来扩增通道数。接下来通过堆叠一系列Residual Block来构建网络，其具体个数为[1, 2, 8, 8, 4]，最终主干网络输出大小为13×13、26×26、52×52三个大小的特征图，目的是可以检测到图像中更小的物体。特征图分割越密集，则每一个特征点相对于原图中的区域越小，从而可以监测到更小的物体。这部分即是上一节提到的“多分类预测”<br><img src="https://img-blog.csdnimg.cn/20201124130336823.gif#pic_center" alt="在这里插入图片描述"></p><p>网络结构的右半部分包括将主干网络Darknet-53的输出进行生成特征金字塔。具体做法为首先将13×13×1024的特征层进行上采样变为26×26×256，再与26×26×512的特征层进行堆叠，其结果为26×26×768大小的特征；同理，大小为52×52×256的特征层与下一层网络堆叠后的结果为52×52×384。<br>     对于这三个堆叠后的结果，分别再进行5次卷积操作，最后接上一个3×3的卷积和1×1的卷积，用于输出预测结果，三个层对应的输出结果大小分别为13×13×255、26×26×255、52×52×255。<br>这里结合下图我们可以看到，前两个维度很明显代表了图像被分网格的行/列数，255是我们根据不同类型的数据集，在yolov3中得到的通道数channel</p><p><img src="https://img-blog.csdnimg.cn/20201124130409593.gif#pic_center" alt="在这里插入图片描述"></p><p>这里的每个输出的通道数都是 3x(80+5)，这是因为 YOLOv3 设定的是每个网格单元预测3个检测框，而且每个检测框需要有 (x, y, w, h, confidence) 五个基本参数，然后还要有80个类别的概率。<br>其中255 = (4+1+80)×3，4表示一个边界框对应的调整参数x, y, w, h，1表示置信度，比如我们用COCO数据集，80表示COCO数据集分为80个类，3表示特征图上的每一个点对应有3个anchor。</p><p>代码中的predict_transform函数获取了前级的输入，并进行处理。<br><img src="https://img-blog.csdnimg.cn/20201124130433634.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201124130447497.gif#pic_center" alt="在这里插入图片描述"></p><p>在class darknet()的yolo模块代码后部分，对于每个yolo层的输出先用predict_transform()变成每行为一个anchor对应的预测值的形式(不看batch_size这个维度，x剩下的维度可以看成一个二维tensor)，这样3个yolo层的预测值按照每个方框对应的行的维度进行连接。得到了这张图处所有anchor的预测值，使后面的NMS等操作可以一次完成<br><img src="https://img-blog.csdnimg.cn/2020112413051535.gif#pic_center" alt="在这里插入图片描述"></p><p>这是由北工大模式识别二组共同创作！！！<br>转载请注明出处，谢谢！！<br>下一章（续2）会简单理解一下我最近研究损失函数所遇到的问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;相比于之前的网络架构，Yolov3有两点提升：&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:48:46.164Z</published>
    <updated>2020-11-24T05:58:51.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型<br><img src="https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。<br> <a id="more"></a><br>物体检测的两个步骤可以概括为：<br>步骤一：检测目标位置（生成矩形框）<br>步骤二：对目标物体进行分类<br>物体检测主流的算法框架大致分为one-stage与two-stage。two-stage算法代表有R-CNN系列，one-stage算法代表有Yolo系列。可以说，two-stage算法将步骤一与步骤二分开执行，输入图像先经过候选框生成网络（例如faster rcnn中的RPN网络），再经过分类网络；one-stage算法将步骤一与步骤二同时执行，输入图像只经过一个网络，生成的结果中同时包含位置与类别信息。two-stage与one-stage相比，精度高，但是计算量更大，所以运算较慢。</p><p>我们这里介绍的两种深度学习算法，都是one-stage算法。<br>基于回归方法的深度学习目标检测算法，他们一步到位，其基本步骤是: 给定一张图像, 通过设定合理的输出向量，使用回归的方式输出这个目标的边框和类别，一步到位。这种算法的优点是速度快，但是对于密集的小样本来说检测比较困难。比如 YOLO、SSD 等。</p><p>2.3.1 YOLO</p><p>2.3.1.1YOLO介绍<br>YOLO系列论文提出了一个新的物体检测的方法：You Only Look Once（YOLO）</p><p>YOLO 的核心思想就是把目标检测转变成一个回归问题，利用整张图作为网络的输入，仅仅经过一个神经网络，得到bounding box（边界框） 的位置及其所属的类别。</p><p>2.3.1.2 YOLOv1<br>论文：<a href="https://arxiv.org/pdf/1506.02640.pdf">https://arxiv.org/pdf/1506.02640.pdf</a><br>YOLOv1是最早版本的YOLO，以下从概念上简单介绍v1的原理<br>1）网络结构<br><img src="https://img-blog.csdnimg.cn/20201124121158625.gif#pic_center" alt="在这里插入图片描述"></p><p>输入：448<em>448</em>3的彩色图片<br>中间层：若干卷积层和最大池化层<br>全连接层：2个全连接层，用来预测位置和类别概率值</p><p>2）实现细节<br>分类器的输出是一个one-hot vector，而检测器的输出是一个框(Bounding Box)。框，该怎么表示？<br><img src="https://img-blog.csdnimg.cn/20201124121259121.gif#pic_center" alt="在这里插入图片描述"></p><p>bounding box<br>总的来说，S×S 个网格，每个网格要预测 B个bounding box ，还要预测 C 个类。网络输出就是一个 S × S × (5×B+C) 的张量。<br><img src="https://img-blog.csdnimg.cn/20201124121342496.gif#pic_center" alt="在这里插入图片描述"></p><p>在实际过程中，YOLOv1把一张图片划分为了7×7个网格，并且每个网格预测2个Box（Box1和Box2），20个类别。所以实际上，S=7，B=2，C=20。那么网络输出的shape也就是：7×7×30。</p><p>3）损失函数和优化器<br>神经网络结构确定之后，训练效果好坏，由Loss函数和优化器决定。Yolo v1使用普通的梯度下降法作为优化器。这里重点解读一下Yolo v1使用的Loss函数：<br><img src="https://img-blog.csdnimg.cn/20201124121743750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>损失是三部分：坐标预测损失、置信度预测损失、类别预测损失的加和</p><p>思考：对于x和y用差平方，而对于宽和高为什么进行开根处理？<br>——假设宽和高使用与x，y相同处理方式（直接差平方），当预测值与真实值图像偏移相同大小时，我们依此法计算出的误差是固定的，然而这与实际不符。实际对于图像框尺度大小不同的区域，相同偏移量下，小尺度图像效果是很差的，而较大尺度图像则效果不错。因此，此损失函数的设计细节是作者为使实验结果更加准确而设计的。<br>置信度预测损失：是正负样本求平方加和<br>类别预测损失：预测值减去真实值求平方</p><p>4）优缺点</p><p>优点：更快更准迁移能力强<br>缺点：对相互靠近的物体，以及很小的群体检测效果不好；对不常见的角度的目标泛化性能偏弱</p><p>升级版 YOLOv2<br>YOLOv2论文：<a href="https://arxiv.org/abs/1612.08242">https://arxiv.org/abs/1612.08242</a></p><p>为提高物体定位精准性和召回率，YOLO作者提出了 “YOLO9000: Better, Faster, Stronger” (Joseph Redmon, Ali Farhadi, CVPR 2017, Best Paper Honorable Mention)，相比YOLOv1 提高了训练图像的分辨率；引入了faster rcnn中anchor box的思想，对网络结构的设计进行了改进，输出层使用卷积层替代YOLO的全连接层，联合使用coco物体检测标注数据和imagenet物体分类标注数据训练物体检测模型。相比YOLO，YOLO9000在识别种类、精度、速度、和定位准确性等方面都有大大提升。</p><p>2.3.2 SSD<br>YOlO和SSD算法作为“一步到位”算法的代表，他们的主要区别就是yolo只利用了末端特征图的信息，而SSD利用了最后几层特征图的信息，所以，从理论上说，SSD算法较yolo（起码是yolov1）来说，精确度必然更高。</p><p>卷积神经网络各层特征信息主要有如下区别：<br>1、低层卷积可以捕捉到更多的细节信息，高层卷积可以捕捉到更多的抽象信息。<br>2、低层特性更关心“在哪里”，但分类准确度不高，而高层特性更关心“是什么”，但丢失了物体的位置信息。<br>——《Visualizing and Understanding Convolutional Networks》.（可视化理解卷积神经网络）2014</p><p>SSD正是利用不同尺度检测图片中不同大小和类别的目标物体，获得了很好的效果。<br><img src="https://img-blog.csdnimg.cn/20201124123639607.gif#pic_center" alt="在这里插入图片描述"></p><p>VGG-16网络</p><p>对于每个特征图来说，SSD引入初始框的概念。对于不同的特征图，SSD总的尺度设计原则就是：随着网络层数加深（特征图的变小），初始框的尺度线性增加。最小的初始框尺度为0.2，最大的初始框尺度为0.9。</p><p><img src="https://img-blog.csdnimg.cn/20201124123710547.gif#pic_center" alt="在这里插入图片描述"></p><p>3.实例解析<br>3.1YOLO实例说明<br>以下对YOLOv3进行介绍，代码部分来自<br>tf2.0yolov3——malin9402,yunyang1994<br><a href="https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3">https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3</a></p><p>pytorch :<br><a href="https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch">https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch</a></p><p>3.1.1网络结构<br>随着CNN的发展和大量研究人员的努力，产生了数篇影响深远的论文，解决了在实际应用的诸多问题。yolov3借鉴了许多论文和思路，完善了yolo网络架构。<br>本节从原理和代码上介绍yolov3的网络架构，并深入探讨其网络架构上的进步和优点。</p><p>yolov3用darknet53作为基础网络架构</p><p><img src="https://img-blog.csdnimg.cn/20201124124149243.gif#pic_center" alt="Darknet53"></p><p>命名来源于它有53层卷积层=  2 + 1<em>2+1 +2</em>2+1 +8<em>2+1 +8</em>2+1 +4*2+1</p><p>未完待续——下一篇我会说一下YOLOV3相对于之前的网络架构的提升，相比之下，算力要求也会随之提升，所以我们需要借助滴滴云DAI平台来跑我们的代码项目<br><img src="https://img-blog.csdnimg.cn/20201124125105797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="输入我的AI大师码：8996，享受⑨折优惠，让自己的算法检测像扫码一样简单"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java Docker</title>
    <link href="http://example.com/2020/11/18/Java%20Docker/"/>
    <id>http://example.com/2020/11/18/Java%20Docker/</id>
    <published>2020-11-18T03:28:11.845Z</published>
    <updated>2020-11-18T03:28:11.845Z</updated>
    
    <content type="html"><![CDATA[<p>对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：</p><a id="more"></a><ul><li>如果未配置合适的JVM堆和元数据区，直接内存等参数；java有可能试图使用超过容器限制的内存，最终被容器OOM kill ，或者自身发生OOM</li><li>错误的判断了可获取的CPU资源。如：Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程</li></ul><p>与虚拟机及其相似，但是也有不同，并不是虚拟化技术，而是一种轻量级的隔离技术。轻量级的开销必然也就在成了许多微妙差异。<br><strong>这就是所谓的Ergonomics机制，例如</strong>：<br>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1/64；并将堆最大值，设置为系统内存的 1/4。<br>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。<br>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房间是给我住的。<br><img src="https://img-blog.csdnimg.cn/20201118112227927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>解决办法：升级到JDK8最新的更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
