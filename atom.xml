<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-24T05:58:14.207Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>目标检测②传统检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:49:55.278Z</published>
    <updated>2020-11-24T05:58:14.207Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务</p><p><strong>什么是传统目标检测？</strong><br>首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？<br>传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器</p><a id="more"></a><p>即首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。下面我们对这三个阶段分别进行介绍</p><p>2.2.1区域选取<br>这一步是为了对目标的位置进行定位。由于目标可能出现在图像的任何位置，而且目标的大小、长宽比例也不确定，所以最初采用滑动窗口的策略对整幅图像进行遍历，而且需要设置不同的尺度，不同的长宽比。这种穷举的策略虽然包含了目标所有可能出现的位置，但是缺点也是显而易见的：时间复杂度太高，产生冗余窗口太多，这也严重影响后续特征提取和分类的速度和性能。（实际上由于受到时间复杂度的问题，滑动窗口的长宽比一般都是固定的设置几个，所以对于长宽比浮动较大的多类别目标检测，即便是滑动窗口遍历也不能得到很好的区域）</p><p>2.2.2特征的设计<br>传统检测方法的特征提取算法主要有两种:HOG特征和lbp算法<br>HOG：方向梯度直方图（Histogram of Oriented Gradient, HOG）。使用梯度直方图来描述的形状特征。主要在行人检测方面。从名字可知，主要将图像中的pixel的方向变化作为特征。因为梯度变化主要是发生在物体边缘，这样就可以知道物体的大致形状。可以进行物体分类或者检测。经典的特征提取一般需要一些超参，比如窗口大小等。<br>提取方法：讲一个image灰度化—&gt;颜色空间的标准化—&gt;计算图像每个像素的梯度        —&gt;将图像划分成小cells—&gt;统计每个cell的梯度直方图    —&gt; 将每几个cell组成一个block—&gt;将图像image内的所有block的HOG特征descriptor串联起来。                                                                                       Lbp算法：LBP（Local Binary Pattern，局部二值模式），反映了局部的纹理特征，跟一个像素的邻域有关。对每个像素的邻域做减法，大于用1表示，否则用0表示则产生了一个二进制数来表示这个像素的局部纹理。这个邻域其实也相当于一个window，window的形状也是可以改变的。</p><p>2.2.3分类器的设计<br>一、利用AdaBoost算法进行训练<br>并不是所有特征都是有用的，AdaBoost特征分类器具有特征选择的能力。<br>AdaBoost 将一系列的弱分类器通过线性组合，构成一个强分类器，<br>如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20201124101332709.gif#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201124101404821.gif#pic_center" alt="在这里插入图片描述"><br>是一个强分类器。</p><p><img src="https://img-blog.csdnimg.cn/2020112410144766.gif#pic_center" alt="在这里插入图片描述">是一个弱分类器，其为一个简单的阈值函数<br><img src="https://img-blog.csdnimg.cn/20201124101601130.gif#pic_center" alt="在这里插入图片描述">为阈值，<br><img src="https://img-blog.csdnimg.cn/20201124101640957.gif#pic_center" alt="在这里插入图片描述">，<br><img src="https://img-blog.csdnimg.cn/20201124101705301.gif#pic_center" alt="在这里插入图片描述">为系数。</p><p>二、训练弱分类器<br>计算所有训练样本的特征值，并将其从小到大排序，随机选取一个特征值作为阈值，把所有元素分为两部分，小于阈值的一部分分类为人脸，大于阈值的一部分分类为非人脸。如下图所示，红色表示人脸，蓝色表示非人脸。</p><p>假如有5个样本，前两个为人脸，后三个为非人脸，用11000表示。如果阈值在第一个之前，通过弱分类器判定为：00000，有两个误差，如果阈值在第一个和第二个之间，通过弱分类器判定为：10000，有1个误差，如果阈值在第二个和第三个之间，通过弱分类器判定为：11000，有0个误差，依次类推，这样共有6个误差，然后从中找到一个误差最小的当成阈值，这样就训练好了一个最优的弱分类器。</p><p><img src="https://img-blog.csdnimg.cn/20201124101841712.gif#pic_center" alt="在这里插入图片描述"><br>三、训练强分类器<br>假设有N个训练样本</p><p><img src="https://img-blog.csdnimg.cn/20201124101922423.gif#pic_center" alt="在这里插入图片描述"><br>,其中有M个正样本，L个负样本，如果<img src="https://img-blog.csdnimg.cn/20201124102024949.gif#pic_center" alt="在这里插入图片描述"></p><p>是人脸图像，则<img src="https://img-blog.csdnimg.cn/20201124102039875.gif#pic_center" alt="在这里插入图片描述"></p><p>, 否则<img src="https://img-blog.csdnimg.cn/20201124102051958.gif#pic_center" alt="在这里插入图片描述"></p><p>其步骤如下：<img src="https://img-blog.csdnimg.cn/20201124102108830.gif#pic_center" alt="在这里插入图片描述"></p><p>每一级分类器使用的训练集中的负样本，都是上一级被错分的，即false positive，误检率或假阳性。这使得下一级分类器更加关注那些更难的（容易被错分的）样本。</p><p>2、2、4 总结：<br>传统检测历史久远，然而一直以来存在着两个主要问题：<br>1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余<br>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是传统目标检测？&lt;/strong&gt;&lt;br&gt;首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？&lt;br&gt;传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测①创建数据集</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-11-24T05:49:37.858Z</published>
    <updated>2020-11-24T05:57:49.491Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务<br>一、研究问题<br>目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。</p><a id="more"></a><p>目标检测的任务是找出图像中所有感兴趣的目标，确定它们的位置和类别。<br>图像识别有四大类任务：<br>分类（Classification）： 解决”what”。<br>定位（Location）：解决”where“。<br>检测（Detection）：解决”what &amp; where“。<br>分割（Segmentation）：分为 实例分割（Instance-level）和 语义分割（semantic segmentation）。解决“每一个像素属于哪个实例或哪一类”。</p><p><img src="https://img-blog.csdnimg.cn/2020112316015579.png#pic_center" alt="在这里插入图片描述"></p><p>1.2 问题特性<br>由于各类物体有不同的外观、形状、姿态，加上成像时光照，遮挡等因素的干扰，目标检测一直是计算机视觉领域最具有挑战的问题。<br>除了图像分类以外，目标检测要解决的核心问题是：<br>1、目标可能出现在图像的任何位置。<br>2、目标有各种不同的大小。<br>3、目标有各种不同的形状。<br>则如果用矩形框来定义目标，则矩形框需要有不同的宽高比。由于目标的宽高比不同，因此采用传统的滑动窗口+图像缩放的方案解决通用目标检测问题的成本太高。</p><p>二、算法分析<br>2.1 目标检测数据集<br>Pascal Voc和COCO是目标检测任务最常用的数据集</p><p>2.1.1 PASCAL VOC<br>Pascal 的全程是 Pattern Analysis, Statical Modeling and Computational Learning。<br>PASCAL VOC 挑战赛是视觉对象的分类识别和检测的一个基准测试，提供了检测算法和学习性能的标准图像注释数据集和标准的评估系统。<br><a href="https://pjreddie.com/media/files/VOC2012_doc.pdf">https://pjreddie.com/media/files/VOC2012_doc.pdf</a><br>2.1.1.1Pascal Voc数据集格式分析<br>1）文件结构<br><img src="https://img-blog.csdnimg.cn/20201123191037131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>数据集下载后解压得到一个名为VOCdevkit的文件夹，该文件夹结构如下：<br>Annotations //xml文件，该文件是对图片的解释，每张图片都对应一个同名的xml文件。<br>ImageSets //txt文件，txt文件中每行都包含图片的名称，末尾会加上±1表示正负样本<br>针对目标检测主要看Main<br>——Action<br>——Layout<br>——Main<br>——Segmentation<br>JPEGImages //数据集的原图片<br>SegmentationClass //图片，语义分割相关<br>SegmentationObject //图片，实例分割相关</p><p> 2.1.1.2 创建自己的pascal voc数据集<br> 下载图像标记软件<br>  git clone  <a href="https://github.com/tzutalin/labelimg">https://github.com/tzutalin/labelimg</a><br>  步骤：<br>  anaconda+pip install labelImg<br>  注：在这里我要说一句：python是Python，anaconda是anaconda,你选择环境时候可以二选一，个人建议anaconda,确实省力。<br>如下截图：</p><p><img src="https://img-blog.csdnimg.cn/20201123190056211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>修改标注类别信息—&gt;设置图像文件所在目录以及标注文件保存目录-&gt;标注图像并保存-&gt;打开labelImg<br>利用create/nRectBox截取并生成xml<br>具体代码：<br>1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchRename</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    批量重命名文件夹中的图片文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 我的图片文件夹路径</span></span><br><span class="line">        self.path = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        total_num = <span class="built_in">len</span>(filelist)</span><br><span class="line">        i = <span class="number">1</span>       <span class="comment"># 设置第一个文件名</span></span><br><span class="line">        n = <span class="number">6</span>       <span class="comment"># 设置文件名长度，如000001，长度为6</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment"># 这里修改的是jpg文件，如果要修改其他类型的文件，请手动将下面两个&#x27;.jpg&#x27;修改为对应的文件后缀</span></span><br><span class="line">            <span class="keyword">if</span> item.endswith(<span class="string">&#x27;.jpg&#x27;</span>):</span><br><span class="line">                n = <span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">str</span>(i))</span><br><span class="line">                src = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">                dst = os.path.join(os.path.abspath(self.path), <span class="built_in">str</span>(<span class="number">0</span>) * n + <span class="built_in">str</span>(i) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.rename(src, dst)</span><br><span class="line">                    print(<span class="string">&#x27;converting %s to %s ...&#x27;</span> % (src, dst))</span><br><span class="line">                    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;total %d to rename &amp; converted %d jpgs&#x27;</span> % (total_num, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = BatchRename()</span><br><span class="line">    demo.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若之后想加图片，只需要把i改了<br>2）<br>labelImg打标签，把图片保存到Annotations文件夹<br>3)<br>生成Main文件夹下面的txt文件<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">trainval_percent = <span class="number">0.7</span>      <span class="comment"># 训练集和验证集 占 数据集 的比例</span></span><br><span class="line">train_percent = <span class="number">0.6</span>         <span class="comment"># 训练集 占 训练集和验证集 的比例</span></span><br><span class="line"><span class="comment"># 把xml路径修改为自己的Annotations文件夹路径</span></span><br><span class="line">xmlfilepath = <span class="string">&#x27;E:/xxx/VOC/Annotations&#x27;</span></span><br><span class="line"><span class="comment"># 把保存路径修改为自己的Main文件夹路径</span></span><br><span class="line">savepath = <span class="string">&#x27;E:/xxx/VOC/ImageSets/Main&#x27;</span></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(<span class="built_in">list</span>, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line"></span><br><span class="line">ftrainval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/trainval.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftest = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftrain = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/train.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/val.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    name = total_xml[i][:<span class="number">-4</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        ftrainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            ftrain.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fval.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ftest.write(name)</span><br><span class="line"></span><br><span class="line">ftrainval.close()</span><br><span class="line">ftrain.close()</span><br><span class="line">fval.close()</span><br><span class="line">ftest.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，我们理解了Pascal voc的格式，并且可以创造属于自己的数据集进行对图片进行目标检测任务的实现。</p><p>2.1.2 COCO<br>这里简单说一下coco<br>MS COCO的全称是Microsoft Common Objects in Context，起源于微软于2014年出资标注的Microsoft COCO数据集，与ImageNet竞赛一样，被视为是计算机视觉领域最受关注和最权威的比赛之一。<br>COCO数据集是一个大型的、丰富的物体检测，分割和字幕数据集。这个数据集以scene understanding为目标，主要从复杂的日常场景中截取，图像中的目标通过精确的segmentation进行位置的标定。图像包括91类目标，328,000影像和2,500,000个label。目前为止有语义分割的最大数据集，提供的类别有80 类，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。</p><p>总的来说,无论数据集以什么格式存储在txt，xml甚至是工作表中。我们需要在算法的实现代码中实现能定位并使用这些各类数据的表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;br&gt;一、研究问题&lt;br&gt;目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法（续）</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/</id>
    <published>2020-11-24T05:49:20.680Z</published>
    <updated>2020-11-24T05:59:05.379Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型</p><p><img src="https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>相比于之前的网络架构，Yolov3有两点提升：<br> <a id="more"></a><br>1)残差结构<br>神经网络训练的过程就是调整参数的过程，可以调整的参数越多，意味着调整的自由度越大，从而逼近效果越好。因此层次越深，可以表示的特征抽象程度越高，可以做出很多只有人类才能做到的需要高度抽象理解能力的事情，在某些特定任务上“效果越好”。<br>然而随着网络深度增加，准确度增加，神经网络会产生梯度消失/梯度爆炸的问题。<br>梯度消失/梯度爆炸指本质上因为梯度反向传播中的连乘效应，造成网络权值更新不稳定，从而使此深层网络的学习几乎等价于只有后几层的浅层网络的学习了，造成网络退化问题。</p><p>Darknet的残差结构(在resnet论文提出的概念)解决了这个问题<br><img src="https://img-blog.csdnimg.cn/20201124125953185.gif#pic_center" alt="在这里插入图片描述"></p><p>在上图的残差网络结构图中，通过 “shortcut connections (捷径连接)” 的方式，直接把输入 x 传到输出作为初始结果，输出结果为 H(x)=F(x)+x，当 F(x)=0 时，那么 H(x)=x，也就是上面所提到的恒等映射。于是，残差结构相当于将学习目标改变了，不再是学习一个完整的输出，而是目标值H(X) 和 x 的差值，也就是所谓的残差 F(x) = H(x)-x，因此，后面的训练目标就是要将残差结果逼近于 0，使到随着网络加深，准确率不下降。<br>resnet论文：<a href="https://arxiv.org/pdf/1512.03385v1.pdf">https://arxiv.org/pdf/1512.03385v1.pdf</a><br>《Deep Residual Learning》——何恺明2016cvpr<br><img src="https://img-blog.csdnimg.cn/20201124130034244.gif#pic_center" alt="在这里插入图片描述"></p><p>feature map 通过 Residual 残差模块前后其 shape 不变。并且，在输入的参数中，要保证 input_channel = filter_num2，否则相加的操作会因为 shape 不同而无法进行。<br>2)多尺度预测<br>同时，yolov3也在多尺度预测上做出改进(类似于FPN)<br>多尺度预测实现了从基础网络输出多个不同尺度作为输入，解决图像中待检测物体大小不同的问题。<br>利用网络对物体进行检测时，浅层网络分辨率高，学到的是图片的细节特征，深层网络，分辨率低，学到的更多的是语义特征，如报告2、3、2提到。<br>因此我们选择利用图像的各个尺度进行训练和测试。可以通过缩放图片提取多组特征图预测，但是想必这样及其消耗时间——因此直接使用卷积网络中产生的各层特征图分别进行预测<br><img src="https://img-blog.csdnimg.cn/20201124130119618.gif#pic_center" alt="在这里插入图片描述"></p><p>《Feature Pyramid Networks for Object Detection》——2017CVPR<br>如上页图Darknet53，以scale2为例，从尺度1中的倒数第二层的卷积层上采样（× 2），再与最后一个 16 × 16 大小的特征图相加，再次通过多个卷积后输出box信息，相比尺度1变大两倍。</p><p>上采样的作用是在后面 YOLOv3 网络中进行相加操作时保证两个 feature map 的宽和高相同，其具体操作为：将输入的 feature map 的宽高都乘 2，得到新的 feature map。如下图代码</p><p>可以看到，route_1，route_2，input_data三个不同尺度的输出到后续网络</p><p><img src="https://img-blog.csdnimg.cn/20201124130202892.gif#pic_center" alt="在这里插入图片描述"></p><p>3.2.2输出定义<br>先来看yolov3的整体结构，随后具体介绍yolov3输出各个维度定义<br>在结构中，我们设置用的数据集类别为80种。<br>下图中左半部分虚线框内即为Darknet-53网络机构，可以看到该网络结构的输入为 416×416×3，之后通过一个3×3的卷积层来扩增通道数。接下来通过堆叠一系列Residual Block来构建网络，其具体个数为[1, 2, 8, 8, 4]，最终主干网络输出大小为13×13、26×26、52×52三个大小的特征图，目的是可以检测到图像中更小的物体。特征图分割越密集，则每一个特征点相对于原图中的区域越小，从而可以监测到更小的物体。这部分即是上一节提到的“多分类预测”<br><img src="https://img-blog.csdnimg.cn/20201124130336823.gif#pic_center" alt="在这里插入图片描述"></p><p>网络结构的右半部分包括将主干网络Darknet-53的输出进行生成特征金字塔。具体做法为首先将13×13×1024的特征层进行上采样变为26×26×256，再与26×26×512的特征层进行堆叠，其结果为26×26×768大小的特征；同理，大小为52×52×256的特征层与下一层网络堆叠后的结果为52×52×384。<br>     对于这三个堆叠后的结果，分别再进行5次卷积操作，最后接上一个3×3的卷积和1×1的卷积，用于输出预测结果，三个层对应的输出结果大小分别为13×13×255、26×26×255、52×52×255。<br>这里结合下图我们可以看到，前两个维度很明显代表了图像被分网格的行/列数，255是我们根据不同类型的数据集，在yolov3中得到的通道数channel</p><p><img src="https://img-blog.csdnimg.cn/20201124130409593.gif#pic_center" alt="在这里插入图片描述"></p><p>这里的每个输出的通道数都是 3x(80+5)，这是因为 YOLOv3 设定的是每个网格单元预测3个检测框，而且每个检测框需要有 (x, y, w, h, confidence) 五个基本参数，然后还要有80个类别的概率。<br>其中255 = (4+1+80)×3，4表示一个边界框对应的调整参数x, y, w, h，1表示置信度，比如我们用COCO数据集，80表示COCO数据集分为80个类，3表示特征图上的每一个点对应有3个anchor。</p><p>代码中的predict_transform函数获取了前级的输入，并进行处理。<br><img src="https://img-blog.csdnimg.cn/20201124130433634.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201124130447497.gif#pic_center" alt="在这里插入图片描述"></p><p>在class darknet()的yolo模块代码后部分，对于每个yolo层的输出先用predict_transform()变成每行为一个anchor对应的预测值的形式(不看batch_size这个维度，x剩下的维度可以看成一个二维tensor)，这样3个yolo层的预测值按照每个方框对应的行的维度进行连接。得到了这张图处所有anchor的预测值，使后面的NMS等操作可以一次完成<br><img src="https://img-blog.csdnimg.cn/2020112413051535.gif#pic_center" alt="在这里插入图片描述"></p><p>这是由北工大模式识别二组共同创作！！！<br>转载请注明出处，谢谢！！<br>下一章（续2）会简单理解一下我最近研究损失函数所遇到的问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;相比于之前的网络架构，Yolov3有两点提升：&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:48:46.164Z</published>
    <updated>2020-11-24T05:58:51.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型<br><img src="https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。<br> <a id="more"></a><br>物体检测的两个步骤可以概括为：<br>步骤一：检测目标位置（生成矩形框）<br>步骤二：对目标物体进行分类<br>物体检测主流的算法框架大致分为one-stage与two-stage。two-stage算法代表有R-CNN系列，one-stage算法代表有Yolo系列。可以说，two-stage算法将步骤一与步骤二分开执行，输入图像先经过候选框生成网络（例如faster rcnn中的RPN网络），再经过分类网络；one-stage算法将步骤一与步骤二同时执行，输入图像只经过一个网络，生成的结果中同时包含位置与类别信息。two-stage与one-stage相比，精度高，但是计算量更大，所以运算较慢。</p><p>我们这里介绍的两种深度学习算法，都是one-stage算法。<br>基于回归方法的深度学习目标检测算法，他们一步到位，其基本步骤是: 给定一张图像, 通过设定合理的输出向量，使用回归的方式输出这个目标的边框和类别，一步到位。这种算法的优点是速度快，但是对于密集的小样本来说检测比较困难。比如 YOLO、SSD 等。</p><p>2.3.1 YOLO</p><p>2.3.1.1YOLO介绍<br>YOLO系列论文提出了一个新的物体检测的方法：You Only Look Once（YOLO）</p><p>YOLO 的核心思想就是把目标检测转变成一个回归问题，利用整张图作为网络的输入，仅仅经过一个神经网络，得到bounding box（边界框） 的位置及其所属的类别。</p><p>2.3.1.2 YOLOv1<br>论文：<a href="https://arxiv.org/pdf/1506.02640.pdf">https://arxiv.org/pdf/1506.02640.pdf</a><br>YOLOv1是最早版本的YOLO，以下从概念上简单介绍v1的原理<br>1）网络结构<br><img src="https://img-blog.csdnimg.cn/20201124121158625.gif#pic_center" alt="在这里插入图片描述"></p><p>输入：448<em>448</em>3的彩色图片<br>中间层：若干卷积层和最大池化层<br>全连接层：2个全连接层，用来预测位置和类别概率值</p><p>2）实现细节<br>分类器的输出是一个one-hot vector，而检测器的输出是一个框(Bounding Box)。框，该怎么表示？<br><img src="https://img-blog.csdnimg.cn/20201124121259121.gif#pic_center" alt="在这里插入图片描述"></p><p>bounding box<br>总的来说，S×S 个网格，每个网格要预测 B个bounding box ，还要预测 C 个类。网络输出就是一个 S × S × (5×B+C) 的张量。<br><img src="https://img-blog.csdnimg.cn/20201124121342496.gif#pic_center" alt="在这里插入图片描述"></p><p>在实际过程中，YOLOv1把一张图片划分为了7×7个网格，并且每个网格预测2个Box（Box1和Box2），20个类别。所以实际上，S=7，B=2，C=20。那么网络输出的shape也就是：7×7×30。</p><p>3）损失函数和优化器<br>神经网络结构确定之后，训练效果好坏，由Loss函数和优化器决定。Yolo v1使用普通的梯度下降法作为优化器。这里重点解读一下Yolo v1使用的Loss函数：<br><img src="https://img-blog.csdnimg.cn/20201124121743750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>损失是三部分：坐标预测损失、置信度预测损失、类别预测损失的加和</p><p>思考：对于x和y用差平方，而对于宽和高为什么进行开根处理？<br>——假设宽和高使用与x，y相同处理方式（直接差平方），当预测值与真实值图像偏移相同大小时，我们依此法计算出的误差是固定的，然而这与实际不符。实际对于图像框尺度大小不同的区域，相同偏移量下，小尺度图像效果是很差的，而较大尺度图像则效果不错。因此，此损失函数的设计细节是作者为使实验结果更加准确而设计的。<br>置信度预测损失：是正负样本求平方加和<br>类别预测损失：预测值减去真实值求平方</p><p>4）优缺点</p><p>优点：更快更准迁移能力强<br>缺点：对相互靠近的物体，以及很小的群体检测效果不好；对不常见的角度的目标泛化性能偏弱</p><p>升级版 YOLOv2<br>YOLOv2论文：<a href="https://arxiv.org/abs/1612.08242">https://arxiv.org/abs/1612.08242</a></p><p>为提高物体定位精准性和召回率，YOLO作者提出了 “YOLO9000: Better, Faster, Stronger” (Joseph Redmon, Ali Farhadi, CVPR 2017, Best Paper Honorable Mention)，相比YOLOv1 提高了训练图像的分辨率；引入了faster rcnn中anchor box的思想，对网络结构的设计进行了改进，输出层使用卷积层替代YOLO的全连接层，联合使用coco物体检测标注数据和imagenet物体分类标注数据训练物体检测模型。相比YOLO，YOLO9000在识别种类、精度、速度、和定位准确性等方面都有大大提升。</p><p>2.3.2 SSD<br>YOlO和SSD算法作为“一步到位”算法的代表，他们的主要区别就是yolo只利用了末端特征图的信息，而SSD利用了最后几层特征图的信息，所以，从理论上说，SSD算法较yolo（起码是yolov1）来说，精确度必然更高。</p><p>卷积神经网络各层特征信息主要有如下区别：<br>1、低层卷积可以捕捉到更多的细节信息，高层卷积可以捕捉到更多的抽象信息。<br>2、低层特性更关心“在哪里”，但分类准确度不高，而高层特性更关心“是什么”，但丢失了物体的位置信息。<br>——《Visualizing and Understanding Convolutional Networks》.（可视化理解卷积神经网络）2014</p><p>SSD正是利用不同尺度检测图片中不同大小和类别的目标物体，获得了很好的效果。<br><img src="https://img-blog.csdnimg.cn/20201124123639607.gif#pic_center" alt="在这里插入图片描述"></p><p>VGG-16网络</p><p>对于每个特征图来说，SSD引入初始框的概念。对于不同的特征图，SSD总的尺度设计原则就是：随着网络层数加深（特征图的变小），初始框的尺度线性增加。最小的初始框尺度为0.2，最大的初始框尺度为0.9。</p><p><img src="https://img-blog.csdnimg.cn/20201124123710547.gif#pic_center" alt="在这里插入图片描述"></p><p>3.实例解析<br>3.1YOLO实例说明<br>以下对YOLOv3进行介绍，代码部分来自<br>tf2.0yolov3——malin9402,yunyang1994<br><a href="https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3">https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3</a></p><p>pytorch :<br><a href="https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch">https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch</a></p><p>3.1.1网络结构<br>随着CNN的发展和大量研究人员的努力，产生了数篇影响深远的论文，解决了在实际应用的诸多问题。yolov3借鉴了许多论文和思路，完善了yolo网络架构。<br>本节从原理和代码上介绍yolov3的网络架构，并深入探讨其网络架构上的进步和优点。</p><p>yolov3用darknet53作为基础网络架构</p><p><img src="https://img-blog.csdnimg.cn/20201124124149243.gif#pic_center" alt="Darknet53"></p><p>命名来源于它有53层卷积层=  2 + 1<em>2+1 +2</em>2+1 +8<em>2+1 +8</em>2+1 +4*2+1</p><p>未完待续——下一篇我会说一下YOLOV3相对于之前的网络架构的提升，相比之下，算力要求也会随之提升，所以我们需要借助滴滴云DAI平台来跑我们的代码项目<br><img src="https://img-blog.csdnimg.cn/20201124125105797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="输入我的AI大师码：8996，享受⑨折优惠，让自己的算法检测像扫码一样简单"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java Docker</title>
    <link href="http://example.com/2020/11/18/Java%20Docker/"/>
    <id>http://example.com/2020/11/18/Java%20Docker/</id>
    <published>2020-11-18T03:28:11.845Z</published>
    <updated>2020-11-18T03:28:11.845Z</updated>
    
    <content type="html"><![CDATA[<p>对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：</p><a id="more"></a><ul><li>如果未配置合适的JVM堆和元数据区，直接内存等参数；java有可能试图使用超过容器限制的内存，最终被容器OOM kill ，或者自身发生OOM</li><li>错误的判断了可获取的CPU资源。如：Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程</li></ul><p>与虚拟机及其相似，但是也有不同，并不是虚拟化技术，而是一种轻量级的隔离技术。轻量级的开销必然也就在成了许多微妙差异。<br><strong>这就是所谓的Ergonomics机制，例如</strong>：<br>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1/64；并将堆最大值，设置为系统内存的 1/4。<br>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。<br>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房间是给我住的。<br><img src="https://img-blog.csdnimg.cn/20201118112227927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>解决办法：升级到JDK8最新的更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发包中的队列比较</title>
    <link href="http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%E8%BE%83/</id>
    <published>2020-11-17T07:47:02.075Z</published>
    <updated>2020-11-17T07:47:02.075Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentLinkedQueue基于CAS的无锁技术，有着更大的吞吐量<br>而BlockingQueue是完全根据锁实现的。LinkedBlockingQueue不仅有着 notEmpty和notFull两种再入锁的条件变量，而且更加改进了锁操作的粒度，头尾操作用的不同的锁，比ArrayBlockingQueue吞吐量更大一点。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//好精美的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock held by take, poll,etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue for waiting takes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty =takeLock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock held by put offer,etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putlock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue for waiting puts</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull =putlock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与ArrayBlockingQueue中的实现有所不同，notEmpty、notFull都是同一个再入锁的条件变量，而LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     * 则改进了锁操作的粒度，头尾操作都使用不同的锁，所以其吞吐量会更好一些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span>  E x;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count =<span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock =<span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count.get()==<span class="number">0</span>)&#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span>(c&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c == capacity)</span><br><span class="line">            signalNotfull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotfull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者消费者（并发）利用ArrayBlockingQueue来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT_MSG =<span class="string">&quot;good bye&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用较小的队列，以更好地在输出中展现其影响，并发队列使用</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当初我的消费者,生产者是依托于 wait 与notify()&amp;notifyall(),这个队列更高级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);<span class="comment">//也算是一种继承类的语法</span></span><br><span class="line">        Producer producer =<span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer =<span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();<span class="comment">//将其包裹在线程中</span></span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.queue =q;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//20个线程并发生产，在值为3（实际为四）的队列里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span><br><span class="line">                    String msg =<span class="string">&quot;Message&quot;</span>+i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced new item&quot;</span>+msg);</span><br><span class="line">                    queue.put(msg);<span class="comment">//努力生产</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;time to say goodbye&quot;</span>);</span><br><span class="line">                queue.put(EXIT_MSG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue=q;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 String msg;</span><br><span class="line">                 <span class="keyword">while</span>(!EXIT_MSG.equalsIgnoreCase((msg=queue.take())))&#123;<span class="comment">//消费</span></span><br><span class="line">                     System.out.println(<span class="string">&quot;Consumed item&quot;</span> +msg);</span><br><span class="line">                     Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(<span class="string">&quot;Got exit message,bye!!!&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <strong>LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue</strong> 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p><ul><li>队列边界：ArrayBlockingQueue有明显限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定，而SynchronousQueue则压根没有缓存任何元素</li><li>空间利用：ArrayBlockingQueue比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段需要一段连续的空间，所以初始内存需求更大</li><li>吞吐量：LinkedBlockingQueue  &gt; ArrayBlockingQueue</li><li>稳定性：ArrayBlockingQueue</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ConcurrentLinkedQueue基于CAS的无锁技术，有着更大的吞吐量&lt;br&gt;而BlockingQueue是完全根据锁实现的。LinkedBlockingQueue不仅有着 notEmpty和notFull两种再入锁的条件变量，而且更加改进了锁操作的粒度，头尾操作用的不同的锁，比ArrayBlockingQueue吞吐量更大一点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发工具安全容器</title>
    <link href="http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%AD%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%AD%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-11-17T03:41:40.835Z</published>
    <updated>2020-11-17T03:41:40.836Z</updated>
    
    <content type="html"><![CDATA[<p> 上一章讲的是同步结构<br>  这一章讲容器<img src="https://img-blog.csdnimg.cn/20201117111546192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><ul><li><p>ConcurrentHashMap:无序，获取元素与map放入元素都很快，常数级别。 </p><ul><li><p>ConcurrentSkipListMap:有序,大量数据频繁修改，通过层次结构提高访问速度，空间复杂度为（O（nlogn））<br><img src="https://img-blog.csdnimg.cn/20201117111334916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>CopyOnWriteArrayList：动态数组。原理就是：add,set,remove,都会拷贝原数组，修改后替换原来的数组，通过这种模式，来实现线程安全</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaBottle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class CopyOnWrite &#123;</span></span><br><span class="line"><span class="comment">//    public boolean add(E e)&#123;</span></span><br><span class="line"><span class="comment">//        synchronized (lock)&#123;</span></span><br><span class="line"><span class="comment">//            Object[] elements =getArray();</span></span><br><span class="line"><span class="comment">//            int len =elements.length;</span></span><br><span class="line"><span class="comment">//            //拷贝</span></span><br><span class="line"><span class="comment">//            Object[] newElements = Arrays.copyOf(elements,len+1);</span></span><br><span class="line"><span class="comment">//            newElements[len]=e;</span></span><br><span class="line"><span class="comment">//            //替换</span></span><br><span class="line"><span class="comment">//            setArray(newElements);</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    final void setArray(Object[] a)&#123;</span></span><br><span class="line"><span class="comment">//        array= a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 上一章讲的是同步结构&lt;br&gt;  这一章讲容器&lt;img src=&quot;https://img-blog.csdnimg.cn/20201117111546192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发工具类</title>
    <link href="http://example.com/2020/11/16/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2020/11/16/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-16T13:58:53.374Z</published>
    <updated>2020-11-16T13:58:53.376Z</updated>
    
    <content type="html"><![CDATA[<p>带你走进并发的世界<br>回顾：我们在IO中讲的用线程池，只是相对于几百访问量的并发，那些只是我们练习时的Demo，<br>我们通常所说的并发包就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类：</p><a id="more"></a><ul><li>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以更加丰富的多线程操作。</li></ul><ul><li>线程安全的容器 ConcurrentHashMap,无序，且MAP放入或者获取的速度更快；有序的ConcurrentSkipListMap,获取并不快，但是有助于增删查改；快照机制，动态数组CopyOnWriteArrayList</li><li>并发队列结构：BlockingQueue实现，如：ArrayBlockingQueue、SynchronousQueue或者针对场景的PriorityBlockingQueue</li><li>强大的Executor框架，可以创建不同类型的线程池，调度任务运行。不需要自己从头实现线程池和任务调度器</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优秀的同步结构 CountDownLatch、CyclicBarrier、Semaphore</span></span><br><span class="line"><span class="comment"> * 线程安全的容器 ConcurrentHashMap,无序，且MAP放入或者获取的速度更快；有序的ConcurrentSkipListMap,获取并不快，但是有助于增删查改；快照机制，动态数组CopyOnWriteArrayList</span></span><br><span class="line"><span class="comment"> * 并发队列结构：BlockingQueue实现，如：ArrayBlockingQueue、SynchronousQueue或者针对场景的PriorityBlockingQueue</span></span><br><span class="line"><span class="comment"> * 强大的Executor框架，可以创建不同类型的线程池，调度任务运行。不需要自己从头实现线程池和任务调度器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsualSemaphoreSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Semaphore是经典信号量，它通过一定数量的允许（permit）的方式，达到限制通用资源访问的目的，有出租车空闲，防止</span></span><br><span class="line"><span class="comment">     * 拥挤，调度员允许一次只有五个访问，这个坐满下次访问再来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Action..GO!&quot;</span>);</span><br><span class="line">        Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> SemaphoreWorker(semaphore));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreWorker</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *不能放入同一类里，这个就像调度员的角色</span></span><br><span class="line"><span class="comment">       * acquire的意思：可以将acquire操作视为是消费一个许可，而release操作是创建一个许可</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreWorker</span><span class="params">(Semaphore semaphore)</span></span>&#123;<span class="comment">//构造方法设定</span></span><br><span class="line">        <span class="keyword">this</span>.semaphore =semaphore;<span class="comment">//this自引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;is waiting for a permit!&quot;</span>);</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            log(<span class="string">&quot;acquired a permit&quot;</span>);</span><br><span class="line">            log(<span class="string">&quot;executed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;released a permit&quot;</span>);</span><br><span class="line">            semaphore.release();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="comment">//只是调用了两个方法，这就是利用semaphore,里面原理依旧是黑匣子</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;</span><br><span class="line">            name=Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(name+<span class="string">&quot; &quot;</span>+msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * countDown/await控制，调用await的线程阻塞等待countDown足够的次数，不管是一个或多个线程中，只要次数足够即可</span></span><br><span class="line"><span class="comment">     * 相对于semaphore, countDown不能重用,如果要支持更多人排队，就不能依赖一个countDownLatch</span></span><br><span class="line"><span class="comment">     * 就相当于我有限量的出租车，而你有无限量的人，等我拉完一趟你们的去另个地点再坐</span></span><br><span class="line"><span class="comment">     * 而semaphore相当于我有限量的指令，你们用完一个给我放一个，应该也不会超出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch =<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//将线程创建在同步器之中</span></span><br><span class="line">            Thread t =<span class="keyword">new</span> Thread(<span class="keyword">new</span> FirstBatchWorker(latch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread t =<span class="keyword">new</span> Thread(<span class="keyword">new</span> SecondBatchWorker(latch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里只是出于演示目的</span></span><br><span class="line">        <span class="keyword">while</span>(latch.getCount()!=<span class="number">1</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait for first batch finish&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstBatchWorker</span><span class="params">(CountDownLatch latch)</span></span>&#123;<span class="comment">//每次都有一个构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.latch =latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First batch executed&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondBatchWorker</span><span class="params">(CountDownLatch latch)</span> </span>&#123;<span class="comment">//每次都有一个构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//其实就相当于数着await次数一样，满足countDown足够的次数，然后second才能运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;Second batch executed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 线程并行时候的协调，从逻辑上讲，五个工作线程就像代表了五个可以就绪的空车</span></span><br><span class="line"><span class="comment">     * 而不是五个待坐的乘客</span></span><br><span class="line"><span class="comment">     * 一种辅助性的同步结构，允许多个线程等待到达某个屏障，支持更多排队人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//到达5就是到达一个屏障</span></span><br><span class="line">        CyclicBarrier barrier =<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//创建五个线程</span></span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicWorker(barrier));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CyclicWorker</span><span class="params">(CyclicBarrier barrier)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.barrier =barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Executed&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理解！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;带你走进并发的世界&lt;br&gt;回顾：我们在IO中讲的用线程池，只是相对于几百访问量的并发，那些只是我们练习时的Demo，&lt;br&gt;我们通常所说的并发包就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之死锁定位，修复，预防</title>
    <link href="http://example.com/2020/11/16/%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F%E5%8F%8A%E5%85%B6%E9%A2%84%E9%98%B2%EF%BC%9F/"/>
    <id>http://example.com/2020/11/16/%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F%E5%8F%8A%E5%85%B6%E9%A2%84%E9%98%B2%EF%BC%9F/</id>
    <published>2020-11-16T06:07:05.547Z</published>
    <updated>2020-11-16T06:07:05.547Z</updated>
    
    <content type="html"><![CDATA[<p>模拟定位问题，就选取常见的jstack,可以使用jps或者系统的ps命令、任务管理器等工具，确定进程ID<br>其次，调用jstack获取线程栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;\bin\jstack your_pid</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201116105056333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>仔细看，有一个线程掌握的一个锁恰好是下一个线程需要的锁</p><p>具体步骤是：<br>区分线程状态—&gt;查看等待目标—&gt;对比monitor等持有状态<br>所以,<strong>理解线程基本状态和并发相关元素</strong>是定位问题的关键，然后调用栈结构，可以找到问题</p><p><strong>如果我们开发自己的管理工具，遇到死锁，可以用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用javaAPI：ThreadMXBean</strong>,直接提供了findDeadlockedThreads()方法用于定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDeadLocked</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();<span class="comment">//容器</span></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;<span class="comment">//检查所有线程</span></span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Detected deadlock threads&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span>(ThreadInfo threadInfo:threadInfos)&#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//并发包中的方法</span></span><br><span class="line">        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//稍等5秒，然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck,<span class="number">5L</span>,<span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>预防死锁<br>发生死锁的原因主要有三点：<br>1.互斥条件，类似于java中的Monitor都是独占的，要不是我用，要不是你用<br>2.互斥条件长期持有，在使用结束之前，自己不会释放，也不能被其他线程抢占<br>3.循环依赖关系，两个或者多个个体之间出现了锁的链条环                                                                                                                                                                          第一种方法：尽量避免使用多个锁，嵌套的synchronized或者lock非常容易出问题<br>设计时，既要支持阻塞模式，又要支持非阻塞模式就很容易出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread HttpClient-6-SelectorManager</span></span><br><span class="line">readlock.lock();</span><br><span class="line">writelock.lock();</span><br><span class="line"><span class="comment">//持有readlock/writelock，调用close()需要获得closelock</span></span><br><span class="line">close();</span><br><span class="line"><span class="comment">//Thread HttpClient-6-Worker-2持有closelock</span></span><br><span class="line">implCloseSelectableChannel();<span class="comment">//向获得readlock</span></span><br></pre></td></tr></table></figure><p>进入死锁！！<br>所以不能赋予代码太多的职责</p><p>第二种方法：<br>尽量设计好锁的顺序<br>反例：<br><img src="https://img-blog.csdnimg.cn/20201116135730648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201116135740146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>时序问题下，可能造成死锁</p><p>第三个方法：<br>使用带超时的方法，为程序带来更多可控性<br>Object.wait(…)<br>第四个方法：<br>FindBugs来尝试使用固定的模式寻找死锁定位，但是现在仍有多欠缺。所以Java官方文档提供了相应JVM参数和基本原则。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟定位问题，就选取常见的jstack,可以使用jps或者系统的ps命令、任务管理器等工具，确定进程ID&lt;br&gt;其次，调用jstack获取线程栈：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;#123;JAVA_HOME&amp;#125;\bin\jstack your_pid&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之ReentrantLock锁的用法，特性，注意事项</title>
    <link href="http://example.com/2020/11/16/ReentrantLock%E9%94%81%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2020/11/16/ReentrantLock%E9%94%81%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-11-16T04:29:20.119Z</published>
    <updated>2020-11-16T04:29:20.119Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。</p><p>1 用法比较<br>Lock使用起来比较灵活，但是必须有释放锁的配合动作<br>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁<br>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</p><a id="more"></a><p>2 特性比较<br>ReentrantLock的优势体现在：<br>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁<br>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放<br>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</p><p>3 注意事项<br>在使用ReentrantLock类的时，一定要注意三点：<br>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放<br>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。<br>ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。&lt;/p&gt;
&lt;p&gt;1 用法比较&lt;br&gt;Lock使用起来比较灵活，但是必须有释放锁的配合动作&lt;br&gt;Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁&lt;br&gt;Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之死锁</title>
    <link href="http://example.com/2020/11/15/%E6%AD%BB%E9%94%81%EF%BC%9F/"/>
    <id>http://example.com/2020/11/15/%E6%AD%BB%E9%94%81%EF%BC%9F/</id>
    <published>2020-11-15T09:24:14.627Z</published>
    <updated>2020-11-15T09:24:14.627Z</updated>
    
    <content type="html"><![CDATA[<p><strong>死锁？</strong></p><p>死锁是一种特定的程序状态，由于循环依赖导致彼此一直处在等待之中，没有任何个体可以继续前进。死锁不仅仅发生在线程之间，存在资源独占的进程之间同样也可能发生死锁。通常来说，两个或者多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞的状态</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201115165637396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。<br>如果发生了死锁，绝大多数情况是无法在线解决的，只能重启、修正程序本身问题。</p><p>第一、写一个死锁的程序，基础的线程编程一遍考察</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockSample</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个就是实例化的线程子类，定义了run()方法</span></span><br><span class="line"><span class="comment">     * 接下来我们的操作就是在mian方法中创建两个线程来实现争夺两个资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockSample</span><span class="params">(String name,String first,String second)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.first=first;</span><br><span class="line">        <span class="keyword">this</span>.second=second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (first)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;obtained:&quot;</span>+first);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (second)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;obtained:&quot;</span>+second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String lockA =<span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB =<span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        DeadLockSample  t1 =<span class="keyword">new</span> DeadLockSample(<span class="string">&quot;Thread1&quot;</span>,lockA,lockB);<span class="comment">//传参，实参</span></span><br><span class="line">        DeadLockSample  t2 =<span class="keyword">new</span> DeadLockSample(<span class="string">&quot;Thread2&quot;</span>,lockB,lockA);<span class="comment">//传参，实参</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//记得添加异常处理</span></span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20201115172247897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>执行并不能结束！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;死锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;死锁是一种特定的程序状态，由于循环依赖导致彼此一直处在等待之中，没有任何个体可以继续前进。死锁不仅仅发生在线程之间，存在资源独占的进程之间同样也可能发生死锁。通常来说，两个或者多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞的状态&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java线程两次调用start()会出现什么？？</title>
    <link href="http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/"/>
    <id>http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/</id>
    <published>2020-11-15T07:53:24.676Z</published>
    <updated>2020-11-15T07:53:24.676Z</updated>
    
    <content type="html"><![CDATA[<p>Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException<br>这是一种运行时异常，多次调用start被认为是编程错误</p><a id="more"></a><p>在线程生命周期的不同状态，已被明确定义在公布内部类型java.lang.Thread.State,分别是：<br>1.新建（new），表示被创建出来还没真正启动的状态，java内部状态<br>2.就绪、（RUNNABLE）表示该线程已经在JVM中执行，可能正在运行，等待系统CPU给其片段，在就绪队列里面排队<br>3.阻塞（Blocked），与前面的同步非常相关，阻塞表示线程在等待Monitor lock.线程视图通过synchronized去获取某个锁，却发现其他线程已经独占了，那么当前线程就会处于阻塞状态<br>4.等待（waiting）表示等待其他线程采取某些操作。类似于以前打过代码的生产者消费者模式，发现生产者线程还没被生产出来，消费者就会等待，生产者线程准备任务数据，通过类似notify等动作，通知消费线程可以继续工作。<br>Thread.join（）也会令线程进入等待状态<br>5.计时等待（TIMED_WAIT）与等待状态类似，但调用的是存在超时条件的方法，比如wait或者join等方法的指定超时版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>6.终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行。</p><p><strong>线程是什么？</strong><br>一个进程可以分为多个线程，作为任务的真正运作着，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）,但是会和其他线程共享文件描述符，虚拟地址空间</p><p>在具体实现中，线程还分为内核线程，用户线程，java线程实现其实与虚拟机相关，现在的模型是一对一映射到操作系统内核线程。<br>源码中，基本操作逻辑是以JNI形式调用的本地代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setPriority0</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable task =()-&gt;&#123;System.out.ptintln(<span class="string">&quot;Hello world&quot;</span>);&#125;;</span><br><span class="line">Thread myThread =<span class="keyword">new</span> Thread(task);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread.join();<span class="comment">//等待结束</span></span><br></pre></td></tr></table></figure><p>实现一个Runnable,将代码逻辑放入Runnable中，然后构建Thread并启动（start）</p><p>Runnable的好处就是，不会受“java不能多继承”的限制，重用代码实现，需要重复执行相应逻辑时效率明显</p><p>另外还能更好地与并发库中的Executor之类框架结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future future =Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">.submit(task)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure><p>守护线程（Daemon Thread）：应用需要一个长期驻留的服务程序，但不希望影响应用退出，如果jvm发现只有守护线程存在时，将结束进程。注：必须在线程启动之前设置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread =<span class="keyword">new</span> Thread();</span><br><span class="line">deamonThread.setDeamon(<span class="keyword">true</span>);</span><br><span class="line">deamonThread.start();</span><br></pre></td></tr></table></figure><p>在多核CPU的系统中，线程等待存在一种可能，就是没有任何线程广播或者信号，线程就会被唤醒，处理不当就会产生并发问题<br>//推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isCondition())&#123;</span><br><span class="line">waitForAConfition(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慎用ThreadLocal,保存线程私有信息的机制，可以方便的在一个线程关联的不同业务之间传递信息，比如事务ID，Cookie等上下文信息，数据存储于ThreadLocalMap，其内部条目是弱引用<br>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt;</span>&#123;</span><br><span class="line">   Object value;</span><br><span class="line">   Entry(ThreadLocal&lt;?&gt; k,Object v)&#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value =v;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key为null时，该条目变为了废弃条目，value回收需要<br>“set 、remove、rehash”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i];; …) &#123;</span><br><span class="line">      <span class="comment">//…</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 替换废弃条目</span></span><br><span class="line">          replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">//  扫描并清理发现的废弃条目，并检查容量是否超限</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">      rehash();<span class="comment">// 清理废弃条目，如果仍然超限，则扩容（加倍）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal虽然是弱引用，但是垃圾处理机制对其例外，所以其回收应该依赖于显式的触发，否则就要等待线程结束，所以一定要提防OOM，<strong>自己创建的应用自己负责remove</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException&lt;br&gt;这是一种运行时异常，多次调用start被认为是编程错误&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之IO方式，及NIO简介</title>
    <link href="http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-14T14:01:15.445Z</published>
    <updated>2020-11-14T14:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<p>可以构建高扩展性应用的能力<br>JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式<br>可以进行简单区分<br>1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等<br>交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序<br>java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。<br>java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。<br>2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式<br>3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作</p><a id="more"></a><p>在面试中，考察的点涉及方方面面</p><ul><li>基础API功能和设计，InputStream/OutputStream和Reader/writer的关系和区别（BIO）</li><li>NIO AIO的基本组成</li><li>给定场景，分别用不同模型实现，分析BIO、NIO等模式的设计和实现原理</li><li>NIO提供的高性能数据操作方式是基于什么原理，如何使用？</li><li>或者，从开发者的角度来看，你觉得NIO自身实现存在哪些问题？有什么改进的想法吗？</li></ul><p>区分同步和异步？<br>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步，而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</p><p>区分阻塞和非阻塞？<br>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当前条件就绪才能继续。比如：ServerSocket新连接建立完毕，或数据读取，写入操作完成，而 非阻塞 则是不管IO操作是否结束，直接返回，相应操作则在后台处理。</p><p>我们不能说同步和阻塞就是低效，分情况而定。</p><p>对于java.io的总结：</p><ul><li>IO不仅仅是对文件的操作，网络编程中，比如Socket通信，都是典型的IO 操作目标</li><li>输入流，输出流是用于读取或写入字节的，操作图片文件</li><li>Reader/Writer则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，相当于构建了应用逻辑和原始数据之间的桥梁</li><li>BufferdOutputStream等缓冲区的实现，可以避免频繁的磁盘读写，进而提高IO处理效率，这种设计利用了缓冲区，将批量数据进行一次操作，使用中不能忘了flush</li><li>很多IO工具类都实现了Closeable接口，因为需要进行资源的释放。比如：打开FilelnputStream，它就会获取相应的文件描述符（FileDescriptor）,需要try-with-resources、try-finally等机制保证FilelnputStream被明确关闭，进而相应文件描述也会失效，否则将导致资源无法被释放</li></ul><p>JAVA NIO</p><p>NIO的组成部分：<br>1.Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现<br>2.Channel,文件描述符，是NIO中被用来支持批量式IO操作的一种抽象。file 、Socket ，被认为是比较高层次的抽象，而 channel则是更加操作系统底层的一种抽象。我们可以通过Socket获取Channel。<br>4.Selector,是NIO实现多复用的基础，他提供了一种高效的机制，可以检测到注册在Selector的多个Channel中，是否有Channel处于就绪状态，进而实现单线程对多CHANNNEL的高效管理</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以构建高扩展性应用的能力&lt;br&gt;JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式&lt;br&gt;可以进行简单区分&lt;br&gt;1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等&lt;br&gt;交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序&lt;br&gt;java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。&lt;br&gt;java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。&lt;br&gt;2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式&lt;br&gt;3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之NIO要解决的问题</title>
    <link href="http://example.com/2020/11/14/NIO%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/14/NIO%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-14T13:57:28.665Z</published>
    <updated>2020-11-14T13:57:28.665Z</updated>
    
    <content type="html"><![CDATA[<p>NIO解决的问题<br>为什么需要NIO，为什么需要多路复用？<br>场景：我们需要实现一个服务器应用，简单要求能够同时服务多个客户端请求</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverSocket.getLocalPort();<span class="comment">//相当于一个平常的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            serverSocket =<span class="keyword">new</span> ServerSocket(<span class="number">0</span>);<span class="comment">//服务器端启动ServerSocket,端口0表示自动绑定一个空闲端口</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket =serverSocket.accept();<span class="comment">//客户端的请求，阻塞等待客户端连接</span></span><br><span class="line">                RequestHandler requestHandler =<span class="keyword">new</span>  RequestHandler(socket) ;</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        DemoServer server =<span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();<span class="comment">//服务器开启</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用Scoket模拟一个简单的客户端，只进行连接、读取、打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span>(Socket client =<span class="keyword">new</span> Socket(InetAddress.getLocalHost(),server.getPort()))&#123;</span><br><span class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        RequestHandler(Socket socket) &#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//重载</span></span><br><span class="line">            <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">                out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程实现比较重量级，启动和销毁一个线程有明显开销，每个线程都有单独的线程栈结构 ，占用非常明显的内存，所以，每一个Client启动一个线程都有点浪费</p><p>所以，我们可以修正问题，引入线程池机制来避免浪费</p><p>通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是构建并发服务的典型方式</p><p><img src="https://img-blog.csdnimg.cn/20201113142701987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果只有几百个连接的普通应用，这种模式往往可以工作很好。但是如果数量急剧上升，这种实现方式就无法很好工作，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势</p><p>NIO引用的多路复用机制，提供了另外一种思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoServerClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/**NIO的组成1.Buffer   2.channel 多线程并发抽象概念  3.Selector筛选器</span></span><br><span class="line"><span class="comment">     * 同步非阻塞IO框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Selector selector =Selector.open();<span class="comment">//通过Selector.open()创建一个Selector,作为一个类似调度员的角色</span></span><br><span class="line">            <span class="comment">/**通过创建一个ServerSocketChannnel,并且向Selector注册，通过指定SelectionKey.OP_ACCEPT，</span></span><br><span class="line"><span class="comment">             * 告诉调度员，它关注的是新的连接请求</span></span><br><span class="line"><span class="comment">             * 为什么我们要明确配置非阻塞模式呢？因为在阻塞模式下，注册操作是不允许的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ServerSocketChannel serverSocket =ServerSocketChannel.open();)&#123;<span class="comment">//创建channel selector</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class="number">8888</span>));<span class="comment">//创建连接端口,监听</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册到Selector,并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">/**Selector阻塞在select操作，当有Channel发生接入请求后，就会被唤醒</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                selector.select();<span class="comment">//阻塞等待就绪的Channel，这是关键点之一</span></span><br><span class="line">                Set &lt;SelectionKey&gt; selectionKeys =selector.selectedKeys();<span class="comment">//建一个selector的HashSet</span></span><br><span class="line">                Iterator &lt;SelectionKey&gt; iter =selectionKeys.iterator();<span class="comment">//迭代器迭代 selectionKey的Set</span></span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key =iter.next();</span><br><span class="line">                    <span class="comment">//生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel)key.channel());<span class="comment">//强制类型转换，找出那个channel</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在此方法中，通过ScoketChannel和Buffer进行数据操作，发送一段字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SocketChannel client =server.accept();)&#123;<span class="comment">//客户端只管发送请求就ok</span></span><br><span class="line">            client.write(Charset.defaultCharset().encode(<span class="string">&quot;helloworld!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IO是同步阻塞模式，需要多线程实现多任务处理<br>NIO利用单线程轮询时间的机制，高效定位就绪的Channel,来决定做什么，仅仅select阶段是阻塞的，可以避免大量客户连接时，频繁切换线程带来的问题</p><p><img src="https://img-blog.csdnimg.cn/20201113152911340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>异步非阻塞AIO</strong><br>java7引入NIO2(AIO)时，又增添了一种额外的异步IO模式，利用事件和回调，处理Accept,Read等操作<br>AsychronousServerSocketChannel对应于上面例子的SeverSocketChannel;<br>AsychronousSocketChannel对应于SocketChannel<br>业务逻辑的关键点在于，通过指定的CompletionHandler回调接口，在accept/read/write等关键节点，通过事件机制调用，实现异步</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NIO解决的问题&lt;br&gt;为什么需要NIO，为什么需要多路复用？&lt;br&gt;场景：我们需要实现一个服务器应用，简单要求能够同时服务多个客户端请求&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java设计模式</title>
    <link href="http://example.com/2020/11/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/11/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-14T13:38:30.186Z</published>
    <updated>2020-11-14T13:38:30.186Z</updated>
    
    <content type="html"><![CDATA[<p>java设计模式、</p><p>创建型设计模式：工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）</p><p>结构型模式：是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等</p><p>行为型模式：是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）</p><a id="more"></a><p><strong>谈谈你知道的设计模式？<br>手动实现单例模式<br>spring等框架使用哪些模式？</strong><br>刚刚学过io框架，我们知道了还有InputStream的抽象类<br>标准类库中提供了FileputStream、ByteArrayInputStream等各种不同的子类，这就是装饰器模式</p><p>装饰器模式：包装同类型实例，对目标对象的调用，往往会通过包装类覆盖过的方法，迂回调用被包装的实例。<br>例子：<br>BufferedInputStream经过包装，为输入流过程增加缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure><p>单例模式（创建型模式）<br>给别人提供一个别人没有的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式<br>造商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//产品类实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;产品&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        IFactory factory = <span class="keyword">new</span> Factory();  </span><br><span class="line">        IProduct prodect = factory.createProduct();  </span><br><span class="line">        prodect.productMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>代理模式<br>代理模式就是在一个我们已知的方法in use时，我们可以采用代理模式实现方法的扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源对象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源对象实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;the original method!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Source source;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>)&#123;</span><br><span class="line">            source = <span class="keyword">new</span> Source ();</span><br><span class="line">        &#125; </span><br><span class="line">        source.method();  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>装饰器模式（结构性模式）<br>通过一个更加灵活的方式动态的为某一个对象添加一些额外的职责</p><p>被扩展的类接口–&gt;实现被扩展的类<br>|<br>创建实现了Shape接口的抽象装饰类<br>|<br>继承抽象接口进一步扩展该性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需被拓展的类的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需被拓展的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Rectangle&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实现了 Shape 接口的抽象装饰类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展了 ShapeDecorator 类的实体装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(decoratedShape);        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      decoratedShape.draw();           </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者模式：（行为型模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </span><br><span class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建观察者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者实现类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者实现类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println( <span class="string">&quot;Octal String: &quot;</span> </span><br><span class="line">     + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变被观察者状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;First state change: 15&quot;</span>); </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;java设计模式、&lt;/p&gt;
&lt;p&gt;创建型设计模式：工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）&lt;/p&gt;
&lt;p&gt;结构型模式：是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等&lt;/p&gt;
&lt;p&gt;行为型模式：是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之接口和抽象类有什么不同？</title>
    <link href="http://example.com/2020/11/14/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/11/14/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-11-14T05:35:56.329Z</published>
    <updated>2020-11-14T05:35:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>接口和抽象类有什么不同?</strong><br>接口是对行为的抽象，里面1.静态方法2.抽象方法，达到成为API的目的。接口，不能实例化。不能含有任何非常量成员，任何filed都隐藏着public  static final.java标准类库里，有着很多定义的接口：java.util.List</p><p>抽象类是不能实例化的类，用abstract修饰，主要目的在于代码重用，没有太多意义上的<strong>行为严格规范</strong>，除了不能实例化外，与其他java类没有任何差别，可以有多个抽象方法，只是代码共同方法的抽象集合堆砌而已。<br>比如：collection框架中，很多通用部分被抽取为抽象类，java.util.AbstractList</p><p>实现用interface ，继承抽象接口（extends）</p><a id="more"></a><p>java可以实现多个接口<br>某些场景下，我们需要抽象出某些与具体实现，实例化无关的通用逻辑，但是形成抽象方法会陷入单继承的窘境。所以我们这时可以变通一下，形成工具接口类，实现它。java.utuil.collections就是这样</p><p>对于抽象类，我们可以在其中展现非抽象方法，其子类不会报错，只会扩展性能</p><p>有一类没有任何方法的接口，叫做Marker interface,为了声明某些东西，比如我们熟知的 Cloneable、Serializable</p><p>java8又增加了一类接口，那便是functional interface<br><a href="https://www.oreilly.com/content/java-8-functional-interfaces/">https://www.oreilly.com/content/java-8-functional-interfaces/</a></p><p>java8以后我们给接口添加一系列的default method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> <span class="keyword">extends</span> <span class="title">Iterable</span> </span>&#123; <span class="comment">/** * Returns a sequential Stream with this collection as its source * ... **/</span> <span class="function"><span class="keyword">default</span> Stream <span class="title">stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><p>封装：<br>我们将一些内部逻辑封装起来，为了安全性和易用性，只释放接口出来，避免外部调用者接触到内部的细节<br>继承:<br>子类父类的关系，一种深耦合<br>多态：<br>重写和重载<br>重写是父子之间，方法名参数一致<br>实现方法不同<br>重载是方法名一致，参数和返回值类型不一致<br><strong>遵循原则</strong><br>S.O.L.I.D<br>single：某个类只能承担一种业务<br>开关原则（Open-Close, Open for extension, close for modification）：对扩展开放，对修改关闭<br>里式替换（Liskov Substitution）：继承关系抽象时，凡是能用父类和基类，都可以用其子类去替换<br>接口分离：进行类和接口设计时，对其实现类造成了两难，只有部分方法对其有意义，可以拆分成功能单一的多个接口，在未来修改接口时，不会对其他不相干的子类造成影响<br>依赖反转：<br>实体应该依赖于<strong>抽象</strong>而不是实现。也就是说高层次模块，不应该依赖于低层次模块，<strong>而是应该基于抽象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;User.TYPE, ServiceProvider&gt; providers;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(T extend User user） &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      providers.get(user.getType()</span>).<span class="title">service</span><span class="params">(user)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span></span>&#123;</span><br><span class="line">     <span class="comment">// do somthing</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">RealVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;接口和抽象类有什么不同?&lt;/strong&gt;&lt;br&gt;接口是对行为的抽象，里面1.静态方法2.抽象方法，达到成为API的目的。接口，不能实例化。不能含有任何非常量成员，任何filed都隐藏着public  static final.java标准类库里，有着很多定义的接口：java.util.List&lt;/p&gt;
&lt;p&gt;抽象类是不能实例化的类，用abstract修饰，主要目的在于代码重用，没有太多意义上的&lt;strong&gt;行为严格规范&lt;/strong&gt;，除了不能实例化外，与其他java类没有任何差别，可以有多个抽象方法，只是代码共同方法的抽象集合堆砌而已。&lt;br&gt;比如：collection框架中，很多通用部分被抽取为抽象类，java.util.AbstractList&lt;/p&gt;
&lt;p&gt;实现用interface ，继承抽象接口（extends）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java拷贝文件(copy)及buffer的基础使用</title>
    <link href="http://example.com/2020/11/13/java%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/11/13/java%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</id>
    <published>2020-11-13T12:54:03.505Z</published>
    <updated>2020-11-13T12:54:03.506Z</updated>
    
    <content type="html"><![CDATA[<p>拷贝实现方式：<br>1.java.io类库，为源文件构建一个FileputStream读取，为目标文件构建FileOutputStream，完成写入工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copyFileByStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span><span class="params">(File source,File dest)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is  = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">            OutputStream os = <span class="keyword">new</span>  FileOutputStream(dest);)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span>((length =is.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用NIO实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.java.nio类库提供的transferTo或者transferFrom方法实现</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用NIO实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source,File dest)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileChannel sourceChannel=<span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">            FileChannel targetChannel =<span class="keyword">new</span> FileOutputStream(dest).getChannel();</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> count =sourceChannel.size();count&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                <span class="keyword">long</span> transferred =sourceChannel.transferTo(sourceChannel.position(),count,targetChannel);</span><br><span class="line">                sourceChannel.position(sourceChannel.position()+transferred);</span><br><span class="line">                count-=transferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>主要还是为了让你加深对java类库设计和实现的了解<br><strong>零copy</strong><br>值得注意的点：<br>1.不同的copy方式，底层机制有什么区别？<br>2.为什么零拷贝（zero-copy）可能有性能优势？<br>3.Buffer分类和使用<br>4.Direct Buffer对垃圾收集等方面的影响与实践选择</p><p>拷贝实现机制<br>当我们使用输入输出流的时候，实际上进行了多次上下文切换。<br>比如<strong>应用读取数据</strong>时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。<br><strong>写入数据时</strong>步骤相反</p><p><img src="https://img-blog.csdnimg.cn/20201113172155296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>transfer To的传输过程<br><img src="https://img-blog.csdnimg.cn/20201113172410498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>基于NIO transferTo的实现方式，在Linux和UNIX上，则会使用到零拷贝技术<br>数据传输并不需要用户态参与，省去了上下文切换和不必要的内拷过程<br>读取磁盘文件：进行Socket发送，享受这种机制带来的性能和扩展性提高</p><p>JAVA IO/NIO源码结构<br>第三种方式：java标准库提供了文件拷贝方法（java.nio.file.copy）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(Path source, OutputStream out)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>这个常见的copy并不是利用transferTo,而是本地技术实现的用户态拷贝（只是简单地用户态空间拷贝）</p><p>提高类似拷贝等IO操作的性能：</p><ul><li>使用缓存等机制，合理减少IO次数（tcp传输）</li><li>使用Transfer To机制，减少上下文切换和额外IO操作</li><li>尽量减少不必要的转换过程，比如编解码，对象序列化和发序列化。如：操作文本文件或者网络通信，如果过程不是需要文本信息，可以考虑不要将二进制信息转换成字符串，直接二进制传输</li></ul><p> <strong>掌握NIO Buffer</strong><br> Buffer 是NIO操作数据的基本工具，Java为每种原始数据类型提供相应的Buffer实现（布尔除外）<br> <img src="https://img-blog.csdnimg.cn/20201113174956887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>capacity,它反映了Buffer到底有多大，数组的长度<br>position,要操作的数据起始位置<br>limit,相当于操作的限额。<br>读取操作时，limit设置为所容纳数据的上限<br>写入时，则会设置容量或者容量以下的可写限度。<br>Mark，记录上一次position的位置，默认是0，算是便利性考虑<br>io操作是一个闭环<br>实例：<br>1.我们创建一个ByteBuffer,准备写入数据<br>capacity当然就是缓冲区大小，而position是0<br>limit默认就是capacity的大小<br>2.当我们写入几个字节的数据时，position就会跟着动，但是不会超过limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead =inChannel.read(buf);<span class="comment">//read into buffer</span></span><br><span class="line">buf.put(<span class="number">127</span>)</span><br></pre></td></tr></table></figure><p>3.我们现在想把写入的数据读出来，需要调用flip方法,将position设置为0，limit一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get(); </span><br></pre></td></tr></table></figure><p>4.如果还想从头再读一遍，将position置为0</p><ul><li><p>Direct Buffer<br>定义了一个isDirect()方法，返回当前Buffer是否是Direct类型<br>这是因为提供了堆内和堆外两种Buffer，我们以它的allocate或者allocateDirect方法直接创建</p></li><li><p>MappedByteBuffer:将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去内核空间向用户空间传输的损耗。我们可以用FileChannel.map创建MappedByteBuffer</p><p>在实际使用中，java会尽量对Direct Buffer仅做本地IO操作，对于很多大数据量的IO密集型操作，会到来很大的性能优势：</p></li><li><p>Direct Buffer生命周期内内存地址不会再发生改变，进而内核可以安全的对其进行访问，很多IO操作会很高效</p></li><li><p>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高</p><p>Direct Buffer 我们需要清楚它对内存和JVM参数的影响。<br>大多数GC中，都不会主动收集，就是基于幻象引用机制，本身并不是public类型，内部实现了一个Deallocator负责销毁的逻辑。对它的销毁往往要拖到full GC的时候，所以一定要小心OOM</p></li></ul><p>对于Direct Buffer的回收：</p><ul><li>显式的调用System.gc()来强制触发</li><li>重复使用Direct Buffer</li></ul><p>跟踪和诊断Direct Buffer内存占用</p><ul><li>jdk8以后我们可以用 Native Memory Tracking(NMT)特性来进行诊断，你可以在程序启东市加下列参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:NativeMemoryTracking=&#123;summary|ddetail&#125;</span><br></pre></td></tr></table></figure><p>注：激活NMT通常会导致JVM出现性能下降5%-10%</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;拷贝实现方式：&lt;br&gt;1.java.io类库，为源文件构建一个FileputStream读取，为目标文件构建FileOutputStream，完成写入工作&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.io.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copyFileByStream&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copyFileByStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File source,File dest)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;(InputStream is  = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileInputStream(source);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            OutputStream os = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;  FileOutputStream(dest);)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] buffer =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((length =is.read(buffer))&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                os.write(buffer,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 利用NIO实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2.java.nio类库提供的transferTo或者transferFrom方法实现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之项目比较大时，使用python ORM框架来操作MYSQL</title>
    <link href="http://example.com/2020/11/10/%E9%A1%B9%E7%9B%AE%E6%AF%94%E8%BE%83%E5%A4%A7%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMYSQL/"/>
    <id>http://example.com/2020/11/10/%E9%A1%B9%E7%9B%AE%E6%AF%94%E8%BE%83%E5%A4%A7%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMYSQL/</id>
    <published>2020-11-10T11:37:22.725Z</published>
    <updated>2020-11-10T11:57:51.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201110155109230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>相当于持久化层<br>从数据库的涉及层面转化为面向对象的处理方式<br>三个ORM主流框架</p><a id="more"></a><p>1.Django<br>MTV框架模式<br><img src="https://img-blog.csdnimg.cn/2020111016031036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2.SQLALchemy 提供了SQL工具包和ORM工具<br>同时支持ORM和原生SQL两种方式</p><p>3.peewee,轻量级的ORM框架<br>采用了Model,Field实例和Model实例来与数据库建立映射关系，从而实现面向对象的管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span>  create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化数据库连接，修改为你的数据库用户名和密码</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://root:xxx密码@localhost:3306/wucai&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer, Float</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"><span class="comment"># 定义Player对象:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ =<span class="string">&#x27;player&#x27;</span></span><br><span class="line">    <span class="comment"># 表的结构:</span></span><br><span class="line">    player_id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    team_id = Column(Integer)</span><br><span class="line">    player_name = Column(String(<span class="number">255</span>))</span><br><span class="line">    height = Column(Float(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对数据表进行增删改查</span></span><br><span class="line">    <span class="comment"># 创建DBSession类型:</span></span><br><span class="line">    DBSession = sessionmaker(bind=engine)</span><br><span class="line">    <span class="comment"># 创建session对象:</span></span><br><span class="line">    session = DBSession()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Player对象:</span></span><br><span class="line">    new_player=Player(team_id = <span class="number">1003</span>, player_name = <span class="string">&quot;约翰-科林斯&quot;</span>, height = <span class="number">2.08</span>)</span><br><span class="line">    <span class="comment"># 添加到session:</span></span><br><span class="line">    session.add(new_player)</span><br><span class="line">    <span class="comment"># 提交即保存到数据库:</span></span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="comment"># 关闭session:</span></span><br><span class="line">    session.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有点难运行出来，快哭了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201110155109230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;相当于持久化层&lt;br&gt;从数据库的涉及层面转化为面向对象的处理方式&lt;br&gt;三个ORM主流框架&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之python控制SQL</title>
    <link href="http://example.com/2020/11/10/python%E6%8E%A7%E5%88%B6SQL/"/>
    <id>http://example.com/2020/11/10/python%E6%8E%A7%E5%88%B6SQL/</id>
    <published>2020-11-10T07:39:16.286Z</published>
    <updated>2020-11-10T11:57:56.174Z</updated>
    
    <content type="html"><![CDATA[<p>python的DB API的规范是什么？<br>python程序<br><img src="https://img-blog.csdnimg.cn/20201110104319568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>总步骤<br>1.引入API模块<br>2.与数据库建立连接<br>3.执行SQL语句<br>4.关闭数据库连接</p><a id="more"></a><p>首先安装 connector<br>在终端写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-connector</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110110228284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>大家有用mac的同学，直接在anaconda中下载myql-connector就可<br>不用pip</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line">db= mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    user =<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    passwd =<span class="string">&quot;&quot;</span>,</span><br><span class="line">    database =<span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"><span class="comment"># 执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"><span class="comment"># 获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&quot;MySQL版本: %s &quot;</span> % data)</span><br><span class="line"><span class="comment"># 关闭游标&amp;数据库连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110132328417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>通过指定 host、user、passwd 和 port 等参数来创建数据库连接，这些参数分别对应着数据库 IP 地址、用户名、密码和端口号；<br>使用 db.close() 关闭数据库连接；<br>使用 db.cursor() 创建游标，操作数据库中的数据；<br>使用 db.begin() 开启事务；<br>使用 db.commit() 和 db.rollback()，对事务进行提交以及回滚。<br>当我们通过cursor = db.cursor()创建游标后，就可以通过面向过程的编程方式对数据库中的数据进行操作：<br>使用cursor.execute(query_sql)，执行数据库查询；<br>使用cursor.fetchone()，读取数据集中的一条数据；<br>使用cursor.fetchall()，取出数据集中的所有行，返回一个元组 tuples 类型；<br>使用cursor.fetchmany(n)，取出数据集中的多条数据，同样返回一个元组 tuples；<br>使用cursor.rowcount，返回查询结果集中的行数。如果没有查询到数据或者还没有查询，则结果为 -1，否则会返回查询得到的数据行数；<br>使用cursor.close()，关闭游标。<br><strong>对数据表进行增删改查</strong><br>查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&#x27;SELECT player_id, player_name, height FROM player WHERE height&gt;=2.08&#x27;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">data = cursor.fetchall()</span><br><span class="line"><span class="keyword">for</span> each_player <span class="keyword">in</span> data:</span><br><span class="line">  print(each_player)</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改球员&quot;约翰-科林斯&quot;的数据</span></span><br><span class="line">sql =<span class="string">&#x27;UPDATE player SET height =%s where  player_name =%s&#x27;</span></span><br><span class="line">val=(<span class="number">2.09</span>,<span class="string">&quot;约翰—科林斯&quot;</span>) <span class="comment">#传值</span></span><br><span class="line">cursor.execute(sql,val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount,<span class="string">&quot;记录被修改&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110151948210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql =<span class="string">&#x27;DELETE FROM player WHERE player_name = %s&#x27;</span></span><br><span class="line">val =(<span class="string">&quot;约翰—科林斯&quot;</span>,)</span><br><span class="line">cursor.execute(sql,val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount,<span class="string">&quot;记录删除成功。&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110152407934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>对于上面的CRUD操作，有几点需要注意<br>1.打开数据连接后，如果不在使用，就关掉<br>2.在执行操作时，可能会产生异常，这时就需要try…except捕获异常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line">db= mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    user =<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    passwd =<span class="string">&quot;&quot;</span>,</span><br><span class="line">    database =<span class="string">&#x27;player&#x27;</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"><span class="comment"># 执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"><span class="comment"># 获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&quot;MySQL版本: %s &quot;</span> % data)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"> sql =<span class="string">&quot;INSERT INTO player (team_id,player_name,height)values (%s,%s,%s)&quot;</span></span><br><span class="line"> val =(<span class="number">1003</span>,<span class="string">&quot;约翰—科林斯&quot;</span>,<span class="number">2.08</span>)</span><br><span class="line"> cursor.execute(sql,val)</span><br><span class="line"> db.commit()</span><br><span class="line"> print(cursor.rowcount,<span class="string">&quot;插入成功。&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment">#打印异常信息</span></span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    <span class="comment">#回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 关闭游标&amp;数据库连接</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br></pre></td></tr></table></figure><p>那么，mysql-connector驱动的方式只是其中一种<br>我们也可以引入ORM框架，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象</p><p>如果针对少量的对象管理，那么我们完全可以用mysql-connector驱动的方式，引入一个框架学习成本太高，代码膨胀也很厉害<br><img src="https://img-blog.csdnimg.cn/20201110104937888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python的DB API的规范是什么？&lt;br&gt;python程序&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201110104319568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;总步骤&lt;br&gt;1.引入API模块&lt;br&gt;2.与数据库建立连接&lt;br&gt;3.执行SQL语句&lt;br&gt;4.关闭数据库连接&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之游标</title>
    <link href="http://example.com/2020/11/09/%E6%B8%B8%E6%A0%87/"/>
    <id>http://example.com/2020/11/09/%E6%B8%B8%E6%A0%87/</id>
    <published>2020-11-09T14:26:58.691Z</published>
    <updated>2020-11-09T14:26:58.691Z</updated>
    
    <content type="html"><![CDATA[<p>面向集合<br>集合思维更像是从整体的角度来考虑<br>然后把整个数据集不同的树形进行划分，形成不同的子集合<br><strong>游标</strong><br>  <a id="more"></a><br>定义游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement</span><br></pre></td></tr></table></figure><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure><p>从游标中获得数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name</span><br></pre></td></tr></table></figure><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure><p>释放游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DEALLOCATE</span> cousor_namec</span><br></pre></td></tr></table></figure><p>实战例子<br>我想用游标来扫描heros数据表中的数据行，然后累计最大生命值<br>创建一个存储过程 calc_hp_max,然后在存储过程中定义游标cur_gero,使用FETCH获取每一行的具体数值，然后赋给变量hp，再用变量hp_sum做累加求和，最后再输出hp_sum（对于工程师来说简单的累加而已）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`calc_hp_max`</span>()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">DECLARE</span> hp <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> hp_sum <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> cur_hero <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> hp_max <span class="keyword">from</span> heros;</span><br><span class="line"> </span><br><span class="line"> OPEN cur_hero;</span><br><span class="line"> read_loop:LOOP</span><br><span class="line"> FETCH cur_hero INTO hp;</span><br><span class="line"> <span class="keyword">SET</span> hp_sum =hp_sum + hp;</span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"> CLOSE cur_hero;</span><br><span class="line"> <span class="keyword">SELECT</span> hp_sum;</span><br><span class="line"> <span class="keyword">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当使用call calc_hp_max()时，会出现1329错误</p><p>我们判断游标溢出<br>当游标溢出时，我们可以制定一个continue事件，这个事件发生后会改变done的值，以此来判断是否溢出</p><p>所以我们要在循环中加上对done的判断，如果游标的循环已经结束，就需要跳出read_loop的循环，意思说只要done的值已经变为false,就可以跳出read_loop的循环了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> calc_hp_max()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201109192421572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201109192633232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我们遇到这种问题时，可以用游标来进行转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`alter_attack_growth`</span>()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="comment">-- 创建接收游标的变量</span></span><br><span class="line">       <span class="keyword">DECLARE</span> temp_id <span class="built_in">INT</span>;  </span><br><span class="line">       <span class="keyword">DECLARE</span> temp_growth, temp_max, temp_start, temp_diff <span class="built_in">FLOAT</span>;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">-- 创建结束标志变量  </span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">-- 定义游标     </span></span><br><span class="line">       <span class="keyword">DECLARE</span> cur_hero <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>, attack_growth, attack_max, attack_start <span class="keyword">FROM</span> heros;</span><br><span class="line">       <span class="comment">-- 指定游标循环结束时的返回值  </span></span><br><span class="line">       <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">SET</span> done = <span class="literal">true</span>;  </span><br><span class="line">       </span><br><span class="line">       OPEN cur_hero;  </span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       REPEAT</span><br><span class="line">                     IF NOT done THEN</span><br><span class="line">                            <span class="keyword">SET</span> temp_diff = temp_max - temp_start;</span><br><span class="line">                            IF temp_growth &lt; 5 THEN</span><br><span class="line">                                   IF temp_diff &gt; 200 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.1</span>;</span><br><span class="line">                                   ELSEIF temp_diff &gt;= 150 AND temp_diff &lt;=200 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.08</span>;</span><br><span class="line">                                   ELSEIF temp_diff &lt; 150 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.07</span>;</span><br><span class="line">                                   <span class="keyword">END</span> <span class="keyword">IF</span>;                       </span><br><span class="line">                            ELSEIF temp_growth &gt;=5 AND temp_growth &lt;=10 THEN</span><br><span class="line">                                   <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.05</span>;</span><br><span class="line">                            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">                            <span class="keyword">UPDATE</span> heros <span class="keyword">SET</span> attack_growth = <span class="keyword">ROUND</span>(temp_growth,<span class="number">3</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = temp_id;</span><br><span class="line">                     <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       UNTIL done = true <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">       </span><br><span class="line">       CLOSE cur_hero;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> heros.id, heros.attack_growth</span><br><span class="line"><span class="keyword">FROM</span> heros  </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201109194723622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向集合&lt;br&gt;集合思维更像是从整体的角度来考虑&lt;br&gt;然后把整个数据集不同的树形进行划分，形成不同的子集合&lt;br&gt;&lt;strong&gt;游标&lt;/strong&gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
