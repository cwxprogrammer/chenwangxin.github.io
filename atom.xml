<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-01T10:21:52.235Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日深耕，勤练不缀之JSON</title>
    <link href="http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/"/>
    <id>http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/</id>
    <published>2020-12-01T10:20:12.365Z</published>
    <updated>2020-12-01T10:21:52.235Z</updated>
    
    <content type="html"><![CDATA[<p>json<br>W3school<br>JSON 是存储和交换文本信息的语法<br>比xml更小，更方便</p><a id="more"></a><p>语法：<br>1.基本规则<br>数据在名称/值对中：由键值对构成。<br>    *键用引号引起来，也可以不使用引号；<br>    *值的取值类型：数字（整数或浮点数）<br>        a.字符串（在双引号中）<br>        b.逻辑值（true 或 false）<br>        c.数组（在方括号中）如：{“persons”:[{},{}]}<br>        d.对象（在花括号中）如：{“address”:{“province”:”陕西”…}}<br>        e.null<br>数据由逗号分隔：多个键值对由逗号分隔<br>花括号保存对象：使用{}定义json格式<br>方括号保存数组<br>2.获取数据<br> *使用json对象.键名<br> *json对象[“键名”]<br> *数组对象[]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>json数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//1.定义基本格式</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> person =&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(person)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// for(var key in person)&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     alert(key+&quot;:&quot;+person[key]);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式： 数组[]----&gt;&#123;&#125;Json对象里面有数组</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> persons= &#123;<span class="string">&quot;psersons&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;]&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(persons);</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式&#123;&#125;--&gt;[]本身就是数组，里面存放json对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ps=[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(ps);</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ps.length;i++</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p =ps[i];</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> p</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(key+<span class="string">&quot;:&quot;</span>+p[key]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Json当做数据的载体，转换为java对象（可以转换为任何对象）</p><p> 1.java转换成JSON<br>  json解析器：jsonlab,Gson,fastjson,jsckson(springmvc)<br> .使用步骤：<br> *导入jackson的相关jar包<br> *创键jackson核心对象ObjectMapper<br> *调用ObjectMapper的WriteValue方法来进行转换</p><p> 2.JSON 转换为 java<br>  readvalue(json,class对象)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package JSON.test;</span><br><span class="line"></span><br><span class="line">import JSON.domain.Person;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Jackson &#123;</span><br><span class="line"></span><br><span class="line">    //java对象转为JSON字符串1.字符串2.键：数组3 数组</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() throws IOException &#123;</span><br><span class="line">        //1.创建几个Person对象</span><br><span class="line">        Person p =new Person();</span><br><span class="line">        p.setName(&quot;张山&quot;);</span><br><span class="line">        p.setAge(23);</span><br><span class="line">        p.setGender(&quot;男&quot;);</span><br><span class="line">        //2.创建Jackson的核心对象  ObjectMapper</span><br><span class="line">        ObjectMapper mapper =new ObjectMapper();</span><br><span class="line">        //3.转换</span><br><span class="line">        /**</span><br><span class="line">         * 转换方法：</span><br><span class="line">         * writevalue (参数1,obj):</span><br><span class="line">         *      参数1：</span><br><span class="line">         *        File:将obj对象转换成JSON字符串，并保存到指定文件中</span><br><span class="line">         *        Writer:将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</span><br><span class="line">         *        OutputStream；将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</span><br><span class="line">         * writeValueAsString(obj):将对象转换为json</span><br><span class="line">         */</span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        //System.out.println(json);</span><br><span class="line">        mapper.writeValue(new FileWriter(&quot;/Users/chenwangxin/Desktop/a.txt&quot;),p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        //1.初始化JSON字符串</span><br><span class="line">        String json =&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23,\&quot;gender\&quot;:true&#125;&quot;;</span><br><span class="line">        //2.创建objectMapper</span><br><span class="line">        ObjectMapper  ob =new ObjectMapper();</span><br><span class="line">        //3.调用readValue()</span><br><span class="line">        Person person=ob.readValue(json,Person.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;json&lt;br&gt;W3school&lt;br&gt;JSON 是存储和交换文本信息的语法&lt;br&gt;比xml更小，更方便&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JQUERY实现AJAX</title>
    <link href="http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-01T10:11:57.504Z</published>
    <updated>2020-12-01T10:22:36.994Z</updated>
    
    <content type="html"><![CDATA[<p>JQUERY实现AJAX:</p><p>AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML<br>1.异步和同步  客户端和服务器端同步通信的基础上<br>2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术<br>提升用户的体验</p><a id="more"></a><p>实现方式：<br>JQuery实现方式<br>1.$.ajax()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//使用$.ajax()发送异步请求</span></span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;ajaxServlet&quot;</span>,<span class="comment">//请求路径</span></span></span><br><span class="line"><span class="javascript">                type:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">                    alert(data)</span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//响应成功后的回调函数</span></span></span><br><span class="line"><span class="javascript">                error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;出错啦。。&quot;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//请求响应失败会执行回调函数</span></span></span><br><span class="line"><span class="javascript">                dataType:<span class="string">&quot;text&quot;</span><span class="comment">//设置接受到的响应数据的格式</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.$.get()：发送get请求<br>    参数：<br>    url:请求路径<br>    data:请求参数<br>    callback:回调函数<br>    type：响应结果的类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">         $.get(<span class="string">&quot;ajaxServlet&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;rose&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">             alert(data);</span><br><span class="line"><span class="javascript">         &#125;,<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.$.post()：发送post请求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JQUERY实现AJAX:&lt;/p&gt;
&lt;p&gt;AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML&lt;br&gt;1.异步和同步  客户端和服务器端同步通信的基础上&lt;br&gt;2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术&lt;br&gt;提升用户的体验&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Jquery</title>
    <link href="http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/"/>
    <id>http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/</id>
    <published>2020-12-01T10:08:20.626Z</published>
    <updated>2020-12-01T10:23:05.575Z</updated>
    
    <content type="html"><![CDATA[<p>Jquery是一个优秀的js框架<br>优化了DOM的操作，事件处理、动画设计、Ajax交互<br>JQuery对象和JS对象区别与转换？<br>divs.html(“bbb”)<br>jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）</p><a id="more"></a><p>转换一下：js—&gt;jq: $(js对象) 就可以转换了<br>             jq—&gt;js: jq对象[索引]或者jq对象.get(索引)<br>选择器:筛选具有相似特征的元素（标签）<br>//jquery入口函数（dom文档加载完成之后执行入口函数）<br>        $(function () {<br>            //$(“#div1”).css(“background-color”,”red”);<br>            $(“#div1”).css(“backgroundColor”,”pink”);</p><pre><code>    &#125;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jquery是一个优秀的js框架&lt;br&gt;优化了DOM的操作，事件处理、动画设计、Ajax交互&lt;br&gt;JQuery对象和JS对象区别与转换？&lt;br&gt;divs.html(“bbb”)&lt;br&gt;jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之HTTPServlet的解释</title>
    <link href="http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2020-11-27T10:40:41.376Z</published>
    <updated>2020-11-27T10:43:47.033Z</updated>
    
    <content type="html"><![CDATA[<p>将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象<br>将来定义servlet类时，可以继承GenericServlet，实现service()方法即可</p><a id="more"></a><p>HTTPServlet（有七种解决方式）<br>不用再去判断请求方式，对http协议的一种封装<br>复写doGet(){}方法，浏览器直接请求是get方式<br>复写doPost(){}方法，表单请求是POST方式</p><p>注解配置<br>ServletDemo4<br>一个Servlet可以定义多个访问路径<br>路径定义规则：</p><ol><li> /xxx</li><li> /xxx/xxx:多层路径,目录结构</li><li> *.do<br>调用Servlet，就可以将自己的信息提交到后台了</li></ol><p>基于TCP/IP的高级协议<br>端口号：80<br>基于请求响应模型，一次请求一次响应<br>无状态：每次请求相互独立，不能交互数据</p><p>向服务器发送请求，js  css 图片  都是单独的请求。<br>1.0：每一次请求都会建立新的连接<br>1.1：复用连接（建立连接后，请求完gif图片，等一会儿，没有数据发送了，连接释放掉）</p><p>请求消息数据格式<br>1.请求行<br>2.请求头<br>3.请求空行<br>4.请求体</p><p>请求的是谁？是客户端</p><p>响应消息数据格式<br>GET:1.请求参数在请求行中，在url后  2.请求的url长度有限制  不安全<br>POST: 请求参数在请求体中 2.url长度没有限制，比如文件上传等大文件只能用post</p><p>请求头：浏览器告诉了服务器我个人的一些信息啊<br>告诉服务器使用的浏览器版本信息，可以解决兼容性的问题</p><p>Request:<br>原理：1.tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo的对象<br>2.tomcat服务器，会创建request和response对象，request对象中封装请求消息数据<br>3.tomcat将request和response两个对象传递给Service方法，并且调用service方法<br>代码如下：<br>@WebServlet(“/demo1”)<br>public class ServletDemo1 implements Servlet{<br>    service(servletRequest,servletResponse){<br>    4.程序员可以通过request对象获取请求数据消息，通过response对象设置响应消息数据<br>    }<br>}<br>5.服务器回传响应消息会从response对象中拿程序员设置的响应消息格式、</p><p>继承体系结构：<br>tomcat创建的</p><p>功能：<br>       //1.获取请求方式： GET<br>        String method =req.getMethod();<br>        System.out.println(method);<br>        //2.(*)获取虚拟目录页<br>        String contextPath=req.getContextPath();<br>        System.out.println(contextPath);<br>        //3.获取Servlet路径 ：/demo1<br>        String servletPath=req.getServletPath();<br>        System.out.println(servletPath);<br>        //4.获取get方式请求参数:name=zhangsan<br>        String queryString=req.getQueryString();<br>        System.out.println(queryString);<br>        //5.获取请求URL<br>        String requesURI=req.getRequestURI();<br>        StringBuffer requestURL =req.getRequestURL();<br>        System.out.println(requesURI);<br>        System.out.println(requestURL);<br>        //6.客户的协议和版本<br>        String protocol=req.getProtocol();<br>        System.out.println(protocol);<br>        //7.获取客户机的IP<br>        String remoteAddr=req.getRemoteAddr();<br>        System.out.println(remoteAddr);</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象&lt;br&gt;将来定义servlet类时，可以继承GenericServlet，实现service()方法即可&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JDBC快速抽取工具类</title>
    <link href="http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-27T10:33:21.969Z</published>
    <updated>2020-11-27T10:44:37.774Z</updated>
    
    <content type="html"><![CDATA[<p>jdbc抽取工具类<br>1.注册驱动抽取<br>2.连接对象方法抽取<br>3.释放资源方法抽取</p><a id="more"></a><p>不想传递参数，还得保证工具类的通用性，<br>解决:配置文件<br>src目录下面：<br>public class JDBCUtils{<br>   private static String url;<br>   private static String user;<br>   private static String password;<br>   private static String driver;<br>    文件的读取，只需要读取一次即可拿到这些值，使用静态代码块<br>    static{<br>    1.创建Properties集合类<br>       properties pro =new  properties();<br>    获取src路径下的文件的方式–&gt;ClassLoader类加载器<br>    ClassLoader classloader =JDBCUtils.class.getClassLoader();<br>    URL res =classLoader.getResource(jdbc.properties);<br>    String path =res.getPath();</p><pre><code>2.加载文件  //pro.load(new FileReader(fileNmae:&quot;src/jdbc.properties&quot;));   pro.load(path); 3.获取数据，赋值  url =pro.getProperty(&quot;url&quot;);  user =pro.getProperty(&quot;user&quot;);  password =pro.getProperty(&quot;password&quot;);  driver=pro.getProperty(&quot;driver&quot;);4.获取驱动  Class.forName(&quot;driver&quot;);&#125;</code></pre><p>}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;jdbc抽取工具类&lt;br&gt;1.注册驱动抽取&lt;br&gt;2.连接对象方法抽取&lt;br&gt;3.释放资源方法抽取&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决小伙伴们深度学习时模型训练的硬件问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T09:01:35.461Z</published>
    <updated>2020-11-25T09:19:54.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习YOLOv3来训练voc模型<br>可想而知一个15年的mac或者老版本的Windows电脑难堪重负。<br>在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！<br><img src="https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。<br>几番抉择后，选择了滴滴云服务器,因为价格！！！<br><a href="https://www.didiyun.com/">https://www.didiyun.com</a></p><a id="more"></a><p>一、大家可以使用云服务器（带GPU）,我顺便搞了个大师码：8996，还给打了⑨折<br>而且最重要的是他家的时间 是按照你用的时间算，你结束时它不会给你计费，意思说你按小时买也特别划算，经济实惠。<br><img src="https://img-blog.csdnimg.cn/20201125163558908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201125164349470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注：大家如果使用云服务器训练。可以参考这篇博文：<br><a href="https://blog.csdn.net/ForeeverF/article/details/103651924%EF%BC%8C%E6%91%98%E8%87%AA">https://blog.csdn.net/ForeeverF/article/details/103651924，摘自</a> Byronnar博主<br>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p><p>需要自己配置环境</p><p>二、还可以使用network，这个就很香，你可以直接跑<br><img src="https://img-blog.csdnimg.cn/20201125164852326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020112516504538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我买个4核处理器的GPU云算力，一小时才三块钱，就可以运行我的项目，还不用担心自己电脑宕机，而我们的所有代码操作都可以在本机上操作，将其利用，具体操作请参考。<br><a href="https://help.didiyun.com/hc/kb/section/1151520/">https://help.didiyun.com/hc/kb/section/1151520/</a><br>三、接下来附上我的学习路径，供大家参考<br><strong>这位大佬讲得特别好，利用VOC2012的训练集训练</strong><br>具体代码以及步骤：<a href="https://github.com/cwxprogrammer/deep-learning-for-image-processing.git">https://github.com/cwxprogrammer/deep-learning-for-image-processing.git</a></p><p>视频理论讲解：<br><a href="https://www.bilibili.com/video/BV1yi4y1g7ro?p=1">https://www.bilibili.com/video/BV1yi4y1g7ro?p=1</a><br>源码讲解：<br><a href="https://www.bilibili.com/video/BV1t54y1C7ra?t=250">https://www.bilibili.com/video/BV1t54y1C7ra?t=250</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习YOLOv3来训练voc模型&lt;br&gt;可想而知一个15年的mac或者老版本的Windows电脑难堪重负。&lt;br&gt;在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。&lt;br&gt;几番抉择后，选择了滴滴云服务器,因为价格！！！&lt;br&gt;&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决部署前后端分离时运行内存太小的问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T07:55:10.290Z</published>
    <updated>2020-11-25T09:18:39.425Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常都会用前后端分离部署我们的项目<br>1.需要使用虚拟机<br>2.内存不够用（因为每个虚拟机最少需要2G内存）<br>3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响<br>4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天</p><p>我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201125155056501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>会自动给你IP<br><img src="https://img-blog.csdnimg.cn/20201125155237451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>重点：我发现云服务器恰好解决了我的燃眉之急，解决了我囊中羞涩不能买高配电脑的痛苦。</p><p>我用的是滴滴云服务器，便宜。<br>你租一个云服务器，自带centos7.6<br>才不到几毛钱。<br>而且买时长，你只要关了就不算时长，很nice。</p><p>解决了硬件问题<br>具体部署视频羊哥已经讲得很详细了：<br>贴个视频链接：<br><a href="https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710">https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们通常都会用前后端分离部署我们的项目&lt;br&gt;1.需要使用虚拟机&lt;br&gt;2.内存不够用（因为每个虚拟机最少需要2G内存）&lt;br&gt;3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响&lt;br&gt;4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天&lt;/p&gt;
&lt;p&gt;我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测②传统检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:49:55.278Z</published>
    <updated>2020-11-24T05:58:14.207Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务</p><p><strong>什么是传统目标检测？</strong><br>首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？<br>传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器</p><a id="more"></a><p>即首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。下面我们对这三个阶段分别进行介绍</p><p>2.2.1区域选取<br>这一步是为了对目标的位置进行定位。由于目标可能出现在图像的任何位置，而且目标的大小、长宽比例也不确定，所以最初采用滑动窗口的策略对整幅图像进行遍历，而且需要设置不同的尺度，不同的长宽比。这种穷举的策略虽然包含了目标所有可能出现的位置，但是缺点也是显而易见的：时间复杂度太高，产生冗余窗口太多，这也严重影响后续特征提取和分类的速度和性能。（实际上由于受到时间复杂度的问题，滑动窗口的长宽比一般都是固定的设置几个，所以对于长宽比浮动较大的多类别目标检测，即便是滑动窗口遍历也不能得到很好的区域）</p><p>2.2.2特征的设计<br>传统检测方法的特征提取算法主要有两种:HOG特征和lbp算法<br>HOG：方向梯度直方图（Histogram of Oriented Gradient, HOG）。使用梯度直方图来描述的形状特征。主要在行人检测方面。从名字可知，主要将图像中的pixel的方向变化作为特征。因为梯度变化主要是发生在物体边缘，这样就可以知道物体的大致形状。可以进行物体分类或者检测。经典的特征提取一般需要一些超参，比如窗口大小等。<br>提取方法：讲一个image灰度化—&gt;颜色空间的标准化—&gt;计算图像每个像素的梯度        —&gt;将图像划分成小cells—&gt;统计每个cell的梯度直方图    —&gt; 将每几个cell组成一个block—&gt;将图像image内的所有block的HOG特征descriptor串联起来。                                                                                       Lbp算法：LBP（Local Binary Pattern，局部二值模式），反映了局部的纹理特征，跟一个像素的邻域有关。对每个像素的邻域做减法，大于用1表示，否则用0表示则产生了一个二进制数来表示这个像素的局部纹理。这个邻域其实也相当于一个window，window的形状也是可以改变的。</p><p>2.2.3分类器的设计<br>一、利用AdaBoost算法进行训练<br>并不是所有特征都是有用的，AdaBoost特征分类器具有特征选择的能力。<br>AdaBoost 将一系列的弱分类器通过线性组合，构成一个强分类器，<br>如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20201124101332709.gif#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201124101404821.gif#pic_center" alt="在这里插入图片描述"><br>是一个强分类器。</p><p><img src="https://img-blog.csdnimg.cn/2020112410144766.gif#pic_center" alt="在这里插入图片描述">是一个弱分类器，其为一个简单的阈值函数<br><img src="https://img-blog.csdnimg.cn/20201124101601130.gif#pic_center" alt="在这里插入图片描述">为阈值，<br><img src="https://img-blog.csdnimg.cn/20201124101640957.gif#pic_center" alt="在这里插入图片描述">，<br><img src="https://img-blog.csdnimg.cn/20201124101705301.gif#pic_center" alt="在这里插入图片描述">为系数。</p><p>二、训练弱分类器<br>计算所有训练样本的特征值，并将其从小到大排序，随机选取一个特征值作为阈值，把所有元素分为两部分，小于阈值的一部分分类为人脸，大于阈值的一部分分类为非人脸。如下图所示，红色表示人脸，蓝色表示非人脸。</p><p>假如有5个样本，前两个为人脸，后三个为非人脸，用11000表示。如果阈值在第一个之前，通过弱分类器判定为：00000，有两个误差，如果阈值在第一个和第二个之间，通过弱分类器判定为：10000，有1个误差，如果阈值在第二个和第三个之间，通过弱分类器判定为：11000，有0个误差，依次类推，这样共有6个误差，然后从中找到一个误差最小的当成阈值，这样就训练好了一个最优的弱分类器。</p><p><img src="https://img-blog.csdnimg.cn/20201124101841712.gif#pic_center" alt="在这里插入图片描述"><br>三、训练强分类器<br>假设有N个训练样本</p><p><img src="https://img-blog.csdnimg.cn/20201124101922423.gif#pic_center" alt="在这里插入图片描述"><br>,其中有M个正样本，L个负样本，如果<img src="https://img-blog.csdnimg.cn/20201124102024949.gif#pic_center" alt="在这里插入图片描述"></p><p>是人脸图像，则<img src="https://img-blog.csdnimg.cn/20201124102039875.gif#pic_center" alt="在这里插入图片描述"></p><p>, 否则<img src="https://img-blog.csdnimg.cn/20201124102051958.gif#pic_center" alt="在这里插入图片描述"></p><p>其步骤如下：<img src="https://img-blog.csdnimg.cn/20201124102108830.gif#pic_center" alt="在这里插入图片描述"></p><p>每一级分类器使用的训练集中的负样本，都是上一级被错分的，即false positive，误检率或假阳性。这使得下一级分类器更加关注那些更难的（容易被错分的）样本。</p><p>2、2、4 总结：<br>传统检测历史久远，然而一直以来存在着两个主要问题：<br>1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余<br>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是传统目标检测？&lt;/strong&gt;&lt;br&gt;首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？&lt;br&gt;传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测①创建数据集</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A0%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2020-11-24T05:49:37.858Z</published>
    <updated>2020-11-24T05:57:49.491Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务<br>一、研究问题<br>目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。</p><a id="more"></a><p>目标检测的任务是找出图像中所有感兴趣的目标，确定它们的位置和类别。<br>图像识别有四大类任务：<br>分类（Classification）： 解决”what”。<br>定位（Location）：解决”where“。<br>检测（Detection）：解决”what &amp; where“。<br>分割（Segmentation）：分为 实例分割（Instance-level）和 语义分割（semantic segmentation）。解决“每一个像素属于哪个实例或哪一类”。</p><p><img src="https://img-blog.csdnimg.cn/2020112316015579.png#pic_center" alt="在这里插入图片描述"></p><p>1.2 问题特性<br>由于各类物体有不同的外观、形状、姿态，加上成像时光照，遮挡等因素的干扰，目标检测一直是计算机视觉领域最具有挑战的问题。<br>除了图像分类以外，目标检测要解决的核心问题是：<br>1、目标可能出现在图像的任何位置。<br>2、目标有各种不同的大小。<br>3、目标有各种不同的形状。<br>则如果用矩形框来定义目标，则矩形框需要有不同的宽高比。由于目标的宽高比不同，因此采用传统的滑动窗口+图像缩放的方案解决通用目标检测问题的成本太高。</p><p>二、算法分析<br>2.1 目标检测数据集<br>Pascal Voc和COCO是目标检测任务最常用的数据集</p><p>2.1.1 PASCAL VOC<br>Pascal 的全程是 Pattern Analysis, Statical Modeling and Computational Learning。<br>PASCAL VOC 挑战赛是视觉对象的分类识别和检测的一个基准测试，提供了检测算法和学习性能的标准图像注释数据集和标准的评估系统。<br><a href="https://pjreddie.com/media/files/VOC2012_doc.pdf">https://pjreddie.com/media/files/VOC2012_doc.pdf</a><br>2.1.1.1Pascal Voc数据集格式分析<br>1）文件结构<br><img src="https://img-blog.csdnimg.cn/20201123191037131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>数据集下载后解压得到一个名为VOCdevkit的文件夹，该文件夹结构如下：<br>Annotations //xml文件，该文件是对图片的解释，每张图片都对应一个同名的xml文件。<br>ImageSets //txt文件，txt文件中每行都包含图片的名称，末尾会加上±1表示正负样本<br>针对目标检测主要看Main<br>——Action<br>——Layout<br>——Main<br>——Segmentation<br>JPEGImages //数据集的原图片<br>SegmentationClass //图片，语义分割相关<br>SegmentationObject //图片，实例分割相关</p><p> 2.1.1.2 创建自己的pascal voc数据集<br> 下载图像标记软件<br>  git clone  <a href="https://github.com/tzutalin/labelimg">https://github.com/tzutalin/labelimg</a><br>  步骤：<br>  anaconda+pip install labelImg<br>  注：在这里我要说一句：python是Python，anaconda是anaconda,你选择环境时候可以二选一，个人建议anaconda,确实省力。<br>如下截图：</p><p><img src="https://img-blog.csdnimg.cn/20201123190056211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>修改标注类别信息—&gt;设置图像文件所在目录以及标注文件保存目录-&gt;标注图像并保存-&gt;打开labelImg<br>利用create/nRectBox截取并生成xml<br>具体代码：<br>1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BatchRename</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    批量重命名文件夹中的图片文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 我的图片文件夹路径</span></span><br><span class="line">        self.path = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        filelist = os.listdir(self.path)</span><br><span class="line">        total_num = <span class="built_in">len</span>(filelist)</span><br><span class="line">        i = <span class="number">1</span>       <span class="comment"># 设置第一个文件名</span></span><br><span class="line">        n = <span class="number">6</span>       <span class="comment"># 设置文件名长度，如000001，长度为6</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> filelist:</span><br><span class="line">            <span class="comment"># 这里修改的是jpg文件，如果要修改其他类型的文件，请手动将下面两个&#x27;.jpg&#x27;修改为对应的文件后缀</span></span><br><span class="line">            <span class="keyword">if</span> item.endswith(<span class="string">&#x27;.jpg&#x27;</span>):</span><br><span class="line">                n = <span class="number">6</span> - <span class="built_in">len</span>(<span class="built_in">str</span>(i))</span><br><span class="line">                src = os.path.join(os.path.abspath(self.path), item)</span><br><span class="line">                dst = os.path.join(os.path.abspath(self.path), <span class="built_in">str</span>(<span class="number">0</span>) * n + <span class="built_in">str</span>(i) + <span class="string">&#x27;.jpg&#x27;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.rename(src, dst)</span><br><span class="line">                    print(<span class="string">&#x27;converting %s to %s ...&#x27;</span> % (src, dst))</span><br><span class="line">                    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">&#x27;total %d to rename &amp; converted %d jpgs&#x27;</span> % (total_num, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    demo = BatchRename()</span><br><span class="line">    demo.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若之后想加图片，只需要把i改了<br>2）<br>labelImg打标签，把图片保存到Annotations文件夹<br>3)<br>生成Main文件夹下面的txt文件<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">trainval_percent = <span class="number">0.7</span>      <span class="comment"># 训练集和验证集 占 数据集 的比例</span></span><br><span class="line">train_percent = <span class="number">0.6</span>         <span class="comment"># 训练集 占 训练集和验证集 的比例</span></span><br><span class="line"><span class="comment"># 把xml路径修改为自己的Annotations文件夹路径</span></span><br><span class="line">xmlfilepath = <span class="string">&#x27;E:/xxx/VOC/Annotations&#x27;</span></span><br><span class="line"><span class="comment"># 把保存路径修改为自己的Main文件夹路径</span></span><br><span class="line">savepath = <span class="string">&#x27;E:/xxx/VOC/ImageSets/Main&#x27;</span></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">len</span>(total_xml)</span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">range</span>(num)</span><br><span class="line">tv = <span class="built_in">int</span>(num * trainval_percent)</span><br><span class="line">tr = <span class="built_in">int</span>(tv * train_percent)</span><br><span class="line">trainval = random.sample(<span class="built_in">list</span>, tv)</span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line"></span><br><span class="line">ftrainval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/trainval.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftest = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">ftrain = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/train.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fval = <span class="built_in">open</span>(savepath + <span class="string">&#x27;/val.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    name = total_xml[i][:<span class="number">-4</span>] + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line">        ftrainval.write(name)</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line">            ftrain.write(name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fval.write(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ftest.write(name)</span><br><span class="line"></span><br><span class="line">ftrainval.close()</span><br><span class="line">ftrain.close()</span><br><span class="line">fval.close()</span><br><span class="line">ftest.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，我们理解了Pascal voc的格式，并且可以创造属于自己的数据集进行对图片进行目标检测任务的实现。</p><p>2.1.2 COCO<br>这里简单说一下coco<br>MS COCO的全称是Microsoft Common Objects in Context，起源于微软于2014年出资标注的Microsoft COCO数据集，与ImageNet竞赛一样，被视为是计算机视觉领域最受关注和最权威的比赛之一。<br>COCO数据集是一个大型的、丰富的物体检测，分割和字幕数据集。这个数据集以scene understanding为目标，主要从复杂的日常场景中截取，图像中的目标通过精确的segmentation进行位置的标定。图像包括91类目标，328,000影像和2,500,000个label。目前为止有语义分割的最大数据集，提供的类别有80 类，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。</p><p>总的来说,无论数据集以什么格式存储在txt，xml甚至是工作表中。我们需要在算法的实现代码中实现能定位并使用这些各类数据的表达式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;br&gt;一、研究问题&lt;br&gt;目标检测，也叫目标提取，是一种基于目标几何和统计特征的图像分割，它将目标的分割和识别合二为一，其准确性和实时性是整个系统的一项重要能力。尤其是在复杂场景中，需要对多个目标进行实时处理时，目标自动提取和识别就显得特别重要。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法（续）</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88%E7%BB%AD1%EF%BC%89/</id>
    <published>2020-11-24T05:49:20.680Z</published>
    <updated>2020-11-24T05:59:05.379Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型</p><p><img src="https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>相比于之前的网络架构，Yolov3有两点提升：<br> <a id="more"></a><br>1)残差结构<br>神经网络训练的过程就是调整参数的过程，可以调整的参数越多，意味着调整的自由度越大，从而逼近效果越好。因此层次越深，可以表示的特征抽象程度越高，可以做出很多只有人类才能做到的需要高度抽象理解能力的事情，在某些特定任务上“效果越好”。<br>然而随着网络深度增加，准确度增加，神经网络会产生梯度消失/梯度爆炸的问题。<br>梯度消失/梯度爆炸指本质上因为梯度反向传播中的连乘效应，造成网络权值更新不稳定，从而使此深层网络的学习几乎等价于只有后几层的浅层网络的学习了，造成网络退化问题。</p><p>Darknet的残差结构(在resnet论文提出的概念)解决了这个问题<br><img src="https://img-blog.csdnimg.cn/20201124125953185.gif#pic_center" alt="在这里插入图片描述"></p><p>在上图的残差网络结构图中，通过 “shortcut connections (捷径连接)” 的方式，直接把输入 x 传到输出作为初始结果，输出结果为 H(x)=F(x)+x，当 F(x)=0 时，那么 H(x)=x，也就是上面所提到的恒等映射。于是，残差结构相当于将学习目标改变了，不再是学习一个完整的输出，而是目标值H(X) 和 x 的差值，也就是所谓的残差 F(x) = H(x)-x，因此，后面的训练目标就是要将残差结果逼近于 0，使到随着网络加深，准确率不下降。<br>resnet论文：<a href="https://arxiv.org/pdf/1512.03385v1.pdf">https://arxiv.org/pdf/1512.03385v1.pdf</a><br>《Deep Residual Learning》——何恺明2016cvpr<br><img src="https://img-blog.csdnimg.cn/20201124130034244.gif#pic_center" alt="在这里插入图片描述"></p><p>feature map 通过 Residual 残差模块前后其 shape 不变。并且，在输入的参数中，要保证 input_channel = filter_num2，否则相加的操作会因为 shape 不同而无法进行。<br>2)多尺度预测<br>同时，yolov3也在多尺度预测上做出改进(类似于FPN)<br>多尺度预测实现了从基础网络输出多个不同尺度作为输入，解决图像中待检测物体大小不同的问题。<br>利用网络对物体进行检测时，浅层网络分辨率高，学到的是图片的细节特征，深层网络，分辨率低，学到的更多的是语义特征，如报告2、3、2提到。<br>因此我们选择利用图像的各个尺度进行训练和测试。可以通过缩放图片提取多组特征图预测，但是想必这样及其消耗时间——因此直接使用卷积网络中产生的各层特征图分别进行预测<br><img src="https://img-blog.csdnimg.cn/20201124130119618.gif#pic_center" alt="在这里插入图片描述"></p><p>《Feature Pyramid Networks for Object Detection》——2017CVPR<br>如上页图Darknet53，以scale2为例，从尺度1中的倒数第二层的卷积层上采样（× 2），再与最后一个 16 × 16 大小的特征图相加，再次通过多个卷积后输出box信息，相比尺度1变大两倍。</p><p>上采样的作用是在后面 YOLOv3 网络中进行相加操作时保证两个 feature map 的宽和高相同，其具体操作为：将输入的 feature map 的宽高都乘 2，得到新的 feature map。如下图代码</p><p>可以看到，route_1，route_2，input_data三个不同尺度的输出到后续网络</p><p><img src="https://img-blog.csdnimg.cn/20201124130202892.gif#pic_center" alt="在这里插入图片描述"></p><p>3.2.2输出定义<br>先来看yolov3的整体结构，随后具体介绍yolov3输出各个维度定义<br>在结构中，我们设置用的数据集类别为80种。<br>下图中左半部分虚线框内即为Darknet-53网络机构，可以看到该网络结构的输入为 416×416×3，之后通过一个3×3的卷积层来扩增通道数。接下来通过堆叠一系列Residual Block来构建网络，其具体个数为[1, 2, 8, 8, 4]，最终主干网络输出大小为13×13、26×26、52×52三个大小的特征图，目的是可以检测到图像中更小的物体。特征图分割越密集，则每一个特征点相对于原图中的区域越小，从而可以监测到更小的物体。这部分即是上一节提到的“多分类预测”<br><img src="https://img-blog.csdnimg.cn/20201124130336823.gif#pic_center" alt="在这里插入图片描述"></p><p>网络结构的右半部分包括将主干网络Darknet-53的输出进行生成特征金字塔。具体做法为首先将13×13×1024的特征层进行上采样变为26×26×256，再与26×26×512的特征层进行堆叠，其结果为26×26×768大小的特征；同理，大小为52×52×256的特征层与下一层网络堆叠后的结果为52×52×384。<br>     对于这三个堆叠后的结果，分别再进行5次卷积操作，最后接上一个3×3的卷积和1×1的卷积，用于输出预测结果，三个层对应的输出结果大小分别为13×13×255、26×26×255、52×52×255。<br>这里结合下图我们可以看到，前两个维度很明显代表了图像被分网格的行/列数，255是我们根据不同类型的数据集，在yolov3中得到的通道数channel</p><p><img src="https://img-blog.csdnimg.cn/20201124130409593.gif#pic_center" alt="在这里插入图片描述"></p><p>这里的每个输出的通道数都是 3x(80+5)，这是因为 YOLOv3 设定的是每个网格单元预测3个检测框，而且每个检测框需要有 (x, y, w, h, confidence) 五个基本参数，然后还要有80个类别的概率。<br>其中255 = (4+1+80)×3，4表示一个边界框对应的调整参数x, y, w, h，1表示置信度，比如我们用COCO数据集，80表示COCO数据集分为80个类，3表示特征图上的每一个点对应有3个anchor。</p><p>代码中的predict_transform函数获取了前级的输入，并进行处理。<br><img src="https://img-blog.csdnimg.cn/20201124130433634.gif#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201124130447497.gif#pic_center" alt="在这里插入图片描述"></p><p>在class darknet()的yolo模块代码后部分，对于每个yolo层的输出先用predict_transform()变成每行为一个anchor对应的预测值的形式(不看batch_size这个维度，x剩下的维度可以看成一个二维tensor)，这样3个yolo层的预测值按照每个方框对应的行的维度进行连接。得到了这张图处所有anchor的预测值，使后面的NMS等操作可以一次完成<br><img src="https://img-blog.csdnimg.cn/2020112413051535.gif#pic_center" alt="在这里插入图片描述"></p><p>这是由北工大模式识别二组共同创作！！！<br>转载请注明出处，谢谢！！<br>下一章（续2）会简单理解一下我最近研究损失函数所遇到的问题</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124125839974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;相比于之前的网络架构，Yolov3有两点提升：&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测③基于深度学习的检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A2%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:48:46.164Z</published>
    <updated>2020-11-24T05:58:51.582Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型<br><img src="https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。<br> <a id="more"></a><br>物体检测的两个步骤可以概括为：<br>步骤一：检测目标位置（生成矩形框）<br>步骤二：对目标物体进行分类<br>物体检测主流的算法框架大致分为one-stage与two-stage。two-stage算法代表有R-CNN系列，one-stage算法代表有Yolo系列。可以说，two-stage算法将步骤一与步骤二分开执行，输入图像先经过候选框生成网络（例如faster rcnn中的RPN网络），再经过分类网络；one-stage算法将步骤一与步骤二同时执行，输入图像只经过一个网络，生成的结果中同时包含位置与类别信息。two-stage与one-stage相比，精度高，但是计算量更大，所以运算较慢。</p><p>我们这里介绍的两种深度学习算法，都是one-stage算法。<br>基于回归方法的深度学习目标检测算法，他们一步到位，其基本步骤是: 给定一张图像, 通过设定合理的输出向量，使用回归的方式输出这个目标的边框和类别，一步到位。这种算法的优点是速度快，但是对于密集的小样本来说检测比较困难。比如 YOLO、SSD 等。</p><p>2.3.1 YOLO</p><p>2.3.1.1YOLO介绍<br>YOLO系列论文提出了一个新的物体检测的方法：You Only Look Once（YOLO）</p><p>YOLO 的核心思想就是把目标检测转变成一个回归问题，利用整张图作为网络的输入，仅仅经过一个神经网络，得到bounding box（边界框） 的位置及其所属的类别。</p><p>2.3.1.2 YOLOv1<br>论文：<a href="https://arxiv.org/pdf/1506.02640.pdf">https://arxiv.org/pdf/1506.02640.pdf</a><br>YOLOv1是最早版本的YOLO，以下从概念上简单介绍v1的原理<br>1）网络结构<br><img src="https://img-blog.csdnimg.cn/20201124121158625.gif#pic_center" alt="在这里插入图片描述"></p><p>输入：448<em>448</em>3的彩色图片<br>中间层：若干卷积层和最大池化层<br>全连接层：2个全连接层，用来预测位置和类别概率值</p><p>2）实现细节<br>分类器的输出是一个one-hot vector，而检测器的输出是一个框(Bounding Box)。框，该怎么表示？<br><img src="https://img-blog.csdnimg.cn/20201124121259121.gif#pic_center" alt="在这里插入图片描述"></p><p>bounding box<br>总的来说，S×S 个网格，每个网格要预测 B个bounding box ，还要预测 C 个类。网络输出就是一个 S × S × (5×B+C) 的张量。<br><img src="https://img-blog.csdnimg.cn/20201124121342496.gif#pic_center" alt="在这里插入图片描述"></p><p>在实际过程中，YOLOv1把一张图片划分为了7×7个网格，并且每个网格预测2个Box（Box1和Box2），20个类别。所以实际上，S=7，B=2，C=20。那么网络输出的shape也就是：7×7×30。</p><p>3）损失函数和优化器<br>神经网络结构确定之后，训练效果好坏，由Loss函数和优化器决定。Yolo v1使用普通的梯度下降法作为优化器。这里重点解读一下Yolo v1使用的Loss函数：<br><img src="https://img-blog.csdnimg.cn/20201124121743750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>损失是三部分：坐标预测损失、置信度预测损失、类别预测损失的加和</p><p>思考：对于x和y用差平方，而对于宽和高为什么进行开根处理？<br>——假设宽和高使用与x，y相同处理方式（直接差平方），当预测值与真实值图像偏移相同大小时，我们依此法计算出的误差是固定的，然而这与实际不符。实际对于图像框尺度大小不同的区域，相同偏移量下，小尺度图像效果是很差的，而较大尺度图像则效果不错。因此，此损失函数的设计细节是作者为使实验结果更加准确而设计的。<br>置信度预测损失：是正负样本求平方加和<br>类别预测损失：预测值减去真实值求平方</p><p>4）优缺点</p><p>优点：更快更准迁移能力强<br>缺点：对相互靠近的物体，以及很小的群体检测效果不好；对不常见的角度的目标泛化性能偏弱</p><p>升级版 YOLOv2<br>YOLOv2论文：<a href="https://arxiv.org/abs/1612.08242">https://arxiv.org/abs/1612.08242</a></p><p>为提高物体定位精准性和召回率，YOLO作者提出了 “YOLO9000: Better, Faster, Stronger” (Joseph Redmon, Ali Farhadi, CVPR 2017, Best Paper Honorable Mention)，相比YOLOv1 提高了训练图像的分辨率；引入了faster rcnn中anchor box的思想，对网络结构的设计进行了改进，输出层使用卷积层替代YOLO的全连接层，联合使用coco物体检测标注数据和imagenet物体分类标注数据训练物体检测模型。相比YOLO，YOLO9000在识别种类、精度、速度、和定位准确性等方面都有大大提升。</p><p>2.3.2 SSD<br>YOlO和SSD算法作为“一步到位”算法的代表，他们的主要区别就是yolo只利用了末端特征图的信息，而SSD利用了最后几层特征图的信息，所以，从理论上说，SSD算法较yolo（起码是yolov1）来说，精确度必然更高。</p><p>卷积神经网络各层特征信息主要有如下区别：<br>1、低层卷积可以捕捉到更多的细节信息，高层卷积可以捕捉到更多的抽象信息。<br>2、低层特性更关心“在哪里”，但分类准确度不高，而高层特性更关心“是什么”，但丢失了物体的位置信息。<br>——《Visualizing and Understanding Convolutional Networks》.（可视化理解卷积神经网络）2014</p><p>SSD正是利用不同尺度检测图片中不同大小和类别的目标物体，获得了很好的效果。<br><img src="https://img-blog.csdnimg.cn/20201124123639607.gif#pic_center" alt="在这里插入图片描述"></p><p>VGG-16网络</p><p>对于每个特征图来说，SSD引入初始框的概念。对于不同的特征图，SSD总的尺度设计原则就是：随着网络层数加深（特征图的变小），初始框的尺度线性增加。最小的初始框尺度为0.2，最大的初始框尺度为0.9。</p><p><img src="https://img-blog.csdnimg.cn/20201124123710547.gif#pic_center" alt="在这里插入图片描述"></p><p>3.实例解析<br>3.1YOLO实例说明<br>以下对YOLOv3进行介绍，代码部分来自<br>tf2.0yolov3——malin9402,yunyang1994<br><a href="https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3">https://github.com/malin9402/tf20/tree/master/4-Object_Detection/YOLOV3</a></p><p>pytorch :<br><a href="https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch">https://github.com/ayooshkathuria/YOLO_v3_tutorial_from_scratch</a></p><p>3.1.1网络结构<br>随着CNN的发展和大量研究人员的努力，产生了数篇影响深远的论文，解决了在实际应用的诸多问题。yolov3借鉴了许多论文和思路，完善了yolo网络架构。<br>本节从原理和代码上介绍yolov3的网络架构，并深入探讨其网络架构上的进步和优点。</p><p>yolov3用darknet53作为基础网络架构</p><p><img src="https://img-blog.csdnimg.cn/20201124124149243.gif#pic_center" alt="Darknet53"></p><p>命名来源于它有53层卷积层=  2 + 1<em>2+1 +2</em>2+1 +8<em>2+1 +8</em>2+1 +4*2+1</p><p>未完待续——下一篇我会说一下YOLOV3相对于之前的网络架构的提升，相比之下，算力要求也会随之提升，所以我们需要借助滴滴云DAI平台来跑我们的代码项目<br><img src="https://img-blog.csdnimg.cn/20201124125105797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="输入我的AI大师码：8996，享受⑨折优惠，让自己的算法检测像扫码一样简单"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，只需⑨折，便不用体验搭环境的痛苦，安心训练自己的模型&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124103816321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;在2012年之前，在目标检测领域还是以传统手工特征的检测算法为主，但是随着卷积神经网络(CNN)在2012年的兴起，目标检测开始了在深度学习下的暴力美学。在深度学习下，目标检测的效果比传统手工特征效果好太多。直至今日，基于深度学习的检测算法依然是目标检测的主流。&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java Docker</title>
    <link href="http://example.com/2020/11/18/Java%20Docker/"/>
    <id>http://example.com/2020/11/18/Java%20Docker/</id>
    <published>2020-11-18T03:28:11.845Z</published>
    <updated>2020-11-18T03:28:11.845Z</updated>
    
    <content type="html"><![CDATA[<p>对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：</p><a id="more"></a><ul><li>如果未配置合适的JVM堆和元数据区，直接内存等参数；java有可能试图使用超过容器限制的内存，最终被容器OOM kill ，或者自身发生OOM</li><li>错误的判断了可获取的CPU资源。如：Docker限制了CPU的核数，JVM就可能设置不合适的GC并行线程</li></ul><p>与虚拟机及其相似，但是也有不同，并不是虚拟化技术，而是一种轻量级的隔离技术。轻量级的开销必然也就在成了许多微妙差异。<br><strong>这就是所谓的Ergonomics机制，例如</strong>：<br>JVM 会大概根据检测到的内存大小，设置最初启动时的堆大小为系统内存的 1/64；并将堆最大值，设置为系统内存的 1/4。<br>而 JVM 检测到系统的 CPU 核数，则直接影响到了 Parallel GC 的并行线程数目和 JIT complier 线程数目，甚至是我们应用中 ForkJoinPool 等机制的并行等级。<br>这些默认参数，是根据通用场景选择的初始值。但是由于容器环境的差异，Java 的判断很可能是基于错误信息而做出的。这就类似，我以为我住的是整栋别墅，实际上却只有一个房间是给我住的。<br><img src="https://img-blog.csdnimg.cn/20201118112227927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>解决办法：升级到JDK8最新的更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于java来说，Docker毕竟是一个比较新的环境。例如，其内存、cpu等资源限制是通过CGroup实现的，早期的jdk版本并不能识别这些限制，进而会导致一些问题：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发包中的队列比较</title>
    <link href="http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%E8%BE%83/"/>
    <id>http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E7%9B%B8%E6%AF%94%E8%BE%83/</id>
    <published>2020-11-17T07:47:02.075Z</published>
    <updated>2020-11-17T07:47:02.075Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentLinkedQueue基于CAS的无锁技术，有着更大的吞吐量<br>而BlockingQueue是完全根据锁实现的。LinkedBlockingQueue不仅有着 notEmpty和notFull两种再入锁的条件变量，而且更加改进了锁操作的粒度，头尾操作用的不同的锁，比ArrayBlockingQueue吞吐量更大一点。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="comment">//好精美的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock held by take, poll,etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue for waiting takes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty =takeLock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lock held by put offer,etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putlock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait queue for waiting puts</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull =putlock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 与ArrayBlockingQueue中的实现有所不同，notEmpty、notFull都是同一个再入锁的条件变量，而LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     * 则改进了锁操作的粒度，头尾操作都使用不同的锁，所以其吞吐量会更好一些</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span>  E x;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count =<span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock =<span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count.get()==<span class="number">0</span>)&#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span>(c&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c == capacity)</span><br><span class="line">            signalNotfull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotfull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者消费者（并发）利用ArrayBlockingQueue来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXIT_MSG =<span class="string">&quot;good bye&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用较小的队列，以更好地在输出中展现其影响，并发队列使用</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当初我的消费者,生产者是依托于 wait 与notify()&amp;notifyall(),这个队列更高级</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);<span class="comment">//也算是一种继承类的语法</span></span><br><span class="line">        Producer producer =<span class="keyword">new</span> Producer(queue);</span><br><span class="line">        Consumer consumer =<span class="keyword">new</span> Consumer(queue);</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();<span class="comment">//将其包裹在线程中</span></span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;String&gt; q)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.queue =q;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//20个线程并发生产，在值为3（实际为四）的队列里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5L</span>);</span><br><span class="line">                    String msg =<span class="string">&quot;Message&quot;</span>+i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced new item&quot;</span>+msg);</span><br><span class="line">                    queue.put(msg);<span class="comment">//努力生产</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;time to say goodbye&quot;</span>);</span><br><span class="line">                queue.put(EXIT_MSG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; q )</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue=q;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span>&#123;</span><br><span class="line">                 String msg;</span><br><span class="line">                 <span class="keyword">while</span>(!EXIT_MSG.equalsIgnoreCase((msg=queue.take())))&#123;<span class="comment">//消费</span></span><br><span class="line">                     System.out.println(<span class="string">&quot;Consumed item&quot;</span> +msg);</span><br><span class="line">                     Thread.sleep(<span class="number">10L</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(<span class="string">&quot;Got exit message,bye!!!&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以 <strong>LinkedBlockingQueue、ArrayBlockingQueue 和 SynchronousQueue</strong> 为例，我们一起来分析一下，根据需求可以从很多方面考量：</p><ul><li>队列边界：ArrayBlockingQueue有明显限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定，而SynchronousQueue则压根没有缓存任何元素</li><li>空间利用：ArrayBlockingQueue比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段需要一段连续的空间，所以初始内存需求更大</li><li>吞吐量：LinkedBlockingQueue  &gt; ArrayBlockingQueue</li><li>稳定性：ArrayBlockingQueue</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;ConcurrentLinkedQueue基于CAS的无锁技术，有着更大的吞吐量&lt;br&gt;而BlockingQueue是完全根据锁实现的。LinkedBlockingQueue不仅有着 notEmpty和notFull两种再入锁的条件变量，而且更加改进了锁操作的粒度，头尾操作用的不同的锁，比ArrayBlockingQueue吞吐量更大一点。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发工具安全容器</title>
    <link href="http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%AD%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2020/11/17/%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%AD%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8/</id>
    <published>2020-11-17T03:41:40.835Z</published>
    <updated>2020-11-17T03:41:40.836Z</updated>
    
    <content type="html"><![CDATA[<p> 上一章讲的是同步结构<br>  这一章讲容器<img src="https://img-blog.csdnimg.cn/20201117111546192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><ul><li><p>ConcurrentHashMap:无序，获取元素与map放入元素都很快，常数级别。 </p><ul><li><p>ConcurrentSkipListMap:有序,大量数据频繁修改，通过层次结构提高访问速度，空间复杂度为（O（nlogn））<br><img src="https://img-blog.csdnimg.cn/20201117111334916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>CopyOnWriteArrayList：动态数组。原理就是：add,set,remove,都会拷贝原数组，修改后替换原来的数组，通过这种模式，来实现线程安全</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> BingfaBottle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//public class CopyOnWrite &#123;</span></span><br><span class="line"><span class="comment">//    public boolean add(E e)&#123;</span></span><br><span class="line"><span class="comment">//        synchronized (lock)&#123;</span></span><br><span class="line"><span class="comment">//            Object[] elements =getArray();</span></span><br><span class="line"><span class="comment">//            int len =elements.length;</span></span><br><span class="line"><span class="comment">//            //拷贝</span></span><br><span class="line"><span class="comment">//            Object[] newElements = Arrays.copyOf(elements,len+1);</span></span><br><span class="line"><span class="comment">//            newElements[len]=e;</span></span><br><span class="line"><span class="comment">//            //替换</span></span><br><span class="line"><span class="comment">//            setArray(newElements);</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    final void setArray(Object[] a)&#123;</span></span><br><span class="line"><span class="comment">//        array= a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt; 上一章讲的是同步结构&lt;br&gt;  这一章讲容器&lt;img src=&quot;https://img-blog.csdnimg.cn/20201117111546192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java并发工具类</title>
    <link href="http://example.com/2020/11/16/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2020/11/16/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-16T13:58:53.374Z</published>
    <updated>2020-11-16T13:58:53.376Z</updated>
    
    <content type="html"><![CDATA[<p>带你走进并发的世界<br>回顾：我们在IO中讲的用线程池，只是相对于几百访问量的并发，那些只是我们练习时的Demo，<br>我们通常所说的并发包就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类：</p><a id="more"></a><ul><li>提供了比synchronized更加高级的各种同步结构，包括CountDownLatch、CyclicBarrier、Semaphore等，可以更加丰富的多线程操作。</li></ul><ul><li>线程安全的容器 ConcurrentHashMap,无序，且MAP放入或者获取的速度更快；有序的ConcurrentSkipListMap,获取并不快，但是有助于增删查改；快照机制，动态数组CopyOnWriteArrayList</li><li>并发队列结构：BlockingQueue实现，如：ArrayBlockingQueue、SynchronousQueue或者针对场景的PriorityBlockingQueue</li><li>强大的Executor框架，可以创建不同类型的线程池，调度任务运行。不需要自己从头实现线程池和任务调度器</li></ul><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优秀的同步结构 CountDownLatch、CyclicBarrier、Semaphore</span></span><br><span class="line"><span class="comment"> * 线程安全的容器 ConcurrentHashMap,无序，且MAP放入或者获取的速度更快；有序的ConcurrentSkipListMap,获取并不快，但是有助于增删查改；快照机制，动态数组CopyOnWriteArrayList</span></span><br><span class="line"><span class="comment"> * 并发队列结构：BlockingQueue实现，如：ArrayBlockingQueue、SynchronousQueue或者针对场景的PriorityBlockingQueue</span></span><br><span class="line"><span class="comment"> * 强大的Executor框架，可以创建不同类型的线程池，调度任务运行。不需要自己从头实现线程池和任务调度器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsualSemaphoreSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Semaphore是经典信号量，它通过一定数量的允许（permit）的方式，达到限制通用资源访问的目的，有出租车空闲，防止</span></span><br><span class="line"><span class="comment">     * 拥挤，调度员允许一次只有五个访问，这个坐满下次访问再来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Action..GO!&quot;</span>);</span><br><span class="line">        Semaphore semaphore =<span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> SemaphoreWorker(semaphore));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreWorker</span>  <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *不能放入同一类里，这个就像调度员的角色</span></span><br><span class="line"><span class="comment">       * acquire的意思：可以将acquire操作视为是消费一个许可，而release操作是创建一个许可</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreWorker</span><span class="params">(Semaphore semaphore)</span></span>&#123;<span class="comment">//构造方法设定</span></span><br><span class="line">        <span class="keyword">this</span>.semaphore =semaphore;<span class="comment">//this自引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;is waiting for a permit!&quot;</span>);</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            log(<span class="string">&quot;acquired a permit&quot;</span>);</span><br><span class="line">            log(<span class="string">&quot;executed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            log(<span class="string">&quot;released a permit&quot;</span>);</span><br><span class="line">            semaphore.release();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="comment">//只是调用了两个方法，这就是利用semaphore,里面原理依旧是黑匣子</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name==<span class="keyword">null</span>)&#123;</span><br><span class="line">            name=Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(name+<span class="string">&quot; &quot;</span>+msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * countDown/await控制，调用await的线程阻塞等待countDown足够的次数，不管是一个或多个线程中，只要次数足够即可</span></span><br><span class="line"><span class="comment">     * 相对于semaphore, countDown不能重用,如果要支持更多人排队，就不能依赖一个countDownLatch</span></span><br><span class="line"><span class="comment">     * 就相当于我有限量的出租车，而你有无限量的人，等我拉完一趟你们的去另个地点再坐</span></span><br><span class="line"><span class="comment">     * 而semaphore相当于我有限量的指令，你们用完一个给我放一个，应该也不会超出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch latch =<span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//将线程创建在同步器之中</span></span><br><span class="line">            Thread t =<span class="keyword">new</span> Thread(<span class="keyword">new</span> FirstBatchWorker(latch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Thread t =<span class="keyword">new</span> Thread(<span class="keyword">new</span> SecondBatchWorker(latch));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里只是出于演示目的</span></span><br><span class="line">        <span class="keyword">while</span>(latch.getCount()!=<span class="number">1</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;wait for first batch finish&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstBatchWorker</span><span class="params">(CountDownLatch latch)</span></span>&#123;<span class="comment">//每次都有一个构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.latch =latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;First batch executed&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondBatchWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondBatchWorker</span><span class="params">(CountDownLatch latch)</span> </span>&#123;<span class="comment">//每次都有一个构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//其实就相当于数着await次数一样，满足countDown足够的次数，然后second才能运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;Second batch executed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Bingfa;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierSample</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 线程并行时候的协调，从逻辑上讲，五个工作线程就像代表了五个可以就绪的空车</span></span><br><span class="line"><span class="comment">     * 而不是五个待坐的乘客</span></span><br><span class="line"><span class="comment">     * 一种辅助性的同步结构，允许多个线程等待到达某个屏障，支持更多排队人数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//到达5就是到达一个屏障</span></span><br><span class="line">        CyclicBarrier barrier =<span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Action...GO again!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;<span class="comment">//创建五个线程</span></span><br><span class="line">            Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> CyclicWorker(barrier));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CyclicWorker</span><span class="params">(CyclicBarrier barrier)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">            <span class="keyword">this</span>.barrier =barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Executed&quot;</span>);</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理解！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;带你走进并发的世界&lt;br&gt;回顾：我们在IO中讲的用线程池，只是相对于几百访问量的并发，那些只是我们练习时的Demo，&lt;br&gt;我们通常所说的并发包就是java.util.concurrent及其子包，集中了Java并发的各种基础工具类：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之死锁定位，修复，预防</title>
    <link href="http://example.com/2020/11/16/%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F%E5%8F%8A%E5%85%B6%E9%A2%84%E9%98%B2%EF%BC%9F/"/>
    <id>http://example.com/2020/11/16/%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%EF%BC%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F%E5%8F%8A%E5%85%B6%E9%A2%84%E9%98%B2%EF%BC%9F/</id>
    <published>2020-11-16T06:07:05.547Z</published>
    <updated>2020-11-16T06:07:05.547Z</updated>
    
    <content type="html"><![CDATA[<p>模拟定位问题，就选取常见的jstack,可以使用jps或者系统的ps命令、任务管理器等工具，确定进程ID<br>其次，调用jstack获取线程栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;JAVA_HOME&#125;\bin\jstack your_pid</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201116105056333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>仔细看，有一个线程掌握的一个锁恰好是下一个线程需要的锁</p><p>具体步骤是：<br>区分线程状态—&gt;查看等待目标—&gt;对比monitor等持有状态<br>所以,<strong>理解线程基本状态和并发相关元素</strong>是定位问题的关键，然后调用栈结构，可以找到问题</p><p><strong>如果我们开发自己的管理工具，遇到死锁，可以用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用javaAPI：ThreadMXBean</strong>,直接提供了findDeadlockedThreads()方法用于定位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadInfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ThreadMXBean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindDeadLocked</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();<span class="comment">//容器</span></span><br><span class="line">        Runnable dlCheck = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span>[] threadIds = mbean.findDeadlockedThreads();</span><br><span class="line">                <span class="keyword">if</span> (threadIds != <span class="keyword">null</span>) &#123;<span class="comment">//检查所有线程</span></span><br><span class="line">                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Detected deadlock threads&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span>(ThreadInfo threadInfo:threadInfos)&#123;</span><br><span class="line">                        System.out.println(threadInfo.getThreadName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//并发包中的方法</span></span><br><span class="line">        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//稍等5秒，然后每10秒进行一次死锁扫描</span></span><br><span class="line">        scheduler.scheduleAtFixedRate(dlCheck,<span class="number">5L</span>,<span class="number">10L</span>, TimeUnit.SECONDS);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>预防死锁<br>发生死锁的原因主要有三点：<br>1.互斥条件，类似于java中的Monitor都是独占的，要不是我用，要不是你用<br>2.互斥条件长期持有，在使用结束之前，自己不会释放，也不能被其他线程抢占<br>3.循环依赖关系，两个或者多个个体之间出现了锁的链条环                                                                                                                                                                          第一种方法：尽量避免使用多个锁，嵌套的synchronized或者lock非常容易出问题<br>设计时，既要支持阻塞模式，又要支持非阻塞模式就很容易出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread HttpClient-6-SelectorManager</span></span><br><span class="line">readlock.lock();</span><br><span class="line">writelock.lock();</span><br><span class="line"><span class="comment">//持有readlock/writelock，调用close()需要获得closelock</span></span><br><span class="line">close();</span><br><span class="line"><span class="comment">//Thread HttpClient-6-Worker-2持有closelock</span></span><br><span class="line">implCloseSelectableChannel();<span class="comment">//向获得readlock</span></span><br></pre></td></tr></table></figure><p>进入死锁！！<br>所以不能赋予代码太多的职责</p><p>第二种方法：<br>尽量设计好锁的顺序<br>反例：<br><img src="https://img-blog.csdnimg.cn/20201116135730648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201116135740146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>时序问题下，可能造成死锁</p><p>第三个方法：<br>使用带超时的方法，为程序带来更多可控性<br>Object.wait(…)<br>第四个方法：<br>FindBugs来尝试使用固定的模式寻找死锁定位，但是现在仍有多欠缺。所以Java官方文档提供了相应JVM参数和基本原则。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模拟定位问题，就选取常见的jstack,可以使用jps或者系统的ps命令、任务管理器等工具，确定进程ID&lt;br&gt;其次，调用jstack获取线程栈：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$&amp;#123;JAVA_HOME&amp;#125;\bin\jstack your_pid&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之ReentrantLock锁的用法，特性，注意事项</title>
    <link href="http://example.com/2020/11/16/ReentrantLock%E9%94%81%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2020/11/16/ReentrantLock%E9%94%81%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E7%89%B9%E6%80%A7%EF%BC%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-11-16T04:29:20.119Z</published>
    <updated>2020-11-16T04:29:20.119Z</updated>
    
    <content type="html"><![CDATA[<p>ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。</p><p>1 用法比较<br>Lock使用起来比较灵活，但是必须有释放锁的配合动作<br>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁<br>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</p><a id="more"></a><p>2 特性比较<br>ReentrantLock的优势体现在：<br>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁<br>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放<br>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</p><p>3 注意事项<br>在使用ReentrantLock类的时，一定要注意三点：<br>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放<br>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。<br>ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。&lt;/p&gt;
&lt;p&gt;1 用法比较&lt;br&gt;Lock使用起来比较灵活，但是必须有释放锁的配合动作&lt;br&gt;Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁&lt;br&gt;Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之死锁</title>
    <link href="http://example.com/2020/11/15/%E6%AD%BB%E9%94%81%EF%BC%9F/"/>
    <id>http://example.com/2020/11/15/%E6%AD%BB%E9%94%81%EF%BC%9F/</id>
    <published>2020-11-15T09:24:14.627Z</published>
    <updated>2020-11-15T09:24:14.627Z</updated>
    
    <content type="html"><![CDATA[<p><strong>死锁？</strong></p><p>死锁是一种特定的程序状态，由于循环依赖导致彼此一直处在等待之中，没有任何个体可以继续前进。死锁不仅仅发生在线程之间，存在资源独占的进程之间同样也可能发生死锁。通常来说，两个或者多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞的状态</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201115165637396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>死锁最常见的方式就是利用jstack等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。<br>如果发生了死锁，绝大多数情况是无法在线解决的，只能重启、修正程序本身问题。</p><p>第一、写一个死锁的程序，基础的线程编程一遍考察</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockSample</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个就是实例化的线程子类，定义了run()方法</span></span><br><span class="line"><span class="comment">     * 接下来我们的操作就是在mian方法中创建两个线程来实现争夺两个资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockSample</span><span class="params">(String name,String first,String second)</span></span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.first=first;</span><br><span class="line">        <span class="keyword">this</span>.second=second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (first)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;obtained:&quot;</span>+first);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (second)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.getName()+<span class="string">&quot;obtained:&quot;</span>+second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String lockA =<span class="string">&quot;lockA&quot;</span>;</span><br><span class="line">        String lockB =<span class="string">&quot;lockB&quot;</span>;</span><br><span class="line">        DeadLockSample  t1 =<span class="keyword">new</span> DeadLockSample(<span class="string">&quot;Thread1&quot;</span>,lockA,lockB);<span class="comment">//传参，实参</span></span><br><span class="line">        DeadLockSample  t2 =<span class="keyword">new</span> DeadLockSample(<span class="string">&quot;Thread2&quot;</span>,lockB,lockA);<span class="comment">//传参，实参</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();<span class="comment">//记得添加异常处理</span></span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果<br><img src="https://img-blog.csdnimg.cn/20201115172247897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>执行并不能结束！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;死锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;死锁是一种特定的程序状态，由于循环依赖导致彼此一直处在等待之中，没有任何个体可以继续前进。死锁不仅仅发生在线程之间，存在资源独占的进程之间同样也可能发生死锁。通常来说，两个或者多个线程之间，由于相互持有对方需要的锁，而永久处于阻塞的状态&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java线程两次调用start()会出现什么？？</title>
    <link href="http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/"/>
    <id>http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/</id>
    <published>2020-11-15T07:53:24.676Z</published>
    <updated>2020-11-15T07:53:24.676Z</updated>
    
    <content type="html"><![CDATA[<p>Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException<br>这是一种运行时异常，多次调用start被认为是编程错误</p><a id="more"></a><p>在线程生命周期的不同状态，已被明确定义在公布内部类型java.lang.Thread.State,分别是：<br>1.新建（new），表示被创建出来还没真正启动的状态，java内部状态<br>2.就绪、（RUNNABLE）表示该线程已经在JVM中执行，可能正在运行，等待系统CPU给其片段，在就绪队列里面排队<br>3.阻塞（Blocked），与前面的同步非常相关，阻塞表示线程在等待Monitor lock.线程视图通过synchronized去获取某个锁，却发现其他线程已经独占了，那么当前线程就会处于阻塞状态<br>4.等待（waiting）表示等待其他线程采取某些操作。类似于以前打过代码的生产者消费者模式，发现生产者线程还没被生产出来，消费者就会等待，生产者线程准备任务数据，通过类似notify等动作，通知消费线程可以继续工作。<br>Thread.join（）也会令线程进入等待状态<br>5.计时等待（TIMED_WAIT）与等待状态类似，但调用的是存在超时条件的方法，比如wait或者join等方法的指定超时版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>6.终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行。</p><p><strong>线程是什么？</strong><br>一个进程可以分为多个线程，作为任务的真正运作着，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）,但是会和其他线程共享文件描述符，虚拟地址空间</p><p>在具体实现中，线程还分为内核线程，用户线程，java线程实现其实与虚拟机相关，现在的模型是一对一映射到操作系统内核线程。<br>源码中，基本操作逻辑是以JNI形式调用的本地代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setPriority0</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable task =()-&gt;&#123;System.out.ptintln(<span class="string">&quot;Hello world&quot;</span>);&#125;;</span><br><span class="line">Thread myThread =<span class="keyword">new</span> Thread(task);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread.join();<span class="comment">//等待结束</span></span><br></pre></td></tr></table></figure><p>实现一个Runnable,将代码逻辑放入Runnable中，然后构建Thread并启动（start）</p><p>Runnable的好处就是，不会受“java不能多继承”的限制，重用代码实现，需要重复执行相应逻辑时效率明显</p><p>另外还能更好地与并发库中的Executor之类框架结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future future =Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">.submit(task)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure><p>守护线程（Daemon Thread）：应用需要一个长期驻留的服务程序，但不希望影响应用退出，如果jvm发现只有守护线程存在时，将结束进程。注：必须在线程启动之前设置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread =<span class="keyword">new</span> Thread();</span><br><span class="line">deamonThread.setDeamon(<span class="keyword">true</span>);</span><br><span class="line">deamonThread.start();</span><br></pre></td></tr></table></figure><p>在多核CPU的系统中，线程等待存在一种可能，就是没有任何线程广播或者信号，线程就会被唤醒，处理不当就会产生并发问题<br>//推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isCondition())&#123;</span><br><span class="line">waitForAConfition(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慎用ThreadLocal,保存线程私有信息的机制，可以方便的在一个线程关联的不同业务之间传递信息，比如事务ID，Cookie等上下文信息，数据存储于ThreadLocalMap，其内部条目是弱引用<br>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt;</span>&#123;</span><br><span class="line">   Object value;</span><br><span class="line">   Entry(ThreadLocal&lt;?&gt; k,Object v)&#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value =v;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key为null时，该条目变为了废弃条目，value回收需要<br>“set 、remove、rehash”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i];; …) &#123;</span><br><span class="line">      <span class="comment">//…</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 替换废弃条目</span></span><br><span class="line">          replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">//  扫描并清理发现的废弃条目，并检查容量是否超限</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">      rehash();<span class="comment">// 清理废弃条目，如果仍然超限，则扩容（加倍）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal虽然是弱引用，但是垃圾处理机制对其例外，所以其回收应该依赖于显式的触发，否则就要等待线程结束，所以一定要提防OOM，<strong>自己创建的应用自己负责remove</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException&lt;br&gt;这是一种运行时异常，多次调用start被认为是编程错误&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之IO方式，及NIO简介</title>
    <link href="http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-14T14:01:15.445Z</published>
    <updated>2020-11-14T14:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<p>可以构建高扩展性应用的能力<br>JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式<br>可以进行简单区分<br>1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等<br>交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序<br>java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。<br>java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。<br>2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式<br>3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作</p><a id="more"></a><p>在面试中，考察的点涉及方方面面</p><ul><li>基础API功能和设计，InputStream/OutputStream和Reader/writer的关系和区别（BIO）</li><li>NIO AIO的基本组成</li><li>给定场景，分别用不同模型实现，分析BIO、NIO等模式的设计和实现原理</li><li>NIO提供的高性能数据操作方式是基于什么原理，如何使用？</li><li>或者，从开发者的角度来看，你觉得NIO自身实现存在哪些问题？有什么改进的想法吗？</li></ul><p>区分同步和异步？<br>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步，而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</p><p>区分阻塞和非阻塞？<br>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当前条件就绪才能继续。比如：ServerSocket新连接建立完毕，或数据读取，写入操作完成，而 非阻塞 则是不管IO操作是否结束，直接返回，相应操作则在后台处理。</p><p>我们不能说同步和阻塞就是低效，分情况而定。</p><p>对于java.io的总结：</p><ul><li>IO不仅仅是对文件的操作，网络编程中，比如Socket通信，都是典型的IO 操作目标</li><li>输入流，输出流是用于读取或写入字节的，操作图片文件</li><li>Reader/Writer则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，相当于构建了应用逻辑和原始数据之间的桥梁</li><li>BufferdOutputStream等缓冲区的实现，可以避免频繁的磁盘读写，进而提高IO处理效率，这种设计利用了缓冲区，将批量数据进行一次操作，使用中不能忘了flush</li><li>很多IO工具类都实现了Closeable接口，因为需要进行资源的释放。比如：打开FilelnputStream，它就会获取相应的文件描述符（FileDescriptor）,需要try-with-resources、try-finally等机制保证FilelnputStream被明确关闭，进而相应文件描述也会失效，否则将导致资源无法被释放</li></ul><p>JAVA NIO</p><p>NIO的组成部分：<br>1.Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现<br>2.Channel,文件描述符，是NIO中被用来支持批量式IO操作的一种抽象。file 、Socket ，被认为是比较高层次的抽象，而 channel则是更加操作系统底层的一种抽象。我们可以通过Socket获取Channel。<br>4.Selector,是NIO实现多复用的基础，他提供了一种高效的机制，可以检测到注册在Selector的多个Channel中，是否有Channel处于就绪状态，进而实现单线程对多CHANNNEL的高效管理</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以构建高扩展性应用的能力&lt;br&gt;JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式&lt;br&gt;可以进行简单区分&lt;br&gt;1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等&lt;br&gt;交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序&lt;br&gt;java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。&lt;br&gt;java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。&lt;br&gt;2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式&lt;br&gt;3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
