<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-15T07:53:24.676Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日深耕，勤练不缀之java线程两次调用start()会出现什么？？</title>
    <link href="http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/"/>
    <id>http://example.com/2020/11/15/java%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8start()%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E7%8A%B6%E5%86%B5%EF%BC%9F/</id>
    <published>2020-11-15T07:53:24.676Z</published>
    <updated>2020-11-15T07:53:24.676Z</updated>
    
    <content type="html"><![CDATA[<p>Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException<br>这是一种运行时异常，多次调用start被认为是编程错误</p><a id="more"></a><p>在线程生命周期的不同状态，已被明确定义在公布内部类型java.lang.Thread.State,分别是：<br>1.新建（new），表示被创建出来还没真正启动的状态，java内部状态<br>2.就绪、（RUNNABLE）表示该线程已经在JVM中执行，可能正在运行，等待系统CPU给其片段，在就绪队列里面排队<br>3.阻塞（Blocked），与前面的同步非常相关，阻塞表示线程在等待Monitor lock.线程视图通过synchronized去获取某个锁，却发现其他线程已经独占了，那么当前线程就会处于阻塞状态<br>4.等待（waiting）表示等待其他线程采取某些操作。类似于以前打过代码的生产者消费者模式，发现生产者线程还没被生产出来，消费者就会等待，生产者线程准备任务数据，通过类似notify等动作，通知消费线程可以继续工作。<br>Thread.join（）也会令线程进入等待状态<br>5.计时等待（TIMED_WAIT）与等待状态类似，但调用的是存在超时条件的方法，比如wait或者join等方法的指定超时版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>6.终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行。</p><p><strong>线程是什么？</strong><br>一个进程可以分为多个线程，作为任务的真正运作着，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）,但是会和其他线程共享文件描述符，虚拟地址空间</p><p>在具体实现中，线程还分为内核线程，用户线程，java线程实现其实与虚拟机相关，现在的模型是一对一映射到操作系统内核线程。<br>源码中，基本操作逻辑是以JNI形式调用的本地代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setPriority0</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable task =()-&gt;&#123;System.out.ptintln(<span class="string">&quot;Hello world&quot;</span>);&#125;;</span><br><span class="line">Thread myThread =<span class="keyword">new</span> Thread(task);</span><br><span class="line">myThread.start();</span><br><span class="line">myThread.join();<span class="comment">//等待结束</span></span><br></pre></td></tr></table></figure><p>实现一个Runnable,将代码逻辑放入Runnable中，然后构建Thread并启动（start）</p><p>Runnable的好处就是，不会受“java不能多继承”的限制，重用代码实现，需要重复执行相应逻辑时效率明显</p><p>另外还能更好地与并发库中的Executor之类框架结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future future =Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">.submit(task)</span><br><span class="line">.get();</span><br></pre></td></tr></table></figure><p>守护线程（Daemon Thread）：应用需要一个长期驻留的服务程序，但不希望影响应用退出，如果jvm发现只有守护线程存在时，将结束进程。注：必须在线程启动之前设置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread daemonThread =<span class="keyword">new</span> Thread();</span><br><span class="line">deamonThread.setDeamon(<span class="keyword">true</span>);</span><br><span class="line">deamonThread.start();</span><br></pre></td></tr></table></figure><p>在多核CPU的系统中，线程等待存在一种可能，就是没有任何线程广播或者信号，线程就会被唤醒，处理不当就会产生并发问题<br>//推荐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (isCondition())&#123;</span><br><span class="line">waitForAConfition(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慎用ThreadLocal,保存线程私有信息的机制，可以方便的在一个线程关联的不同业务之间传递信息，比如事务ID，Cookie等上下文信息，数据存储于ThreadLocalMap，其内部条目是弱引用<br>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt;</span>&#123;</span><br><span class="line">   Object value;</span><br><span class="line">   Entry(ThreadLocal&lt;?&gt; k,Object v)&#123;</span><br><span class="line">    <span class="keyword">super</span>(k);</span><br><span class="line">    value =v;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key为null时，该条目变为了废弃条目，value回收需要<br>“set 、remove、rehash”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i];; …) &#123;</span><br><span class="line">      <span class="comment">//…</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 替换废弃条目</span></span><br><span class="line">          replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">//  扫描并清理发现的废弃条目，并检查容量是否超限</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">      rehash();<span class="comment">// 清理废弃条目，如果仍然超限，则扩容（加倍）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal虽然是弱引用，但是垃圾处理机制对其例外，所以其回收应该依赖于显式的触发，否则就要等待线程结束，所以一定要提防OOM，<strong>自己创建的应用自己负责remove</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java的线程是不允许启动两次的，第二次调用必然会抛出illegalThreadStateException&lt;br&gt;这是一种运行时异常，多次调用start被认为是编程错误&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之IO方式，及NIO简介</title>
    <link href="http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2020/11/14/IO%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%8ANIO%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-14T14:01:15.445Z</published>
    <updated>2020-11-14T14:01:15.445Z</updated>
    
    <content type="html"><![CDATA[<p>可以构建高扩展性应用的能力<br>JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式<br>可以进行简单区分<br>1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等<br>交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序<br>java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。<br>java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。<br>2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式<br>3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作</p><a id="more"></a><p>在面试中，考察的点涉及方方面面</p><ul><li>基础API功能和设计，InputStream/OutputStream和Reader/writer的关系和区别（BIO）</li><li>NIO AIO的基本组成</li><li>给定场景，分别用不同模型实现，分析BIO、NIO等模式的设计和实现原理</li><li>NIO提供的高性能数据操作方式是基于什么原理，如何使用？</li><li>或者，从开发者的角度来看，你觉得NIO自身实现存在哪些问题？有什么改进的想法吗？</li></ul><p>区分同步和异步？<br>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步，而异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</p><p>区分阻塞和非阻塞？<br>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当前条件就绪才能继续。比如：ServerSocket新连接建立完毕，或数据读取，写入操作完成，而 非阻塞 则是不管IO操作是否结束，直接返回，相应操作则在后台处理。</p><p>我们不能说同步和阻塞就是低效，分情况而定。</p><p>对于java.io的总结：</p><ul><li>IO不仅仅是对文件的操作，网络编程中，比如Socket通信，都是典型的IO 操作目标</li><li>输入流，输出流是用于读取或写入字节的，操作图片文件</li><li>Reader/Writer则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。本质上计算机操作的都是字节，不管是网络通信还是文件读取，相当于构建了应用逻辑和原始数据之间的桥梁</li><li>BufferdOutputStream等缓冲区的实现，可以避免频繁的磁盘读写，进而提高IO处理效率，这种设计利用了缓冲区，将批量数据进行一次操作，使用中不能忘了flush</li><li>很多IO工具类都实现了Closeable接口，因为需要进行资源的释放。比如：打开FilelnputStream，它就会获取相应的文件描述符（FileDescriptor）,需要try-with-resources、try-finally等机制保证FilelnputStream被明确关闭，进而相应文件描述也会失效，否则将导致资源无法被释放</li></ul><p>JAVA NIO</p><p>NIO的组成部分：<br>1.Buffer，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现<br>2.Channel,文件描述符，是NIO中被用来支持批量式IO操作的一种抽象。file 、Socket ，被认为是比较高层次的抽象，而 channel则是更加操作系统底层的一种抽象。我们可以通过Socket获取Channel。<br>4.Selector,是NIO实现多复用的基础，他提供了一种高效的机制，可以检测到注册在Selector的多个Channel中，是否有Channel处于就绪状态，进而实现单线程对多CHANNNEL的高效管理</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以构建高扩展性应用的能力&lt;br&gt;JAVA  IO 有很多种，基于不同的IO抽象模型和交互方式&lt;br&gt;可以进行简单区分&lt;br&gt;1.传统的java.io包（BIO），基于流模型实现，提供了我们最熟知的一些IO性能,如:File抽象，输入输出流等&lt;br&gt;交互方式是同步，堵塞的方式，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序&lt;br&gt;java.io包的好处是代码比较简单，直观，缺点是IO效率和扩展性存在局限，成为性能瓶颈。&lt;br&gt;java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库。&lt;br&gt;2.java1.4引入了NIO框架（java.io包），提供了Channel,Selector,Buffer等新的抽象，可以构建多路复用的、同步非阻塞IO程序，，提供了更接近操作系统底层的高性能数据操作方式&lt;br&gt;3.java7中，NIO有了进一步的改进，也就是NIO2，引入了异步非阻塞IO方式，也有很多人叫它AIO(Asynchronous IO)。异步IO操作基于事件和回调机制，可以理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之NIO要解决的问题</title>
    <link href="http://example.com/2020/11/14/NIO%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/14/NIO%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-14T13:57:28.665Z</published>
    <updated>2020-11-14T13:57:28.665Z</updated>
    
    <content type="html"><![CDATA[<p>NIO解决的问题<br>为什么需要NIO，为什么需要多路复用？<br>场景：我们需要实现一个服务器应用，简单要求能够同时服务多个客户端请求</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverSocket.getLocalPort();<span class="comment">//相当于一个平常的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            serverSocket =<span class="keyword">new</span> ServerSocket(<span class="number">0</span>);<span class="comment">//服务器端启动ServerSocket,端口0表示自动绑定一个空闲端口</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket =serverSocket.accept();<span class="comment">//客户端的请求，阻塞等待客户端连接</span></span><br><span class="line">                RequestHandler requestHandler =<span class="keyword">new</span>  RequestHandler(socket) ;</span><br><span class="line">                requestHandler.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocket !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        DemoServer server =<span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();<span class="comment">//服务器开启</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用Scoket模拟一个简单的客户端，只进行连接、读取、打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span>(Socket client =<span class="keyword">new</span> Socket(InetAddress.getLocalHost(),server.getPort()))&#123;</span><br><span class="line">            BufferedReader bufferedReader =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span>  <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        RequestHandler(Socket socket) &#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//重载</span></span><br><span class="line">            <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());) &#123;</span><br><span class="line">                out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">                out.flush();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程实现比较重量级，启动和销毁一个线程有明显开销，每个线程都有单独的线程栈结构 ，占用非常明显的内存，所以，每一个Client启动一个线程都有点浪费</p><p>所以，我们可以修正问题，引入线程池机制来避免浪费</p><p>通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是构建并发服务的典型方式</p><p><img src="https://img-blog.csdnimg.cn/20201113142701987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如果只有几百个连接的普通应用，这种模式往往可以工作很好。但是如果数量急剧上升，这种实现方式就无法很好工作，因为线程上下文切换开销会在高并发时变得很明显，这是同步阻塞方式的低扩展性劣势</p><p>NIO引用的多路复用机制，提供了另外一种思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoServerClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">/**NIO的组成1.Buffer   2.channel 多线程并发抽象概念  3.Selector筛选器</span></span><br><span class="line"><span class="comment">     * 同步非阻塞IO框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Selector selector =Selector.open();<span class="comment">//通过Selector.open()创建一个Selector,作为一个类似调度员的角色</span></span><br><span class="line">            <span class="comment">/**通过创建一个ServerSocketChannnel,并且向Selector注册，通过指定SelectionKey.OP_ACCEPT，</span></span><br><span class="line"><span class="comment">             * 告诉调度员，它关注的是新的连接请求</span></span><br><span class="line"><span class="comment">             * 为什么我们要明确配置非阻塞模式呢？因为在阻塞模式下，注册操作是不允许的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ServerSocketChannel serverSocket =ServerSocketChannel.open();)&#123;<span class="comment">//创建channel selector</span></span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(),<span class="number">8888</span>));<span class="comment">//创建连接端口,监听</span></span><br><span class="line">            serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册到Selector,并说明关注点</span></span><br><span class="line">            serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">/**Selector阻塞在select操作，当有Channel发生接入请求后，就会被唤醒</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                selector.select();<span class="comment">//阻塞等待就绪的Channel，这是关键点之一</span></span><br><span class="line">                Set &lt;SelectionKey&gt; selectionKeys =selector.selectedKeys();<span class="comment">//建一个selector的HashSet</span></span><br><span class="line">                Iterator &lt;SelectionKey&gt; iter =selectionKeys.iterator();<span class="comment">//迭代器迭代 selectionKey的Set</span></span><br><span class="line">                <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">                    SelectionKey key =iter.next();</span><br><span class="line">                    <span class="comment">//生产系统中一般会额外进行就绪状态检查</span></span><br><span class="line">                    sayHelloWorld((ServerSocketChannel)key.channel());<span class="comment">//强制类型转换，找出那个channel</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在此方法中，通过ScoketChannel和Buffer进行数据操作，发送一段字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">(ServerSocketChannel server)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SocketChannel client =server.accept();)&#123;<span class="comment">//客户端只管发送请求就ok</span></span><br><span class="line">            client.write(Charset.defaultCharset().encode(<span class="string">&quot;helloworld!&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IO是同步阻塞模式，需要多线程实现多任务处理<br>NIO利用单线程轮询时间的机制，高效定位就绪的Channel,来决定做什么，仅仅select阶段是阻塞的，可以避免大量客户连接时，频繁切换线程带来的问题</p><p><img src="https://img-blog.csdnimg.cn/20201113152911340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>异步非阻塞AIO</strong><br>java7引入NIO2(AIO)时，又增添了一种额外的异步IO模式，利用事件和回调，处理Accept,Read等操作<br>AsychronousServerSocketChannel对应于上面例子的SeverSocketChannel;<br>AsychronousSocketChannel对应于SocketChannel<br>业务逻辑的关键点在于，通过指定的CompletionHandler回调接口，在accept/read/write等关键节点，通过事件机制调用，实现异步</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;NIO解决的问题&lt;br&gt;为什么需要NIO，为什么需要多路复用？&lt;br&gt;场景：我们需要实现一个服务器应用，简单要求能够同时服务多个客户端请求&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java设计模式</title>
    <link href="http://example.com/2020/11/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2020/11/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-14T13:38:30.186Z</published>
    <updated>2020-11-14T13:38:30.186Z</updated>
    
    <content type="html"><![CDATA[<p>java设计模式、</p><p>创建型设计模式：工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）</p><p>结构型模式：是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等</p><p>行为型模式：是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）</p><a id="more"></a><p><strong>谈谈你知道的设计模式？<br>手动实现单例模式<br>spring等框架使用哪些模式？</strong><br>刚刚学过io框架，我们知道了还有InputStream的抽象类<br>标准类库中提供了FileputStream、ByteArrayInputStream等各种不同的子类，这就是装饰器模式</p><p>装饰器模式：包装同类型实例，对目标对象的调用，往往会通过包装类覆盖过的方法，迂回调用被包装的实例。<br>例子：<br>BufferedInputStream经过包装，为输入流过程增加缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure><p>单例模式（创建型模式）<br>给别人提供一个别人没有的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式<br>造商品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProduct</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//产品类实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">IProduct</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">productMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;产品&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类实体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IProduct <span class="title">createProduct</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        IFactory factory = <span class="keyword">new</span> Factory();  </span><br><span class="line">        IProduct prodect = factory.createProduct();  </span><br><span class="line">        prodect.productMethod();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>代理模式<br>代理模式就是在一个我们已知的方法in use时，我们可以采用代理模式实现方法的扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源对象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//源对象实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;the original method!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Source source;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>)&#123;</span><br><span class="line">            source = <span class="keyword">new</span> Source ();</span><br><span class="line">        &#125; </span><br><span class="line">        source.method();  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>装饰器模式（结构性模式）<br>通过一个更加灵活的方式动态的为某一个对象添加一些额外的职责</p><p>被扩展的类接口–&gt;实现被扩展的类<br>|<br>创建实现了Shape接口的抽象装饰类<br>|<br>继承抽象接口进一步扩展该性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需被拓展的类的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需被拓展的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Shape: Rectangle&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实现了 Shape 接口的抽象装饰类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Shape decoratedShape;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展了 ShapeDecorator 类的实体装饰类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(decoratedShape);        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      decoratedShape.draw();           </span><br><span class="line">      setRedBorder(decoratedShape);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Border Color: Red&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者模式：（行为型模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> List&lt;Observer&gt; observers </span><br><span class="line">      = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">      observers.add(observer);      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建观察者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者实现类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println( <span class="string">&quot;Binary String: &quot;</span> </span><br><span class="line">      + Integer.toBinaryString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者实现类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.subject = subject;</span><br><span class="line">      <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println( <span class="string">&quot;Octal String: &quot;</span> </span><br><span class="line">     + Integer.toOctalString( subject.getState() ) ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变被观察者状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">      <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;First state change: 15&quot;</span>); </span><br><span class="line">      subject.setState(<span class="number">15</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Second state change: 10&quot;</span>);    </span><br><span class="line">      subject.setState(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;java设计模式、&lt;/p&gt;
&lt;p&gt;创建型设计模式：工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）&lt;/p&gt;
&lt;p&gt;结构型模式：是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等&lt;/p&gt;
&lt;p&gt;行为型模式：是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之接口和抽象类有什么不同？</title>
    <link href="http://example.com/2020/11/14/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/11/14/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-11-14T05:35:56.329Z</published>
    <updated>2020-11-14T05:35:56.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>接口和抽象类有什么不同?</strong><br>接口是对行为的抽象，里面1.静态方法2.抽象方法，达到成为API的目的。接口，不能实例化。不能含有任何非常量成员，任何filed都隐藏着public  static final.java标准类库里，有着很多定义的接口：java.util.List</p><p>抽象类是不能实例化的类，用abstract修饰，主要目的在于代码重用，没有太多意义上的<strong>行为严格规范</strong>，除了不能实例化外，与其他java类没有任何差别，可以有多个抽象方法，只是代码共同方法的抽象集合堆砌而已。<br>比如：collection框架中，很多通用部分被抽取为抽象类，java.util.AbstractList</p><p>实现用interface ，继承抽象接口（extends）</p><a id="more"></a><p>java可以实现多个接口<br>某些场景下，我们需要抽象出某些与具体实现，实例化无关的通用逻辑，但是形成抽象方法会陷入单继承的窘境。所以我们这时可以变通一下，形成工具接口类，实现它。java.utuil.collections就是这样</p><p>对于抽象类，我们可以在其中展现非抽象方法，其子类不会报错，只会扩展性能</p><p>有一类没有任何方法的接口，叫做Marker interface,为了声明某些东西，比如我们熟知的 Cloneable、Serializable</p><p>java8又增加了一类接口，那便是functional interface<br><a href="https://www.oreilly.com/content/java-8-functional-interfaces/">https://www.oreilly.com/content/java-8-functional-interfaces/</a></p><p>java8以后我们给接口添加一系列的default method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> <span class="keyword">extends</span> <span class="title">Iterable</span> </span>&#123; <span class="comment">/** * Returns a sequential Stream with this collection as its source * ... **/</span> <span class="function"><span class="keyword">default</span> Stream <span class="title">stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>); &#125; &#125;</span><br></pre></td></tr></table></figure><p>封装：<br>我们将一些内部逻辑封装起来，为了安全性和易用性，只释放接口出来，避免外部调用者接触到内部的细节<br>继承:<br>子类父类的关系，一种深耦合<br>多态：<br>重写和重载<br>重写是父子之间，方法名参数一致<br>实现方法不同<br>重载是方法名一致，参数和返回值类型不一致<br><strong>遵循原则</strong><br>S.O.L.I.D<br>single：某个类只能承担一种业务<br>开关原则（Open-Close, Open for extension, close for modification）：对扩展开放，对修改关闭<br>里式替换（Liskov Substitution）：继承关系抽象时，凡是能用父类和基类，都可以用其子类去替换<br>接口分离：进行类和接口设计时，对其实现类造成了两难，只有部分方法对其有意义，可以拆分成功能单一的多个接口，在未来修改接口时，不会对其他不相干的子类造成影响<br>依赖反转：<br>实体应该依赖于<strong>抽象</strong>而不是实现。也就是说高层次模块，不应该依赖于低层次模块，<strong>而是应该基于抽象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPCenter</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Map&lt;User.TYPE, ServiceProvider&gt; providers;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">serviceVIP</span><span class="params">(T extend User user） &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      providers.get(user.getType()</span>).<span class="title">service</span><span class="params">(user)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SlumDogVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span></span>&#123;</span><br><span class="line">     <span class="comment">// do somthing</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">RealVIPServiceProvider</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(T extend User user)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// do something</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;接口和抽象类有什么不同?&lt;/strong&gt;&lt;br&gt;接口是对行为的抽象，里面1.静态方法2.抽象方法，达到成为API的目的。接口，不能实例化。不能含有任何非常量成员，任何filed都隐藏着public  static final.java标准类库里，有着很多定义的接口：java.util.List&lt;/p&gt;
&lt;p&gt;抽象类是不能实例化的类，用abstract修饰，主要目的在于代码重用，没有太多意义上的&lt;strong&gt;行为严格规范&lt;/strong&gt;，除了不能实例化外，与其他java类没有任何差别，可以有多个抽象方法，只是代码共同方法的抽象集合堆砌而已。&lt;br&gt;比如：collection框架中，很多通用部分被抽取为抽象类，java.util.AbstractList&lt;/p&gt;
&lt;p&gt;实现用interface ，继承抽象接口（extends）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java拷贝文件(copy)及buffer的基础使用</title>
    <link href="http://example.com/2020/11/13/java%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/11/13/java%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</id>
    <published>2020-11-13T12:54:03.505Z</published>
    <updated>2020-11-13T12:54:03.506Z</updated>
    
    <content type="html"><![CDATA[<p>拷贝实现方式：<br>1.java.io类库，为源文件构建一个FileputStream读取，为目标文件构建FileOutputStream，完成写入工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">copyFileByStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByStream</span><span class="params">(File source,File dest)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is  = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">            OutputStream os = <span class="keyword">new</span>  FileOutputStream(dest);)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line">            <span class="keyword">while</span>((length =is.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用NIO实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.java.nio类库提供的transferTo或者transferFrom方法实现</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用NIO实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFileByChannel</span><span class="params">(File source,File dest)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileChannel sourceChannel=<span class="keyword">new</span> FileInputStream(source).getChannel();</span><br><span class="line">            FileChannel targetChannel =<span class="keyword">new</span> FileOutputStream(dest).getChannel();</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> count =sourceChannel.size();count&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                <span class="keyword">long</span> transferred =sourceChannel.transferTo(sourceChannel.position(),count,targetChannel);</span><br><span class="line">                sourceChannel.position(sourceChannel.position()+transferred);</span><br><span class="line">                count-=transferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>主要还是为了让你加深对java类库设计和实现的了解<br><strong>零copy</strong><br>值得注意的点：<br>1.不同的copy方式，底层机制有什么区别？<br>2.为什么零拷贝（zero-copy）可能有性能优势？<br>3.Buffer分类和使用<br>4.Direct Buffer对垃圾收集等方面的影响与实践选择</p><p>拷贝实现机制<br>当我们使用输入输出流的时候，实际上进行了多次上下文切换。<br>比如<strong>应用读取数据</strong>时，先在内核态将数据从磁盘读取到内核缓存，再切换到用户态将数据从内核缓存读取到用户缓存。<br><strong>写入数据时</strong>步骤相反</p><p><img src="https://img-blog.csdnimg.cn/20201113172155296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>transfer To的传输过程<br><img src="https://img-blog.csdnimg.cn/20201113172410498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>基于NIO transferTo的实现方式，在Linux和UNIX上，则会使用到零拷贝技术<br>数据传输并不需要用户态参与，省去了上下文切换和不必要的内拷过程<br>读取磁盘文件：进行Socket发送，享受这种机制带来的性能和扩展性提高</p><p>JAVA IO/NIO源码结构<br>第三种方式：java标准库提供了文件拷贝方法（java.nio.file.copy）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">copy</span><span class="params">(Path source, Path target, CopyOption... options)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(InputStream in, Path target, CopyOption... options)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">copy</span><span class="params">(Path source, OutputStream out)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>这个常见的copy并不是利用transferTo,而是本地技术实现的用户态拷贝（只是简单地用户态空间拷贝）</p><p>提高类似拷贝等IO操作的性能：</p><ul><li>使用缓存等机制，合理减少IO次数（tcp传输）</li><li>使用Transfer To机制，减少上下文切换和额外IO操作</li><li>尽量减少不必要的转换过程，比如编解码，对象序列化和发序列化。如：操作文本文件或者网络通信，如果过程不是需要文本信息，可以考虑不要将二进制信息转换成字符串，直接二进制传输</li></ul><p> <strong>掌握NIO Buffer</strong><br> Buffer 是NIO操作数据的基本工具，Java为每种原始数据类型提供相应的Buffer实现（布尔除外）<br> <img src="https://img-blog.csdnimg.cn/20201113174956887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>capacity,它反映了Buffer到底有多大，数组的长度<br>position,要操作的数据起始位置<br>limit,相当于操作的限额。<br>读取操作时，limit设置为所容纳数据的上限<br>写入时，则会设置容量或者容量以下的可写限度。<br>Mark，记录上一次position的位置，默认是0，算是便利性考虑<br>io操作是一个闭环<br>实例：<br>1.我们创建一个ByteBuffer,准备写入数据<br>capacity当然就是缓冲区大小，而position是0<br>limit默认就是capacity的大小<br>2.当我们写入几个字节的数据时，position就会跟着动，但是不会超过limit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead =inChannel.read(buf);<span class="comment">//read into buffer</span></span><br><span class="line">buf.put(<span class="number">127</span>)</span><br></pre></td></tr></table></figure><p>3.我们现在想把写入的数据读出来，需要调用flip方法,将position设置为0，limit一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get(); </span><br></pre></td></tr></table></figure><p>4.如果还想从头再读一遍，将position置为0</p><ul><li><p>Direct Buffer<br>定义了一个isDirect()方法，返回当前Buffer是否是Direct类型<br>这是因为提供了堆内和堆外两种Buffer，我们以它的allocate或者allocateDirect方法直接创建</p></li><li><p>MappedByteBuffer:将文件按照指定大小直接映射为内存区域，当程序访问这个内存区域时将直接操作这块儿文件数据，省去内核空间向用户空间传输的损耗。我们可以用FileChannel.map创建MappedByteBuffer</p><p>在实际使用中，java会尽量对Direct Buffer仅做本地IO操作，对于很多大数据量的IO密集型操作，会到来很大的性能优势：</p></li><li><p>Direct Buffer生命周期内内存地址不会再发生改变，进而内核可以安全的对其进行访问，很多IO操作会很高效</p></li><li><p>减少了堆内对象存储的可能额外维护工作，所以访问效率可能有所提高</p><p>Direct Buffer 我们需要清楚它对内存和JVM参数的影响。<br>大多数GC中，都不会主动收集，就是基于幻象引用机制，本身并不是public类型，内部实现了一个Deallocator负责销毁的逻辑。对它的销毁往往要拖到full GC的时候，所以一定要小心OOM</p></li></ul><p>对于Direct Buffer的回收：</p><ul><li>显式的调用System.gc()来强制触发</li><li>重复使用Direct Buffer</li></ul><p>跟踪和诊断Direct Buffer内存占用</p><ul><li>jdk8以后我们可以用 Native Memory Tracking(NMT)特性来进行诊断，你可以在程序启东市加下列参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:NativeMemoryTracking=&#123;summary|ddetail&#125;</span><br></pre></td></tr></table></figure><p>注：激活NMT通常会导致JVM出现性能下降5%-10%</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;拷贝实现方式：&lt;br&gt;1.java.io类库，为源文件构建一个FileputStream读取，为目标文件构建FileOutputStream，完成写入工作&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.io.*;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copyFileByStream&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;copyFileByStream&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File source,File dest)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;(InputStream is  = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileInputStream(source);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            OutputStream os = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;  FileOutputStream(dest);)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] buffer =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((length =is.read(buffer))&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                os.write(buffer,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 利用NIO实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2.java.nio类库提供的transferTo或者transferFrom方法实现&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之项目比较大时，使用python ORM框架来操作MYSQL</title>
    <link href="http://example.com/2020/11/10/%E9%A1%B9%E7%9B%AE%E6%AF%94%E8%BE%83%E5%A4%A7%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMYSQL/"/>
    <id>http://example.com/2020/11/10/%E9%A1%B9%E7%9B%AE%E6%AF%94%E8%BE%83%E5%A4%A7%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8python%20ORM%E6%A1%86%E6%9E%B6%E6%9D%A5%E6%93%8D%E4%BD%9CMYSQL/</id>
    <published>2020-11-10T11:37:22.725Z</published>
    <updated>2020-11-10T11:57:51.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20201110155109230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>相当于持久化层<br>从数据库的涉及层面转化为面向对象的处理方式<br>三个ORM主流框架</p><a id="more"></a><p>1.Django<br>MTV框架模式<br><img src="https://img-blog.csdnimg.cn/2020111016031036.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2.SQLALchemy 提供了SQL工具包和ORM工具<br>同时支持ORM和原生SQL两种方式</p><p>3.peewee,轻量级的ORM框架<br>采用了Model,Field实例和Model实例来与数据库建立映射关系，从而实现面向对象的管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span>  create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化数据库连接，修改为你的数据库用户名和密码</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://root:xxx密码@localhost:3306/wucai&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer, Float</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"><span class="comment"># 定义Player对象:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ =<span class="string">&#x27;player&#x27;</span></span><br><span class="line">    <span class="comment"># 表的结构:</span></span><br><span class="line">    player_id = Column(Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    team_id = Column(Integer)</span><br><span class="line">    player_name = Column(String(<span class="number">255</span>))</span><br><span class="line">    height = Column(Float(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#对数据表进行增删改查</span></span><br><span class="line">    <span class="comment"># 创建DBSession类型:</span></span><br><span class="line">    DBSession = sessionmaker(bind=engine)</span><br><span class="line">    <span class="comment"># 创建session对象:</span></span><br><span class="line">    session = DBSession()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Player对象:</span></span><br><span class="line">    new_player=Player(team_id = <span class="number">1003</span>, player_name = <span class="string">&quot;约翰-科林斯&quot;</span>, height = <span class="number">2.08</span>)</span><br><span class="line">    <span class="comment"># 添加到session:</span></span><br><span class="line">    session.add(new_player)</span><br><span class="line">    <span class="comment"># 提交即保存到数据库:</span></span><br><span class="line">    session.commit()</span><br><span class="line">    <span class="comment"># 关闭session:</span></span><br><span class="line">    session.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有点难运行出来，快哭了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201110155109230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;相当于持久化层&lt;br&gt;从数据库的涉及层面转化为面向对象的处理方式&lt;br&gt;三个ORM主流框架&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之python控制SQL</title>
    <link href="http://example.com/2020/11/10/python%E6%8E%A7%E5%88%B6SQL/"/>
    <id>http://example.com/2020/11/10/python%E6%8E%A7%E5%88%B6SQL/</id>
    <published>2020-11-10T07:39:16.286Z</published>
    <updated>2020-11-10T11:57:56.174Z</updated>
    
    <content type="html"><![CDATA[<p>python的DB API的规范是什么？<br>python程序<br><img src="https://img-blog.csdnimg.cn/20201110104319568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>总步骤<br>1.引入API模块<br>2.与数据库建立连接<br>3.执行SQL语句<br>4.关闭数据库连接</p><a id="more"></a><p>首先安装 connector<br>在终端写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-connector</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110110228284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>大家有用mac的同学，直接在anaconda中下载myql-connector就可<br>不用pip</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line">db= mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    user =<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    passwd =<span class="string">&quot;&quot;</span>,</span><br><span class="line">    database =<span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"><span class="comment"># 执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"><span class="comment"># 获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&quot;MySQL版本: %s &quot;</span> % data)</span><br><span class="line"><span class="comment"># 关闭游标&amp;数据库连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110132328417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>通过指定 host、user、passwd 和 port 等参数来创建数据库连接，这些参数分别对应着数据库 IP 地址、用户名、密码和端口号；<br>使用 db.close() 关闭数据库连接；<br>使用 db.cursor() 创建游标，操作数据库中的数据；<br>使用 db.begin() 开启事务；<br>使用 db.commit() 和 db.rollback()，对事务进行提交以及回滚。<br>当我们通过cursor = db.cursor()创建游标后，就可以通过面向过程的编程方式对数据库中的数据进行操作：<br>使用cursor.execute(query_sql)，执行数据库查询；<br>使用cursor.fetchone()，读取数据集中的一条数据；<br>使用cursor.fetchall()，取出数据集中的所有行，返回一个元组 tuples 类型；<br>使用cursor.fetchmany(n)，取出数据集中的多条数据，同样返回一个元组 tuples；<br>使用cursor.rowcount，返回查询结果集中的行数。如果没有查询到数据或者还没有查询，则结果为 -1，否则会返回查询得到的数据行数；<br>使用cursor.close()，关闭游标。<br><strong>对数据表进行增删改查</strong><br>查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&#x27;SELECT player_id, player_name, height FROM player WHERE height&gt;=2.08&#x27;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">data = cursor.fetchall()</span><br><span class="line"><span class="keyword">for</span> each_player <span class="keyword">in</span> data:</span><br><span class="line">  print(each_player)</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改球员&quot;约翰-科林斯&quot;的数据</span></span><br><span class="line">sql =<span class="string">&#x27;UPDATE player SET height =%s where  player_name =%s&#x27;</span></span><br><span class="line">val=(<span class="number">2.09</span>,<span class="string">&quot;约翰—科林斯&quot;</span>) <span class="comment">#传值</span></span><br><span class="line">cursor.execute(sql,val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount,<span class="string">&quot;记录被修改&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110151948210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sql =<span class="string">&#x27;DELETE FROM player WHERE player_name = %s&#x27;</span></span><br><span class="line">val =(<span class="string">&quot;约翰—科林斯&quot;</span>,)</span><br><span class="line">cursor.execute(sql,val)</span><br><span class="line">db.commit()</span><br><span class="line">print(cursor.rowcount,<span class="string">&quot;记录删除成功。&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201110152407934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>对于上面的CRUD操作，有几点需要注意<br>1.打开数据连接后，如果不在使用，就关掉<br>2.在执行操作时，可能会产生异常，这时就需要try…except捕获异常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line">db= mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    user =<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    passwd =<span class="string">&quot;&quot;</span>,</span><br><span class="line">    database =<span class="string">&#x27;player&#x27;</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"><span class="comment"># 执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"><span class="comment"># 获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line">print(<span class="string">&quot;MySQL版本: %s &quot;</span> % data)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"> sql =<span class="string">&quot;INSERT INTO player (team_id,player_name,height)values (%s,%s,%s)&quot;</span></span><br><span class="line"> val =(<span class="number">1003</span>,<span class="string">&quot;约翰—科林斯&quot;</span>,<span class="number">2.08</span>)</span><br><span class="line"> cursor.execute(sql,val)</span><br><span class="line"> db.commit()</span><br><span class="line"> print(cursor.rowcount,<span class="string">&quot;插入成功。&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment">#打印异常信息</span></span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    <span class="comment">#回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 关闭游标&amp;数据库连接</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()</span><br></pre></td></tr></table></figure><p>那么，mysql-connector驱动的方式只是其中一种<br>我们也可以引入ORM框架，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象</p><p>如果针对少量的对象管理，那么我们完全可以用mysql-connector驱动的方式，引入一个框架学习成本太高，代码膨胀也很厉害<br><img src="https://img-blog.csdnimg.cn/20201110104937888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python的DB API的规范是什么？&lt;br&gt;python程序&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201110104319568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;总步骤&lt;br&gt;1.引入API模块&lt;br&gt;2.与数据库建立连接&lt;br&gt;3.执行SQL语句&lt;br&gt;4.关闭数据库连接&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之游标</title>
    <link href="http://example.com/2020/11/09/%E6%B8%B8%E6%A0%87/"/>
    <id>http://example.com/2020/11/09/%E6%B8%B8%E6%A0%87/</id>
    <published>2020-11-09T14:26:58.691Z</published>
    <updated>2020-11-09T14:26:58.691Z</updated>
    
    <content type="html"><![CDATA[<p>面向集合<br>集合思维更像是从整体的角度来考虑<br>然后把整个数据集不同的树形进行划分，形成不同的子集合<br><strong>游标</strong><br>  <a id="more"></a><br>定义游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement</span><br></pre></td></tr></table></figure><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure><p>从游标中获得数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name</span><br></pre></td></tr></table></figure><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure><p>释放游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DEALLOCATE</span> cousor_namec</span><br></pre></td></tr></table></figure><p>实战例子<br>我想用游标来扫描heros数据表中的数据行，然后累计最大生命值<br>创建一个存储过程 calc_hp_max,然后在存储过程中定义游标cur_gero,使用FETCH获取每一行的具体数值，然后赋给变量hp，再用变量hp_sum做累加求和，最后再输出hp_sum（对于工程师来说简单的累加而已）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`calc_hp_max`</span>()</span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">DECLARE</span> hp <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> hp_sum <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">DECLARE</span> cur_hero <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> hp_max <span class="keyword">from</span> heros;</span><br><span class="line"> </span><br><span class="line"> OPEN cur_hero;</span><br><span class="line"> read_loop:LOOP</span><br><span class="line"> FETCH cur_hero INTO hp;</span><br><span class="line"> <span class="keyword">SET</span> hp_sum =hp_sum + hp;</span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"> CLOSE cur_hero;</span><br><span class="line"> <span class="keyword">SELECT</span> hp_sum;</span><br><span class="line"> <span class="keyword">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当使用call calc_hp_max()时，会出现1329错误</p><p>我们判断游标溢出<br>当游标溢出时，我们可以制定一个continue事件，这个事件发生后会改变done的值，以此来判断是否溢出</p><p>所以我们要在循环中加上对done的判断，如果游标的循环已经结束，就需要跳出read_loop的循环，意思说只要done的值已经变为false,就可以跳出read_loop的循环了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> calc_hp_max()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201109192421572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201109192633232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我们遇到这种问题时，可以用游标来进行转换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`alter_attack_growth`</span>()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="comment">-- 创建接收游标的变量</span></span><br><span class="line">       <span class="keyword">DECLARE</span> temp_id <span class="built_in">INT</span>;  </span><br><span class="line">       <span class="keyword">DECLARE</span> temp_growth, temp_max, temp_start, temp_diff <span class="built_in">FLOAT</span>;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">-- 创建结束标志变量  </span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">-- 定义游标     </span></span><br><span class="line">       <span class="keyword">DECLARE</span> cur_hero <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>, attack_growth, attack_max, attack_start <span class="keyword">FROM</span> heros;</span><br><span class="line">       <span class="comment">-- 指定游标循环结束时的返回值  </span></span><br><span class="line">       <span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">SET</span> done = <span class="literal">true</span>;  </span><br><span class="line">       </span><br><span class="line">       OPEN cur_hero;  </span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       REPEAT</span><br><span class="line">                     IF NOT done THEN</span><br><span class="line">                            <span class="keyword">SET</span> temp_diff = temp_max - temp_start;</span><br><span class="line">                            IF temp_growth &lt; 5 THEN</span><br><span class="line">                                   IF temp_diff &gt; 200 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.1</span>;</span><br><span class="line">                                   ELSEIF temp_diff &gt;= 150 AND temp_diff &lt;=200 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.08</span>;</span><br><span class="line">                                   ELSEIF temp_diff &lt; 150 THEN</span><br><span class="line">                                          <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.07</span>;</span><br><span class="line">                                   <span class="keyword">END</span> <span class="keyword">IF</span>;                       </span><br><span class="line">                            ELSEIF temp_growth &gt;=5 AND temp_growth &lt;=10 THEN</span><br><span class="line">                                   <span class="keyword">SET</span> temp_growth = temp_growth * <span class="number">1.05</span>;</span><br><span class="line">                            <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">                            <span class="keyword">UPDATE</span> heros <span class="keyword">SET</span> attack_growth = <span class="keyword">ROUND</span>(temp_growth,<span class="number">3</span>) <span class="keyword">WHERE</span> <span class="keyword">id</span> = temp_id;</span><br><span class="line">                     <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">       FETCH cur_hero INTO temp_id, temp_growth, temp_max, temp_start;</span><br><span class="line">       UNTIL done = true <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line">       </span><br><span class="line">       CLOSE cur_hero;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> heros.id, heros.attack_growth</span><br><span class="line"><span class="keyword">FROM</span> heros  </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201109194723622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向集合&lt;br&gt;集合思维更像是从整体的角度来考虑&lt;br&gt;然后把整个数据集不同的树形进行划分，形成不同的子集合&lt;br&gt;&lt;strong&gt;游标&lt;/strong&gt;&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之深入讲解SQL事务隔离级别</title>
    <link href="http://example.com/2020/11/09/%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3SQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2020/11/09/%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3SQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2020-11-09T08:37:16.844Z</published>
    <updated>2020-11-09T08:37:16.845Z</updated>
    
    <content type="html"><![CDATA[<p>因为需要并发能力<br>所以我们不能用上一节的串行化的方式<br>来满足并发<br>需要降低数据库的隔离级别，来换取事务的并发能力<br><strong>三种异常问题</strong></p><a id="more"></a><p>脏读：事务还没提交，小李已经读到了数据<br>不可重复读：在事务操作中间时修改记录，另一个人两次的查询结果不一样<br>幻读：某人先查询了N条数据，正好同时某人提交了增加数据，下一次查询后产生了N+1条数据<br><strong>四种隔离级别</strong><br><img src="https://img-blog.csdnimg.cn/20201109161303678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>可重复读:就是相当于你写入数据的时候对于输出封闭<br>（查询时获得结果一致）<br>需要模拟脏读，不可重复读，幻读</p><p>MYSQL:默认是可重复读隔离级别<br><img src="https://img-blog.csdnimg.cn/20201109163133730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为需要并发能力&lt;br&gt;所以我们不能用上一节的串行化的方式&lt;br&gt;来满足并发&lt;br&gt;需要降低数据库的隔离级别，来换取事务的并发能力&lt;br&gt;&lt;strong&gt;三种异常问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之InnoDB事务处理</title>
    <link href="http://example.com/2020/11/09/InnoDB%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2020/11/09/InnoDB%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2020-11-09T07:04:55.420Z</published>
    <updated>2020-11-09T08:36:05.165Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB支持事务，取代MyISAM<br>事务英文名称：transaction<br><strong>进行一次处理的基本单元，要么完全执行，要么都不执行</strong><br>保证了数据处理的完整性，保证了数据库的数据一致性<br>高级处理数据方式<br>允许我们回滚还原（你买了商品，小卖铺老板忘记你付过款，让你重新付，如果这时候掌握了事务的特性，就不出产生这种问题了）</p><a id="more"></a><p><strong>事务特性</strong><br>ACID<br>A：原子性（Atomicity）<br>不可分割，进行数据处理的基本单位<br>C：一致性(Consistency)<br>数据库进行事务操作时，会有原来一直的状态变为另一种一致的状态，也就是说当事务提交后，回滚也不会破坏数据库的完整性约束<br>I：隔离性(Isolation)<br>每个事务都是彼此独立的，不会受到其他事务的执行影响<br>一个事务在提交之前，对其他事务是不可见的<br>D：持久性(Durability)<br>事务提交之后对数据的修改时持久性的，即使在系统出故障的情况下，数据修改依旧有效。当事务完成，这时可以通过日志，让系统恢复到最后一次成功的更新状态</p><p>原子性是基础，隔离性是手段，一致性是约束条件，持久性是我们的目的<br>补充：约束性条件：DDL全称：Data Definition Language<br>数据定义语言。定义了数据库的结构和数据表的结构<br>在DDL中，我们使用对应的命令：<br>CREATE DROP ALTER<br>不需要COMMIT,就可以完成执行任务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> nba;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> nba;</span><br><span class="line"><span class="comment">#对数据表进行定义</span></span><br><span class="line">CTEATE TABLE [table_name](字段名 数据类型，....)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> player(</span><br><span class="line">  player_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  player_name <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要注意逗号，和分号的位置<br>其实我们可以通过可视化工具将其创建出来</p><p><img src="https://img-blog.csdnimg.cn/20201109140442348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>一致性的七大约束<br>1.主键约束<br>主键唯一标识一条记录，不能重复，不能为空<br>一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合而成。我们将player_id 设置成了主键<br>2.外键约束<br>外键确保了表和表之间引用的完整性。一个表中的外键对应另一张表的主键。<br>外键可以是重复的，也可以为空<br>例如：球员比分表player_score的外键就是player_id,关联到player表中<br>3.字段约束<br>4.唯一性约束<br>我们已经设置了主键，但是有时也需要在其他字段中进行唯一性约束，比如给player_name设置唯一性约束，就保证了每个球员的名字不能相同<br>5.NOT NULL约束<br>6.DEFAULT<br>字段默认值约束，字段没有取值，就设置为默认值，DEFAULT  0.00<br>7.CHECK约束<br>我们可以实行检查约束。对身高height的数值进行CHECK约束，必须&gt;=0且&lt;3。<br><strong>设计数据表的原则</strong><br>三少一多<br>1.数据表的个数越少越好<br>2.数据表中的字段越少越好<br>3.数据表中联合主键的字段个数越少越好<br>4.使用主键和外键越多越好<br><strong>事务的控制</strong><br>事务常用控制语句<br>1.START TRANSCTION或者BEGIN：显式开启一个事务<br>2.COMMIT:提交事务。当提交事务后，对数据库的修改是永久性的<br>3.ROLLBACK或者ROLLBACK TO [SAVEPOINT],意为回滚事务<br>4.SAVEPOINT:在事务中创建保存点，方便后续对保存点进行回滚<br>5.SET TRANSACTION:设置事务的隔离级别</p><p>需要注意的是：隐式事务实际上在MYSQL中是自动提交</p><p>一个BEGIN 一个显式事务，回滚全覆盖</p><p>completion_type参数作用<br>0：默认情况，执行commit会提交事务，执行下一个显式事务时，还需要使用START TRANSACTION或者BEGIN来开启，不然就是隐式事务<br>1：开启一个链式任务，commit提交任务后，下一阶段会开启一个相同级别的事务<br>2：提交后，会自动与服务器断开</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;InnoDB支持事务，取代MyISAM&lt;br&gt;事务英文名称：transaction&lt;br&gt;&lt;strong&gt;进行一次处理的基本单元，要么完全执行，要么都不执行&lt;/strong&gt;&lt;br&gt;保证了数据处理的完整性，保证了数据库的数据一致性&lt;br&gt;高级处理数据方式&lt;br&gt;允许我们回滚还原（你买了商品，小卖铺老板忘记你付过款，让你重新付，如果这时候掌握了事务的特性，就不出产生这种问题了）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之SQL存储过程</title>
    <link href="http://example.com/2020/11/08/SQL%E4%B8%AD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2020/11/08/SQL%E4%B8%AD%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-08T09:08:35.663Z</published>
    <updated>2020-11-08T09:08:35.664Z</updated>
    
    <content type="html"><![CDATA[<p><strong>SQL存储过程</strong><br>本次应用数据库<a href="https://github.com/cystanford/sql_heros_data.git">https://github.com/cystanford/sql_heros_data.git</a><br>就是面向过程的编程语句<br> 里面加入了流语句<br> 有 begin end<br> 赋值 封装<br> <a id="more"></a><br> 但是因为可移植性太差的原因，所以国内很少有人指出存储过程<br> 开发维护，版本迭代太困难<br>更重要的是不符合高并发的数据库管理，高并发要减轻数据库的压力，采用分库分表的形式，而且对可扩展性要求很高。<br><strong>练习</strong><br>针对王者荣耀的英雄数据表heros表，请编写存储过程<br>get_sum_score,用来得到某一类型英雄的最大生命值的总和</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">`get_sum_score`</span>(</span><br><span class="line">  <span class="keyword">OUT</span> sum_max_hp <span class="built_in">FLOAT</span>,</span><br><span class="line">  <span class="keyword">IN</span> s <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">   )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">SUM</span>(hp_max)</span><br><span class="line"><span class="keyword">FROM</span> heros </span><br><span class="line">  <span class="keyword">WHERE</span> role_main =s</span><br><span class="line">  <span class="keyword">INTO</span> sum_max_hp;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201108165502261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>查询代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#记得加分号</span></span><br><span class="line"><span class="keyword">CALL</span> get_sum_score(@sum_max_hp,<span class="string">&#x27;战士&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> @sum_max_hp;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201108170655498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201108160702910.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;SQL存储过程&lt;/strong&gt;&lt;br&gt;本次应用数据库&lt;a href=&quot;https://github.com/cystanford/sql_heros_data.git&quot;&gt;https://github.com/cystanford/sql_heros_data.git&lt;/a&gt;&lt;br&gt;就是面向过程的编程语句&lt;br&gt; 里面加入了流语句&lt;br&gt; 有 begin end&lt;br&gt; 赋值 封装&lt;br&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之SQL对视图的查询及应用</title>
    <link href="http://example.com/2020/11/05/SQL%E5%AF%B9%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/05/SQL%E5%AF%B9%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-05T10:47:16.000Z</published>
    <updated>2020-11-05T10:50:07.283Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a></p><p>虚拟表，本身是不具备数据的<br>只是为了体现安全性，封装性，以及权限性</p><a id="more"></a><p>下面是一个图，很好的诠释了这个关系<br><img src="https://img-blog.csdnimg.cn/2020110517222349.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>帮助我们使用表的一部分，另一方面也可以针对不同的用户制定不同的查询视图。</p><p>视图作为一张虚拟表，帮我们封装了底层和数据表的接口。它相当于一张表或者多张表的数据结果集，编写视图后，我们可以不断重用他，这个和JAVA的接口很像</p><p>创建视图<br>CREATE VIEW </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure><p>只是添加了一句而已，就可以将查询语句封装</p><p>我们以NBA球员为例<br>我们要查询比NBA球员平均身高高的球员有哪些？并显示他们的球员ID和身高。我们给这个视图起名字player_above _avg_height</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height&gt;(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height) <span class="keyword">FROM</span> player)</span><br></pre></td></tr></table></figure><p>我们在navicat里创建了视图<br>然后我们再查询视图，得到的是同样的结果</p><p>接下来<strong>嵌套视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_above_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height&gt;(<span class="keyword">SELECT</span> <span class="keyword">avg</span>(height) <span class="keyword">FROM</span> player_above_avg_height)</span><br></pre></td></tr></table></figure><p>修改视图<br>ALTER VIEW<br>比如我们想更新视图player_above_avg_height</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> player_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id, player_name, height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt; (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height) <span class="keyword">from</span> player)</span><br></pre></td></tr></table></figure><p>删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure><p>利用视图完成复杂的连接</p><p>我们对player表和height_grades表进行连接，关联条件是球员的身高（在身高等级表中），然后把取得的查询结果放到视图player_height_grades</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_height_grades <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> a.height, a.player_id,a.player_name,b.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a <span class="keyword">JOIN</span> height_grades <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.height <span class="keyword">BETWEEN</span> b.height_lowest <span class="keyword">AND</span> b.height_highest</span><br></pre></td></tr></table></figure><p>采用ON连接，毫无疑问</p><p>而我们接下来用视图查询更简单、、</p><p><strong>利用视图对数据进行格式化</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_team <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(player_name,<span class="string">&#x27;(&#x27;</span>,team.team_name,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> player_team</span><br><span class="line"><span class="keyword">FROM</span> player</span><br></pre></td></tr></table></figure><p>正确的使用视图可以帮我们简化复杂的数据处理<br>我们以球员比赛成绩表为例<br>对应的是player_score表，这张表中一共19个字段，我们可以通过视图将其分析<br>比如：我们想要每个球员在每场比赛这种的二分球，三分球和罚球的得分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> game_player_score <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> game_id,player_id,(shoot_hits-shoot_3_hits)*<span class="number">2</span> <span class="keyword">AS</span> shoot_2_points,</span><br><span class="line">shoot_3_hits *<span class="number">3</span> <span class="keyword">AS</span> shoot_3_points,</span><br><span class="line">shoot_p_hits <span class="keyword">AS</span> shoot_p_points,score</span><br><span class="line"><span class="keyword">FROM</span> player_score</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201105184311556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>一个视图其实是SELECT语句的集合，执行时会提前编译好，可以反复使用。在底层执行顺序的时候和SELECT语句是一样：<br>1、FROM子句组装数据<br>2、WHERE子句进行条件筛选<br>3、GROUP BY分组<br>4、使用聚集函数进行计算；<br>5、HAVING筛选分组；<br>6、计算所有的表达式；<br>7、SELECT 的字段；<br>8、ORDER BY排序<br>9、LIMIT筛选</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虚拟表，本身是不具备数据的&lt;br&gt;只是为了体现安全性，封装性，以及权限性&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之sql99连接查询</title>
    <link href="http://example.com/2020/11/04/sql99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/04/sql99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-04T12:37:47.709Z</published>
    <updated>2020-11-04T12:40:48.423Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a></p><p><strong>交叉连接</strong>（92中的笛卡尔积）<br>在这里我们使用的是CROSS JOIN<br>代码如下</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure><p>三张表的交叉连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team_score</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104190150569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>自然连接</strong>（相当于92的等值连接）<br>在92中我们得自己判定两张表相同的属性是什么，而在99中利用 NATURAL JOIN 替代了 WHERE player.team_id=team.team_id<br>会帮你自动查询两张表中所有相同的字段，然后进行等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id ,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player </span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure><p><strong>ON连接</strong>（用来指定我们想要的连接条件）<br>进行等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player.team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team</span><br><span class="line"><span class="keyword">ON</span> player.team_id =team.team_id</span><br></pre></td></tr></table></figure><p>进行非等值连接<br>想要查询球员的身高等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.player_id,a.player_name,a.height,b.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a <span class="keyword">JOIN</span> height_grades <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.height <span class="keyword">BETWEEN</span> b.height_lowest <span class="keyword">AND</span> b.height_highest</span><br></pre></td></tr></table></figure><p><strong>using连接</strong><br>因为自然连接会自动查询相同字段进行连接，我们我们想指定相同字段连接时就得用using</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">USING</span>(team_id)</span><br></pre></td></tr></table></figure><p><strong>外连接</strong></p><p>左外链接<br>右外连接<br>全外连接在mysql中不支持</p><p>内连接：等值连接（自然连接，using连接，ON连接），非等值连接（ON连接）<br>外连接：会返回一个表中的所有记录，以及另一个表中匹配的行，左外连接，右外连接</p><p><strong>SQL99与SQL92的区别</strong><br>SQL92会在from后面放所有表<br>SQL99会放在join后面，每次连接一张表，可以多次使用join连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1和table2的连接条件</span><br><span class="line">        <span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2和table3的连接条件</span><br></pre></td></tr></table></figure><p>查询不同身高级别（对应height_grades）对应的球员数量（对应player表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(player.player_id),b.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> height_grades <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> player.height <span class="keyword">BETWEEN</span> b.height_lowest <span class="keyword">AND</span> b.height_highest</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> b.height_level</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104203514926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交叉连接&lt;/strong&gt;（92中的笛卡尔积）&lt;br&gt;在这里我们使用的是CROSS JOIN&lt;br&gt;代码如下&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之如何保证集合是线程安全的？</title>
    <link href="http://example.com/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F/"/>
    <id>http://example.com/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F/</id>
    <published>2020-11-04T09:55:45.658Z</published>
    <updated>2020-11-04T09:55:45.659Z</updated>
    
    <content type="html"><![CDATA[<p>java基本容器工具<br>前面两篇说的是Java容器类，大部分都不是线程安全的</p><p>如何保证集合是线程安全的、？<br>java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等内容容器，还提供了所谓的同步包装器（Synchronnized Wrapper),我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap）,但是他们都利用的粗粒度的同步方式，在高并发情况下，性能比较低下</p><p>更加普遍的选择是利用并发包提供的线程安全容器类，</p><a id="more"></a><p>它提供了：</p><ul><li>各种并发器，比如ConcurrentHashMap,CopyWriteArrayList.</li><li>各种线程安全队列（Queue/Deque）,如ArrayBlockingQueue、SynchronousQueue</li><li>各种有序容器的线程安全版本</li></ul><p>从简单的synchronized方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现<br>总体来说，并发包提供的容器通用场景，远远优于早期</p><p><strong>线程安全和并发的深入考察</strong><br>需要四个方面的解答<br><strong>1.理解基本的线程安全工具</strong><br><strong>2.理解传统集合框架并发编程中Map存在的问题，清楚简单的同步方式的不足</strong><br><strong>3.梳理并发包内，尤其是ConcurrentHashMap采取了哪些方法来提高并发的表现</strong><br><strong>4.最好能掌握ConcurrentHashMap自身的演进</strong></p><p>Hashtable本身比较低效，因为它的实现基本就是将put、get、size等各种方法加上”synchronized”.简单来说，这就导致了所有并发程序都要争一把锁，一个线程进行同步操作时，其他职能等待，导致CPU占用100%的问题。<br>那我们能不能用Collections提供的同步包装器来解决问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m; <span class="comment">//Backing Map</span></span><br><span class="line"> <span class="keyword">final</span> Object mutex; <span class="comment">//Object on which to synchronized</span></span><br><span class="line"> <span class="comment">//..</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们发现同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为Synchronized方法，但还是利用了”this”作为互斥的mutex,无真正意义上的改进。<br>所以，同步包装版本，还是很难适合在高并发场景中</p><p>2.ConcurrentHashMap分析<br>早期ConcurrentHashMap，其实现是基于：</p><ul><li>分离锁，也就是将内部进行分段，里面则是HashEntry的数组，和HashMap类似，哈希值相同的条目也是以链表形式存放</li><li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access,去直接完成部分操作，以优化性能<br><img src="https://img-blog.csdnimg.cn/20201104161404841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>在构造的时候，Segment的数量由所谓的concurrentcyLevel决定，默认是16，也可以在相应构造函数直接指定。注意，Java需要它是2的幂数值，如果输入时类似15这种非幂值，会被自动调整到16</p><p>老版的jdk7 会通过这种方式，下面是get代码，get需要保证的是可见性，所以并没有什么同步逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line"> Segment&lt;K,V&gt; s;</span><br><span class="line"> HashEntry&lt;K,V&gt;[]tab;</span><br><span class="line"> <span class="keyword">int</span>  h=hash(key.hashCode());</span><br><span class="line"> <span class="keyword">long</span> u =(((h&gt;&gt;&gt;segmentShift)&amp;segmentMask)&lt;&lt; SSHIFT)+SBASE;</span><br><span class="line"> <span class="comment">//以segment为单位，进行定位</span></span><br><span class="line"> <span class="comment">//利用Unsafe直接进行volatile access</span></span><br><span class="line"> <span class="keyword">if</span>((s=(Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(setments,u))!=<span class="keyword">null</span>&amp;&amp;(tab =s.table)!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="comment">//省略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>相对于put操作，通过二次哈希避免冲突<br>然后以Unsafe调用方式，直接获取相应的Segment,然后进行线程安全的put操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  NullPointerException</span><br><span class="line">    <span class="comment">//二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">  <span class="keyword">int</span> hash =hash(key.hashCode());</span><br><span class="line">  <span class="keyword">int</span> j =(hash &gt;&gt;&gt;segmentShift)&amp;segmentMask;</span><br><span class="line">  <span class="keyword">if</span>((s =(Segment&lt;K,V&gt;)UNSAFE.getObject(segments,(j &lt;&lt; SSHIFT) + SBASE))==<span class="keyword">null</span>)</span><br><span class="line">  s=ensureSegment(j);</span><br><span class="line">  <span class="keyword">return</span> s.put(key,hash,value,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心实现的逻辑是下面的内部方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// scanAndLockForPut会去查找是否有key相同Node</span></span><br><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span><br><span class="line">   HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">// 更新已有value...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 放置HashEntry到特定位置，如果超过阈值，进行rehash</span></span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在进行并发写操作时：<br>ConcurrentHashMap会获取再入锁，以保证数据一致性，Segment本身就是基于ReentrantLock的扩展实现，所以在并发修改期间，Segment是被锁定的</p><p>在最初阶段，进行重复性的扫描，以确定相应key值是否已经在数组里面，进而决定是更新还是放置。重复扫描，检测冲突是ConcurrentHashMap的常见技巧</p><p>扩容是单独给Segment扩容</p><p>Map的size方法同样需要关注，它的实现涉及分离锁的副作用，如果不进行同步，简单的计算所有Segment的总值，可能会因为并发put,导致结果不准确，但是直接锁定所有Segment进行计算，会很昂贵。<br>所以，ConcurrentHashMap的实现是通过重试机制<br>（RETRIES_BEFORE_LOCK,指定重试次数2），获取可靠值，如果没有监控到没有发生变化，直接返回。如果监控到变化，获取锁进行操作</p><p><strong>java8以后的ConcurrentHashMap</strong></p><p>总体结构上，它的内部结构与HashMap结构非常相似<br>桶（bucket）数组，然后内部也是一个个链表结构（bin）<br>具体看图<br><img src="https://img-blog.csdnimg.cn/20201104171559549.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>同步的力度更细致一些<br>内部仍有segment定义，为了保证序列化的兼容性，无作用<br>不使用segment,修改为lazy-load<br>数据存储利用volatile保证可见性(声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步)<br>使用了CAS操作，在特定场景进行无锁并发<br>AtomicLong满足大部分性能要求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;java基本容器工具&lt;br&gt;前面两篇说的是Java容器类，大部分都不是线程安全的&lt;/p&gt;
&lt;p&gt;如何保证集合是线程安全的、？&lt;br&gt;java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等内容容器，还提供了所谓的同步包装器（Synchronnized Wrapper),我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap）,但是他们都利用的粗粒度的同步方式，在高并发情况下，性能比较低下&lt;/p&gt;
&lt;p&gt;更加普遍的选择是利用并发包提供的线程安全容器类，&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之ArrayList,LinkedList,Vector的区别?</title>
    <link href="http://example.com/2020/11/04/ArrayList,LinkedList,Vector%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2020/11/04/ArrayList,LinkedList,Vector%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2020-11-04T06:17:04.945Z</published>
    <updated>2020-11-04T06:17:04.946Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList,LinkedList,Vector的区别?<br>高效的管理和操作数据</p><ul><li>三者都是集合框架里的list，即所谓的有序集合。</li><li>  按照位置进行定位，添加和删除的操作  </li><li>都提供<strong>迭代器</strong>以遍历其内容<a id="more"></a>Vector是Java早期的线程安全动态数组，通过我们不断地积累学习（StringBuffer ,StringBuilder,String）,都会知道线程安全有额外开销。<br>Vector内部是使用对象数组来保存数据，根据需要自动增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</li></ul><p>ArrayList是应用更广泛的动态数组实现，它本身不是线程安全的，性能相对好很多，也可以根据需要调整容量，不过Vector调整一倍，ArrayList增加50%</p><p>LinkedList 顾名思义，就是java提供的双向链表，他不需要调整容量，也不是线程安全的</p><p><strong>考点分析</strong><br><strong>面试官会考察不同容器类型适合的场景？</strong><br>       Vector 和ArrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问，增删的话除非在尾部插入或者删除，其余性能很慢。<br>       而LinkedList作为双向链表，虽然有顺序，但是随机访问性能却是很差，因为其一个数据节点中不仅得存现有节点的数据信息，还得存下一节点的位置信息。<br>       但是增加或删除节点很快，因为不需将其余元素移位，只需将其相关联的位置信息修改就ok</p><p>所以在应用开发中，我们就得提前预估到，应用操作是偏向于访问操作，还是偏向于增删操作，可以有针对性的进行选择</p><p><strong>关于java集合框架？</strong><br>这方面如果展开问，有四个大问题：</p><ul><li>java集合框架的设计结构，至少要有一个整体印象</li><li>java提供的只要容器（集合和Map）类型，了解或掌握对应的<strong>数据结构，算法</strong>，思考具体技术选择</li><li>将问题扩展到性能、并发等领域</li><li>集合框架的演进和发展</li></ul><p>1.狭义的集合框架<br><img src="https://img-blog.csdnimg.cn/20201104112340810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>大家可以看到cellection是集合的根，然后展开提供了三大类集合：</p><ul><li>List ，也就是咱们今天学的有序集合，它提供了方便的访问，插入，删除等操作</li><li>set ，set是不允许重复元素且无序的，这是和List最明显的区别，我们日常开发中很多需要保证元素唯一性的场合都可以用set。在这里说一下，很多set的实现完全依赖于Map的实现，也就是相当于HashMap的马甲</li><li>Queue/Deque,则是java提供的标准队列结构的实现。除了集合的基本功能，它还支持先进先出，后进先出等行为。<br>除了前面提到的，我们还是以现实为例，了解基本特征和典型使用场景</li><li>TreeSet支持自然顺序访问，但是添加、删除、包含等操作相对低效（log(n)时间）</li><li>HashSet则是利用哈希算法，如果哈希散列正常，可以提供常数时间级别的添加、删除、包含等操作，但它不保证有序。</li><li>LinkedHashSet,内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作略低于HashSet，需要维护链表的开销。</li><li>在遍历元素时，HashSet性能受自身容量影响，所以初始化时，不要把初始容量设置太大。而LinkedHashSet遍历性能只和元素多少有关</li></ul><p>2.典型排序算法：内部排序（归并排序，交换排序（冒泡，快排），选择排序，插入排序）<br>外部排序：掌握利用内存和外部存储处理超大数据集，至少要了解过程和思路</p><p>考察算法不一定如何简单，比如：哪些算法是不稳定的（快排，堆排），思考稳定意味着什么？<br>对不同数据集，各种排序的最好和最差情况？<br>从某个角度进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并排序优异）</p><p>我们今天介绍的都不是线程安全的，对于java.util.concurrent里面的线程安全容器，后面会介绍</p><p>并不代表这些集合不能支持并发编程的场景，在Collections工具类里，提供了一系列synchronized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span>;</span><br></pre></td></tr></table></figure><p>我们完全可以利用类似方法实现基本的线程安全集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list =collectins.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure><p>它的实现，基本上就是将每个基本方法，比如<br>get,set,add之类，都通过synchronized添加基本的同步支持。<br>注意：这些方法创建的线程安全集合，都符合迭代时fail-fast行为，当发生意外的<strong>并发修改时</strong>，尽早抛出ConcurrentModificationException异常，以避免不可预计的损失</p><p><strong>Java集合默认的排序算法是什么？具体呢？能否解释一下排序方式和设计思路？</strong></p><p>其实说出这句话的面试官都是大佬！！！<br>他想让你解释一下多种情况<br>因为你需要区分是Arrays.sort()还是Collections.sort()<br>(底层是调用Array.sort());具体什么数据类型；多大的数据集？（太小的数据集，复杂排序是没必要的，Java会直接进行二分插入排序）</p><ul><li>对于原始数据类型，目前使用的双轴快速排序，是一种改进快速排序</li><li>对于对象数据类型，目前使用TimSort，思想上也是一种归并和二分插入排序结合的优化排序算法</li><li>另外 java8直接引入了并行排序算法（parallelSort），为了充分利用现代多核处理器的计算能力，底层实现fork-join框架，当处理的数据集比较小的时候，差距不明显。但是，当数据增长到数万到百万以上，提升就是一个量级</li><li>在 java9中，java标准类库提供一系列静态工厂方法，比如 list.of(),set.of(),大大简化了构建晓得容器实例的代码量，采用新的容器静态工厂方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; simpleList =list.of(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>并且保证了不可变性</p><p>讨论一个问题？<br>今天你需要实现一个云计算任务调度系统，希望可以保证VIP客户的任务被优先处理，你可以利用那些数据结构或者标准的集合类型？</p><p>我首先会使用ArrayList来存储对象的姓名（自动开辟新内存），而后采用<br>HashMap来对接对象的任务及处理数据（可以接受NULL值），接下来如果他是VIP，我会考虑到优先级队列，还要额外考虑一下vip再分级，即同等级vip的平权问题，即优先级规则问题，还得考虑同等级多个客户互相不被单一客户大量任务阻塞的问题，调度数据放入redis里面</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArrayList,LinkedList,Vector的区别?&lt;br&gt;高效的管理和操作数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三者都是集合框架里的list，即所谓的有序集合。&lt;/li&gt;
&lt;li&gt;  按照位置进行定位，添加和删除的操作  &lt;/li&gt;
&lt;li&gt;都提供&lt;strong&gt;迭代器&lt;/strong&gt;以遍历其内容</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之SQL连接表的操作</title>
    <link href="http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-03T14:02:24.260Z</published>
    <updated>2020-11-04T01:35:30.915Z</updated>
    
    <content type="html"><![CDATA[<p>SQL92<br>很强大的功能就是在各个数据表之间连接查询<br>JOIN在SQL中的作用<br>五种连接<br><strong>1.笛卡尔积</strong><br>笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能<br>我们假定player表的数据是集合X，先进行SQL查询</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player </span><br></pre></td></tr></table></figure><p>再假定team表的数据为集合Y，同样进行SQL验证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  team</span><br></pre></td></tr></table></figure><p>接下来是笛卡尔积的调用方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player,team</span><br></pre></td></tr></table></figure><p>执行结果<img src="https://img-blog.csdnimg.cn/20201103195856723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2.等值连接<br>两张表的等值连接就是用两张表都存在的列进行连接。我们也可以对多张表进行等值连接<br>而经过我们分析，两张表的等值就是队的ID,因为都存在，我们代码中必须＋表名加以区分<br>所以代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player.team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player,team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103201731217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3.非等值连接<br>我们在进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符都是非等值连接<br>PS：我们知道player表中有身高height字段，如果想要知道每个球员的身高的级别，可以采用非等值连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.player_id,p.player_name,p.height,h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> p,height_grades <span class="keyword">AS</span> h</span><br><span class="line"><span class="keyword">WHERE</span> p.height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20201103202701344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.外连接（左连接，右连接）<br><strong>左外连接</strong>就是指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表<br>相当于SQL99的left join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id(+)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team  <span class="comment">#显示主表的所有行</span></span><br><span class="line"><span class="keyword">ON</span> player.team_id = team.team_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212346387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>右外连接</strong>，当然指的是右边的表为主表，显示右表的所有行，左侧的表为从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> team</span><br><span class="line"><span class="keyword">ON</span> player.team_id =team.team_id <span class="comment"># 显示右表的所有行</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212915704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.自连接<br>自连接可以对多个表进行操作，也可以对同一个表进行操作。也就是说查询条件使用了当前表的字段<br>我们想要查看比，布雷克 ·格里芬身高，高的球员都有谁？以及他们的对应身高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.player_name ,b.height</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a ,player <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.player_name =<span class="string">&#x27;布雷克-格里芬&#x27;</span> <span class="keyword">and</span> a.height &lt; b.height</span><br></pre></td></tr></table></figure><p>这段自连接有点怪，搜出那个名字后，直接可以拿他的身高比就可以了<br>执行结果</p><p><img src="https://img-blog.csdnimg.cn/20201103214329297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>试着做一道题？<br>表格中一共有三支球队，那么现在3支球队需要进行比赛，请用SQL语句写出所有可能的比赛组合<br>分析：根据我的理解，我觉得是笛卡尔积，但是不可能。自己和自己不能比赛<br>那么是不是能笛卡尔积+左连接<br>事实证明我上面的分析都是错的！！！！</p><p>分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(kedui.team_name,<span class="string">&#x27;VS&#x27;</span>,zhudui.team_name) <span class="keyword">AS</span> <span class="string">&#x27;客队vs主队&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> zhudui <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team <span class="keyword">AS</span> kedui</span><br><span class="line"><span class="keyword">ON</span> zhudui.team_id&lt;&gt;kedui.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020110322020619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>不分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.team_name ,b.team_name</span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> a,team <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id&lt;b.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103220216610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL92&lt;br&gt;很强大的功能就是在各个数据表之间连接查询&lt;br&gt;JOIN在SQL中的作用&lt;br&gt;五种连接&lt;br&gt;&lt;strong&gt;1.笛卡尔积&lt;/strong&gt;&lt;br&gt;笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能&lt;br&gt;我们假定player表的数据是集合X，先进行SQL查询&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之equals的基本特性，及自己对wait,notify的理解、join的理解</title>
    <link href="http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-03T10:53:25.158Z</published>
    <updated>2020-11-03T10:58:14.820Z</updated>
    
    <content type="html"><![CDATA[<p>自反性：对于任何非空引用值x,x.equals(x)都应返回true<br>对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true<br>传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.<br>一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值</p><a id="more"></a><p>equals注意事项：<br>对象域，使用equals方法<br>类型安全的枚举，使用equals或者==<br>可能为null的对象域：使用equals或者==<br>数组域，使用Arrays.equals</p><p>有一个问题：notify()会立刻释放锁吗？<br>答案是：不会<br>多个线程之间有互动关系的时候，某个线程得等一会儿wait()，等notify()提醒他，这就是互动模式<br>wait()是让线程等待的方法（线程释放对象锁，进入等待池；所以必须先得获得锁，wait必须写在synchronized代码块中，否则会报异常）<br>notify()是提醒线程该运行的方法（唤醒等待该对象同步锁的线程，放线程进入锁池中，竞争得到对象锁，然后开始执行）<br>notify唤醒的线程，都是随机唤醒的，没有顺序之分<br>notify All唤醒的线程，符合后进先出的原则<br>都是Object方法<br>所以说，notify 和notifyALL并不会立即释放对象锁，必须等到synchronized方法或者语法块执行完才能真正释放锁。然后线程去竞争。<br>贴代码：生产者和消费者<br>消费者：我用三个线程去执行队列里由生产者产生的任务(因为会产生交互，都是执行的一个队列的任务，所以任务队列得加synchronzied锁)<br>生产者：我用100个线程生产任务<br>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTaskCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;T&gt; tasks, <span class="keyword">int</span> maxTaskCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">        <span class="keyword">this</span>.maxTaskCount = maxTaskCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(T task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果这个检查不在synchronized块里会怎么样呢？</span></span><br><span class="line">            <span class="comment">// TODO 如果如果不用while会怎么样呢？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() &gt;= maxTaskCount) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(task);</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;T&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果不用while，用if，会怎么样？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = tasks.poll();</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCKER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; urls = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;&gt;(urls);</span><br><span class="line">        Producer&lt;String&gt; producer = <span class="keyword">new</span> Producer&lt;&gt;(urls, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread consumerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = consumer.consume();</span><br><span class="line">                        processURL(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;消费者-&quot;</span> + i);</span><br><span class="line">            consumerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread producerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = produceURL();</span><br><span class="line">                        producer.produce(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;生产者-&quot;</span> + i);</span><br><span class="line">            producerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 如果想给生产者消费者做一个统计，统计每个生产者消费者所生产/消费的task的数量，应该</span></span><br><span class="line">        <span class="comment">// TODO 1）使用哪种数据结构？</span></span><br><span class="line">        <span class="comment">// TODO 2）如何保证线程安全？</span></span><br><span class="line">        <span class="comment">// TODO 3）怎么将统计结果输出到控制台？</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">produceURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ret.append(<span class="string">&quot;www.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.append(<span class="string">&quot;.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processURL</span><span class="params">(String url)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理：&quot;</span> + url);</span><br><span class="line">        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;处理完成：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>粗略涉及一下join方法<br>join方法同步<br>就涉及范围更广了<br>比如一个线程A.join，<br>那么下一个线程就必须等待A执行完，才能执行<br><strong>我现在理解的多线程是并发执行不同的任务，一些需要交互的用synchronized,wait/notify、join方法保证，整体并发时间肯定比一个个执行线程的时间少</strong><br>下面我贴一个代码！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.join;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; CONTENTS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> WORKING_DURATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainStart = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始抓取网页内容&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                String content = getContentFromWeb();</span><br><span class="line">                <span class="keyword">long</span> threadWorkingDuration = System.currentTimeMillis() - start;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:抓取网页内容结束&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (CONTENTS) &#123;</span><br><span class="line">                    CONTENTS.add(content);</span><br><span class="line">                    WORKING_DURATION += threadWorkingDuration;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO sleep一下，让线程都启动起来</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程开始 join  ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = thread.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程开始join &quot;</span> + name + <span class="string">&quot; ------------ &quot;</span>);</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程join &quot;</span> + name + <span class="string">&quot; 结束 ------------ &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程join结束，获取的内容为： ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        CONTENTS.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.print(s.length() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainWorkDuration = System.currentTimeMillis() - mainStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 多线程的意义就是让工作并发的处理，使用更多的资源（CPU，磁盘，网络等），以便让工作更快的完成。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程累计工作时间：&quot;</span> + WORKING_DURATION);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程工作时间：&quot;</span> + mainWorkDuration);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getContentFromWeb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000000</span>)) % <span class="number">4096</span> + <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工作线程累计工作时间：33466<br>主线程工作时间：6727<br>线程累计时间多，而并发线程时间少！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自反性：对于任何非空引用值x,x.equals(x)都应返回true&lt;br&gt;对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true&lt;br&gt;传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.&lt;br&gt;一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Hashtable、HashMap、TreeMap</title>
    <link href="http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-11-03T05:50:17.860Z</published>
    <updated>2020-11-03T05:55:22.329Z</updated>
    
    <content type="html"><![CDATA[<p>map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现</p><p>Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。</p><a id="more"></a><p>HashMap与Hashtable行为基本上一致，不一样的地方在于HashMap<strong>不是同步</strong>的，<strong>支持null键和值</strong><br>通常，HashMap进行put或者get操作，可以达到常数时间的性能,因此使我们利用键值对存取场景的首选。比如：<br>用户ID –用户信息对应的运行时存储结构</p><p>Treemap是基于红黑树的一种提供<strong>访问顺序</strong>的Map，和HashMap不同，它的get,put,remove的时间复杂度都是O（log(n)）,具体顺序由指定的Comparator来决定，或者由键的自然顺序来判断</p><p><strong>HashMap的设计和实现细节</strong><br>  HashMap扩展了abstractMap，且非常依赖于哈希码的有效性：<br>  1.equals相等，hashcode一定相等<br>  2.hashcode改写以后也要改写equals<br>  3.hashCode需要保持一致性，状态改变返回的哈希值仍然要一致<br>  4.equals的对称，反射，传递等特性（下篇博客写）</p><p> <strong>有序Map</strong><br> LinkedHashMap和TreeMap都可以保证某种顺序<br> 1.linkedHashMap提供的遍历顺序符合插入顺序，它的实现是通过为键值对维护一个双向链表，<br> 通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的put,get,compute都算作“访问”。<br> 场景：构建一个空间占用敏感化的资源池，希望可以自动将最不常被访问的对象释放掉，使用LInkedHashMap来实现<br> 2.对于TreeMap,它的整体顺序是由键的顺序来决定，通过comparator或Comparable（自然顺序：必须符合约定：comparaTo的返回值需要和equals一致）来决定。<br> 代码如下，经常复盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = …</span><br><span class="line">    cmp = k.compareTo(t.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构建一个优先级的调度系统的问题，其本质就是一个典型的有限队列场景，Java标准类库提供了基于二叉堆实现的PriorityQueue,TreeMap和TreeSet也是依赖于此。</p><p><strong>HashMap内部基本点分析</strong><br>可以看作是<strong>数组（Node&lt;K,V&gt;[]table）</strong>和<strong>链表</strong>组成的符合结构<br>数组被分为一个个桶，通过哈希值决定键值对在这个数组的寻址。<br>哈希值相同的键值对，就按照链表形式存储。<br>如果链表超过阈值，就会被改造成树形结构。</p><p>这个数组似乎并没有被初始化好，仅仅设置了一些初始值而已<br>看代码就知道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们认为HashMap也许是按照lazy-load原则，在首次使用时初始化。<br>只有putVal的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evit)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> , i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line">        tab[i] = newNode(hash, key, value, nll);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">        <span class="comment">//  ... </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表格是null,resize就会负责初始化它，这从tab=<br>resize()可以看出</p><p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足要求的时候，进行扩容（resize）</p><p>在放置新的键值对的过程中，如果发生下面这种情况，就会发生扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>具体键值对在哈希表的位置（数组Index）取决于下面的位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>学过数据结构的都知道，它并不是key本身的hashCode,而是来自于HashMap里面的另外一个hash方法。<br><strong>为什么将高位数据移位到低位进行异或运算？</strong><br>计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，这种<strong>处理就可以有效避免类似情况下的哈希碰撞</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> h;</span><br><span class="line">           <span class="keyword">return</span> (key =<span class="keyword">null</span>)?<span class="number">0</span>:(h= key.hashCode())^(h&gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么树化？对链表（bin）进行怎样的处理？</strong></p><p>可以看出，putVal方法本身逻辑非常集中，从初始化，扩容到树化，都有参与<br>依据resize源码，在不考虑极端情况下的（容量理论最大极限由 MAXIMUM_CAPACITY指定，数值为1&lt;&lt;30,即2^30次方）：<br>我们可以归纳为<strong>门限值</strong>=负载因子*容量，我们通常用默认值<br><strong>门限值（就是数组的最大参数）</strong>通常以倍数调整，当元素个数超过门限大小是，即调整Map大小<br>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源</p><p><strong>容量，负载因子，树化？</strong><br>还是数据结构的原理<br>容量和负载因子都是数组的标准条件，相当于当时学过的寻找大于元素数量的最小的素数来当做数组。<br>就相当于桶的数量，太少和占用太满都会影响操作的性能</p><p>负载因子：不超过0.75<br>如果使用太小的负载因子，则用导致更加频繁的扩容，增加开销成本</p><p>树化改造，不外乎对应逻辑就是putVal和treeIfyBin中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> n,index;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> (tab ==<span class="keyword">null</span> ||(n =tab.length)&lt;MIN_TREEIFY_CAPACITY)</span><br><span class="line">               resize();<span class="comment">//创建数组</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>((e=tab[index =(n-<span class="number">1</span>)&amp;hash])! =<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//树化逻辑改造</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>数组判定条件：当bin的数量大于TREEIFY_THRESHOLD（默认是8）的条件下：（一个桶中有8个元素），允许红黑树化<br>—&gt;接下来有判定条件：<br>如果容量小于MIN_TREEIFY_CAPACITY，只会进行简单的扩容<br>如果容量大于MIN_TREEIFY_CAPACITY（最小树形阈值）<br>则进行红黑树化</p><p>本质上是一个安全问题，如果哈希冲突，都会放置同一个桶里，形成链表，我们知道链表是线性的，会影响存取的性能。<br>第二是因为构造哈希冲突的数据并不是非常复杂的事情，恶意代码可以利用这些数据大量与服务器交互，从而让服务器CPU被大量占用，造成崩溃，所以允许树化，再不济进行扩容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现&lt;/p&gt;
&lt;p&gt;Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之sql子查询</title>
    <link href="http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-02T11:40:50.925Z</published>
    <updated>2020-11-02T11:43:39.213Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a><br>查询结果集<br><strong>关联子查询:</strong> 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部</p><a id="more"></a><p>我们想要查找球队中大于平均身高的球员有哪些？并显示他们的球员姓名身高和所在球队ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height,team_id</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height)</span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id =b.team_id)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次查询都得执行一次子语句</p><p>通常关联子查询也会和EXISTS一起使用<br>比如我们想看出场过的球员有哪些？并且显示他们的姓名，id，球队ID</p><p>是否出场可以通过player_score此表来查询，因为在player_score有出场记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,team_id</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> player_id  <span class="keyword">FROM</span> player_score</span><br><span class="line"><span class="keyword">WHERE</span> player.player_id =player_score.player_id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IN和EXISTS虽然查询结果一样，但是效率确不一样，<br>如果A表比B表小，EXISTS效率高，因为查询时可以使用A表对于play_id的索引，反之，则IN效率更高(小表驱动大表更有效率)</p><p>ANY ,ALL<br>举例：<br>想要查询球员表中，比印第安纳步行者team_id=002那只队中任意一个球员身高高的所有球员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ANY</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ALL</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><p><strong>将子查询作为主查询的计算字段（把子查询的结果当做主查询的列）</strong><br>比如我想查询每个球队的球员数，也就是对应那个team_id ,相同的team_id在player这张表中球员数量是多少</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> team_name,(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id)</span><br><span class="line"><span class="keyword">AS</span> player_num</span><br><span class="line"><span class="keyword">FROM</span> team</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS player_num</span><br></pre></td></tr></table></figure><p>是给</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id</span><br></pre></td></tr></table></figure><p>起了个别名，方便我们使用</p><p>最后出个题：<br>编写SQL语句，得到场均得分大于20的球员（场均得分从player_score表中获取，同时你需要输出球员的ID，球员姓名及所在球队的ID信息）<br>我的理解是：<br>1.场均得分大于20，第一场得了40分，第二场得了2分，场均为21分照样满足条件<br>2.一场比赛中，球员可以出现多次<br>解析思路：先得出球员在每场比赛中的总分数，然后对球员按比赛分组，计算球员在所参加比赛中的平均分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t2.player_id,t2.player_name,t2.team_id,t3.v</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> t1.player_id,<span class="keyword">avg</span>(t1.total) <span class="keyword">AS</span> v</span><br><span class="line">     <span class="keyword">FROM</span> </span><br><span class="line">       (<span class="keyword">SELECT</span> player_id,<span class="keyword">SUM</span>(score) <span class="keyword">AS</span> total   <span class="keyword">FROM</span> player_score   <span class="keyword">WHERE</span> game_id <span class="keyword">IN</span>  (<span class="keyword">SELECT</span> game_id <span class="keyword">FROM</span> player_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> game_id) </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> player_id <span class="comment">#对球员进行分组，计算在每场比赛的总分数</span></span><br><span class="line">        )<span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.player_id <span class="comment">#对球员分组，计算每场比赛的均分</span></span><br><span class="line"><span class="keyword">HAVING</span> v&gt;<span class="number">20</span> <span class="comment">#对分组进行筛选</span></span><br><span class="line">)<span class="keyword">AS</span> t3 <span class="keyword">ON</span> t2.player_id =t3.player_id</span><br></pre></td></tr></table></figure><p>本题有点难度！！！！<br>要经常回来复盘！！<br>答案贴在这<br><img src="https://img-blog.csdnimg.cn/20201102193901622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>**非关联子查询:**只作为主查询的条件语句执行一次</p><p>我们想要找nba球员中谁最高？<br>且输出他的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height=(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(height) <span class="keyword">FROM</span> player)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;br&gt;查询结果集&lt;br&gt;&lt;strong&gt;关联子查询:&lt;/strong&gt; 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
