<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-23T15:07:57.268Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小厂历险记之前端，数据库，后端开发-全干开发</title>
    <link href="http://example.com/2021/04/23/%E8%AE%B0%E5%B0%8F%E5%8E%82%E5%8E%86%E9%99%A9%E8%AE%B00423--%E5%89%8D%E7%AB%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2021/04/23/%E8%AE%B0%E5%B0%8F%E5%8E%82%E5%8E%86%E9%99%A9%E8%AE%B00423--%E5%89%8D%E7%AB%AF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/</id>
    <published>2021-04-23T13:48:44.685Z</published>
    <updated>2021-04-23T15:07:57.268Z</updated>
    
    <content type="html"><![CDATA[<p>1.初入职场，不会接触Java核心编程，也没那个能力<br>2.接触Vue+Element-ui封装进行html的双向绑定，要熟悉其中的js方法，要明白其中的@事件，要明白其中的钩子函数<br>3.我们清楚了出现bug后，总结套路：<br>    a.判断html页面是否写错 b. themeleaf引用其他插件是否出错 c.如果都没出错，那我们看是否配置出错，就是你的sql语句是否出错（可以看控制台），sql不出错，那么肯定是数据库配置错误.<br>4.sql这个要重点讲讲，我们通常遇到都是些简单的语句，但是开发情况下不可能有简单语句，我们通常会精确的查多个字段，并且设置字段别名，表别名；通过连接表查询，查询出来的数据以list返回到前端<br>5.还有一个感悟，就是我们通常开发后台的时候，设置权限查询的时候，会涉及到此权限总共设计了几位，分别的主键是什么，能不能数字和key分离，我们在此时不能写一个方法进行查询。因为我不管查询哪个权限都会一次性调用多个性能，所以我不权限分成多个层级，每一层级分别查询，极大地提升效率。<br>6.关联表可以增加控制权限</p><a id="more"></a><p>目前就这些体悟，以后有时间就会更新，谢谢大家关注。<br>如果大家喜欢什么知识，记得留言，我会尽量更新并给大家讲清楚，互相学习，毕竟都是懒人</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.初入职场，不会接触Java核心编程，也没那个能力&lt;br&gt;2.接触Vue+Element-ui封装进行html的双向绑定，要熟悉其中的js方法，要明白其中的@事件，要明白其中的钩子函数&lt;br&gt;3.我们清楚了出现bug后，总结套路：&lt;br&gt;    a.判断html页面是否写错 b. themeleaf引用其他插件是否出错 c.如果都没出错，那我们看是否配置出错，就是你的sql语句是否出错（可以看控制台），sql不出错，那么肯定是数据库配置错误.&lt;br&gt;4.sql这个要重点讲讲，我们通常遇到都是些简单的语句，但是开发情况下不可能有简单语句，我们通常会精确的查多个字段，并且设置字段别名，表别名；通过连接表查询，查询出来的数据以list返回到前端&lt;br&gt;5.还有一个感悟，就是我们通常开发后台的时候，设置权限查询的时候，会涉及到此权限总共设计了几位，分别的主键是什么，能不能数字和key分离，我们在此时不能写一个方法进行查询。因为我不管查询哪个权限都会一次性调用多个性能，所以我不权限分成多个层级，每一层级分别查询，极大地提升效率。&lt;br&gt;6.关联表可以增加控制权限&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>寒假项目</title>
    <link href="http://example.com/2021/03/03/netty%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2021/03/03/netty%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/</id>
    <published>2021-03-03T11:11:59.934Z</published>
    <updated>2021-03-03T12:06:24.837Z</updated>
    
    <content type="html"><![CDATA[<p>第1章 项目介绍 超目 -信<br>第2章 netty介绍与相关基础知识<br>初识netty，学习阻塞与非阻塞，同步与异步，理解BIO、NIO、AIO以及netty的线程模型</p><p>2-1 初始netty<br>2-2 阻塞和非阻塞、同步和异步的概念<br>2-3 BIO讲解<br>2-4 NIO讲解<br>2-5 BIO NIO AIO的区别与理解<br>2-6 再看netty<br>2-7 netty的三种线程模型<br>第3章 使用netty编写第一个hello netty 服务器<br>从零开始使用netty编写服务器，在网页访问后返回hello netty，主要对服务器启动类，channel初始化器以及助手类讲解，最后会对channel的生命周期进行讲解</p><p>3-1 使用maven构建netty基础依赖<br>3-2 构建hello服务器<br>3-3 为channel设置初始化器<br>3-4 编写自定义助手类<br>3-5 hello服务器启动与讲解<br>3-6 netty生命周期<br>第4章 使用netty构建websocket服务器<br>理解实时通信，使用netty的websocket编写服务端启动类、子处理器以及助手类。 理解JS相关的websocket api，简单使用hbuilder编写通信页面与netty交互并且使用web浏览器与手机端浏览器进行测试数据交互</p><a id="more"></a><p>4-1 实时通信相关概念讲解<br>4-2 编写websocket服务端启动类<br>4-3 编写websocket子处理器initialzer<br>4-4 编写chatHandler对消息的处理<br>4-5 基于js的websocket相关api介绍<br>4-6 简单实用hbuilder工具编写前端websocket<br>4-7 测试web端携手移动端与后端netty聊天通信<br>第5章 使用MUI与H5+构建移动端app<br>零基础讲解MUI、H5+以及hbuilder开发工具，构建慕信轻聊的基本骨架</p><p>5-1 MUI,H5+，Hbuilder介绍<br>5-2 创建项目，页面基本结构讲解<br>5-3 自定义标题栏样式<br>5-4 真机调试与原生标题栏样式更改<br>5-5 首页底部tab选项卡的使用，MUI图标库讲解<br>5-6 使用阿里图标库构建自己的icon库<br>5-7 tab选项卡切换页面（上）<br>5-8 tab选项卡切换页面（下）<br>第6章 使用springboot整合netty搭建后台<br>对数据库表设计进行讲解并且使用springboot作为主要后台框架，并且整合mybatis以及netty，重构netty server并且整合</p><p>6-1 数据库表设计<br>6-2 使用mybatis逆向工具<br>6-3 搭建springboot2.0工程<br>6-4 springboot整合mybatis<br>6-5 整合netty server<br>6-6 完成netty整合springboot并且测试<br>第7章 用户注册/登录/个人信息<br>开发用户注册登录以及个人信息页面相关功能模块，其中涉及到高性能分布式文件存储服务器fastdfs的搭建，并且使用nginx发布可使用http进行web访问并且下载用户头像和二维码</p><p>7-1 注册登录页面讲解与后端接口开发1<br>7-2 注册登录页面讲解与后端接口开发2<br>7-3 登录注册页面的判断事件与js自定义util<br>7-4 登录注册前后端联调<br>7-5 首页禁止返回和用户自动登录讲解<br>7-6 开发我的个人页面<br>7-7 动态初始化个人信息<br>7-8 打开个人头像页面<br>7-9 增加可选择菜单<br>7-10 为菜单增加事件绑定<br>7-11 选择照片与裁剪插件<br>7-12 文件服务器概览<br>7-13 安装tracker服务<br>7-14 安装storage服务<br>7-15 配置client并且上传测试图片<br>7-16 nginx安装与fastdfs配置（上）<br>7-17 nginx安装与fastdfs配置（下）<br>7-18 fastdfs 整合springboot<br>7-19 后端上传图片功能开发<br>7-20 上传图片前后端联调与测试<br>7-21 头像上传后跨页面调用自定义事件刷新<br>7-22 上传头像细节部分处理与openwindow的bug处理<br>7-23 下载头像到相册<br>7-24 修改昵称页面<br>7-25 修改昵称后端接口<br>7-26 修改昵称前后端联调<br>7-27 用户二维码生成<br>7-28 我的二维码作业布置<br>7-29 我的二维码作业讲解<br>7-30 用户退出以及简单小结<br>第8章 发现页面与通讯录相关功能开发<br>用户可以通过搜索其他用户账号进行好友添加，或者通过用户的唯一二维码进行扫码添加，发送添加请求后其他用户可以拒绝或者同意好友请求</p><p>8-1 发现页面编码<br>8-2 搜索朋友账号接口（上）<br>8-3 搜索朋友账号接口（下）<br>8-4 搜索朋友前后端联调<br>8-5 搜索结果页讲解以及webview传参<br>8-6 发送添加好友请求接口编码<br>8-7 前后端连天发送好友请求<br>8-8 查询好友请求接口<br>8-9 朋友接受到请求页面联调开发<br>8-10 好友请求HTML动态渲染<br>8-11 同意或忽略事件动态绑定<br>8-12 同意或忽略controller<br>8-13 同意或忽略的service编写<br>8-14 好友请求忽略或拒绝前后台联调<br>8-15 构建扫描器<br>8-16 扫码器颜色自定义<br>8-17 扫码添加好友联调<br>8-18 延时加载预处理数据<br>8-19 mui 自带索引列表模板讲解<br>8-20 通讯录列表整合<br>8-21 图文列表和通讯录整合增加用户头像显示<br>8-22 查询用户的所有好友列表接口<br>8-23 手机端获取好友列表保存到本地<br>8-24 定义通讯录好友列表模型<br>8-25 通讯录列表渲染展现<br>8-26 好友请求接收方更新通讯录<br>第9章 聊天页面开发<br>构建手机端上的聊天页面模型，建立会话，接受发送消息，netty控制点对点消息发送，控制会话重连，聊天记录的本地保存与左滑删除，消息标记未读，消息牵手等。</p><p>9-1 聊天页面讲解与展示<br>9-2 header动态改为好友昵称，动态滚动到最新消息<br>9-3 发送按钮的颜色状态改变<br>9-4 弹出软键盘重新设置聊天窗口高度<br>9-5 发送消息前置条件网络状态判断<br>9-6 监听网络连接事件<br>9-7 发送消息html渲染<br>9-8 接收消息html渲染<br>9-9 发送消息与接收消息时的铃声播放<br>9-10 手机端websocket模型定义和发送消息<br>9-11 websocket接受消息的渲染_x264<br>9-12 服务器断开后的重连机制<br>9-13 chatHandler初步重构<br>9-14 构建聊天业务模型<br>9-15 chatHandler - 处理客户端连接<br>9-16 chatHandler - 保存聊天消息到数据库<br>9-17 chatHandler - 处理消息发送<br>9-18 chatHandler - 签收单条或多条消息<br>9-19 客户端onopen联调，初始化用户和channel关系<br>9-20 客户端发送消息与接收联调<br>9-21 接收方获得消息后重构渲染<br>9-22 客户端签收消息<br>9-23 websocket新增好友类型联调<br>9-24 保存聊天记录到本地<br>9-25 从本地获取聊天记录<br>9-26 初始化聊天记录和渲染<br>9-27 聊天快照业务简单讲解<br>9-28 保存聊天快照到本地<br>9-29 获取聊天快照<br>9-30 已读未读消息的设置与快照调用<br>9-31 展示聊天快照<br>9-32 未读消息小红点标记<br>9-33 点击快照开始聊天<br>9-34 未读消息标记已读<br>9-35 开发获取未读消息列表接口<br>9-36 前端获取未读消息列表<br>9-37 批量签收并且展示未读消息<br>9-38 聊天快照左滑删除效果<br>9-39 聊天快照右滑删除聊天记录与快照<br>第10章 使用netty编写心跳检测<br>app不会主动和服务端切断，只会有可能发生离线或者关机或者飞行模式，所以需要在后台控制心跳，检测客户端的读写请求来判断是否清除无用的channel。同时手机端也要保持一定的keepalive。未接受到的消息在用户下次打开后重新获取。    …</p><p>10-1 心跳机制的概念与飞行模式<br>10-2 心跳HeartBeatHandler编码<br>10-3 配置空闲handler与超时时间设置<br>10-4 手机端与netty的心跳测试<br>10-5 前端keepalive保持，与心跳测试<br>第11章 后端云部署与app云打包<br>本章节做为上线部分，需要购买云服务器，采用腾讯云，会对其进行讲解，然后搭建基本环境，包含JDK、tomcat、MariaDB、fastdfs、nginx，springboot打包与部署。最后对手机app进行云打包</p><p>11-1 云服务器购买推荐及安全组介绍与关联<br>11-2 文件传输工具的使用<br>11-3 命令行工具的简单使用<br>11-4 云服务器配置JDK环境<br>11-5 云服务器安装tomcat<br>11-6 云服务器离线安装MariaDB<br>11-7 云服务器MariaDB安全设置与客户端连接调试<br>11-8 云服务器安装图片服务器的注意事项以及nginx反向代理tomcat服务器<br>11-9 springboot工程打包<br>11-10 打包文件上传到云服务器并且进行tomcat部署<br>11-11 app云打包<br>第12章 课程总结<br>课程总结</p><p>12-1 课程总结</p><p>#更多资源q891377154</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章 项目介绍 超目 -信&lt;br&gt;第2章 netty介绍与相关基础知识&lt;br&gt;初识netty，学习阻塞与非阻塞，同步与异步，理解BIO、NIO、AIO以及netty的线程模型&lt;/p&gt;
&lt;p&gt;2-1 初始netty&lt;br&gt;2-2 阻塞和非阻塞、同步和异步的概念&lt;br&gt;2-3 BIO讲解&lt;br&gt;2-4 NIO讲解&lt;br&gt;2-5 BIO NIO AIO的区别与理解&lt;br&gt;2-6 再看netty&lt;br&gt;2-7 netty的三种线程模型&lt;br&gt;第3章 使用netty编写第一个hello netty 服务器&lt;br&gt;从零开始使用netty编写服务器，在网页访问后返回hello netty，主要对服务器启动类，channel初始化器以及助手类讲解，最后会对channel的生命周期进行讲解&lt;/p&gt;
&lt;p&gt;3-1 使用maven构建netty基础依赖&lt;br&gt;3-2 构建hello服务器&lt;br&gt;3-3 为channel设置初始化器&lt;br&gt;3-4 编写自定义助手类&lt;br&gt;3-5 hello服务器启动与讲解&lt;br&gt;3-6 netty生命周期&lt;br&gt;第4章 使用netty构建websocket服务器&lt;br&gt;理解实时通信，使用netty的websocket编写服务端启动类、子处理器以及助手类。 理解JS相关的websocket api，简单使用hbuilder编写通信页面与netty交互并且使用web浏览器与手机端浏览器进行测试数据交互&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/01/05/%22%E6%B2%B3%E9%95%BF%22%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84%E5%BA%95%E5%9B%BE%E7%94%9F%E6%88%90%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>http://example.com/2021/01/05/%22%E6%B2%B3%E9%95%BF%22%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84%E5%BA%95%E5%9B%BE%E7%94%9F%E6%88%90%E7%9A%84%E5%89%AF%E6%9C%AC/</id>
    <published>2021-01-05T06:32:55.389Z</published>
    <updated>2021-01-05T06:33:34.104Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#999AAA >提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档</p></font><p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><h1 id="一、河长制是什么？"><a href="#一、河长制是什么？" class="headerlink" title="一、河长制是什么？"></a>一、河长制是什么？</h1><p>“河长（zhǎng）制”，即由中国各级党政主要负责人担任“河长”，负责组织领导相应河湖的管理和保护工作。“河长制”工作的主要任务包括六个方面。</p><p>2017年的元旦，习近平总书记在新年贺词中发出“每条河流要有‘河长’了”的号令 [4]  。截至2018年6月底，全国31个省（自治区、直辖市）已全面建立河长制，共明确省、市、县、乡四级河长30多万名，另有29个省份设立村级河长76万多名，打通了河长制“最后一公里” [5]  。</p><h1 id="二、环科院的需求"><a href="#二、环科院的需求" class="headerlink" title="二、环科院的需求"></a>二、环科院的需求</h1><h2 id="1-环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据"><a href="#1-环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据" class="headerlink" title="1.环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据"></a>1.环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据</h2><p>从需求出发，再结合环科院老师的深入解读，主要痛点分为以下几点：<br>1.环科院是统筹部门，不会外派到执政单位专门测绘底图，监测数据，而后上传<br>2.环科院一个部门之力，不能给所有全国1347个县级单位的河流制定一个完整的系统底图，并实时传送数据<br><strong>需求：</strong><br>    这时需要有一个运行程序，实行封装功能，制作UI按键，通过智能识别（地图）图像一键生成出2.5D的一个斜切面图，上面在重要的点之间标注好数据，如果条件允许还会增加传感器进一步优化数据，并设置好时间隔段传输数据，实时反馈给当地责任制行政长官“河长”</p><h2 id="2-需求知悉，查取可行方案数据"><a href="#2-需求知悉，查取可行方案数据" class="headerlink" title="2.需求知悉，查取可行方案数据"></a>2.需求知悉，查取可行方案数据</h2><a id="more"></a><p>途径：<br>1.x-mol文献阅读 ——&gt;国外最新研究成果<br>2.知网——&gt;国内最新研究成果<br>3.头条号、csdn、简书、牛客网、微信公众号查看人工智能在图像提取方面的领域贡献和成熟度<br>4.总结自己查取的论文，总结出以下技术路径<br>    a.不计成本GIS卫星地图，传感器扫描 实现<br>    b.小而美的利用传统CV技术实现图像提取，再通过autoCAD实现2.5D的一个基本提取功能，后续加入传感器，再通过pyecharts实现关键点标注，图像反馈</p><p>结果毫无疑问，通过小组的讨论，选择了B方案</p><h2 id="3-软硬件配置"><a href="#3-软硬件配置" class="headerlink" title="3.软硬件配置"></a>3.软硬件配置</h2><p><strong>软件</strong><br>1.Pycharm+python3’6<br>2.openCV的资源包<br>3.独立编写的代码（解析图片提取代码+AutoCAD生成代码+Pyechart图表生成代码）<br><strong>硬件</strong><br>1.摄像头<br>2.Jseon Nano依托平台（或者一台带有python3.6的电脑）<br>3.传感器</p><h1 id="后续任务延伸"><a href="#后续任务延伸" class="headerlink" title="后续任务延伸"></a>后续任务延伸</h1><p>每月都会提交gitee项目管理，目前遇到的技术难点关键是地图中的文字处理问题。<br>三种解决方案：<br>1.采用fast R-cnn识别字体，将其消除<br>2.采用openCV像素均值化，将其黑色字体干掉<br>3.调用手机端的SDK，腾讯百度地图提供了一键消除组建的API<br>目前正在商议中</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#999AAA &gt;提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档&lt;/p&gt;
&lt;/font&gt;

&lt;p&gt;@&lt;a href=&quot;%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、河长制是什么？&quot;&gt;&lt;a href=&quot;#一、河长制是什么？&quot; class=&quot;headerlink&quot; title=&quot;一、河长制是什么？&quot;&gt;&lt;/a&gt;一、河长制是什么？&lt;/h1&gt;&lt;p&gt;“河长（zhǎng）制”，即由中国各级党政主要负责人担任“河长”，负责组织领导相应河湖的管理和保护工作。“河长制”工作的主要任务包括六个方面。&lt;/p&gt;
&lt;p&gt;2017年的元旦，习近平总书记在新年贺词中发出“每条河流要有‘河长’了”的号令 [4]  。截至2018年6月底，全国31个省（自治区、直辖市）已全面建立河长制，共明确省、市、县、乡四级河长30多万名，另有29个省份设立村级河长76万多名，打通了河长制“最后一公里” [5]  。&lt;/p&gt;
&lt;h1 id=&quot;二、环科院的需求&quot;&gt;&lt;a href=&quot;#二、环科院的需求&quot; class=&quot;headerlink&quot; title=&quot;二、环科院的需求&quot;&gt;&lt;/a&gt;二、环科院的需求&lt;/h1&gt;&lt;h2 id=&quot;1-环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据&quot;&gt;&lt;a href=&quot;#1-环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据&quot; class=&quot;headerlink&quot; title=&quot;1.环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据&quot;&gt;&lt;/a&gt;1.环科院分院太少，下设机构人手不多，不可能具象的给每个县级单位，乡级单位配备底图，添加数据&lt;/h2&gt;&lt;p&gt;从需求出发，再结合环科院老师的深入解读，主要痛点分为以下几点：&lt;br&gt;1.环科院是统筹部门，不会外派到执政单位专门测绘底图，监测数据，而后上传&lt;br&gt;2.环科院一个部门之力，不能给所有全国1347个县级单位的河流制定一个完整的系统底图，并实时传送数据&lt;br&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;br&gt;    这时需要有一个运行程序，实行封装功能，制作UI按键，通过智能识别（地图）图像一键生成出2.5D的一个斜切面图，上面在重要的点之间标注好数据，如果条件允许还会增加传感器进一步优化数据，并设置好时间隔段传输数据，实时反馈给当地责任制行政长官“河长”&lt;/p&gt;
&lt;h2 id=&quot;2-需求知悉，查取可行方案数据&quot;&gt;&lt;a href=&quot;#2-需求知悉，查取可行方案数据&quot; class=&quot;headerlink&quot; title=&quot;2.需求知悉，查取可行方案数据&quot;&gt;&lt;/a&gt;2.需求知悉，查取可行方案数据&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之SpringMVC框架的初解</title>
    <link href="http://example.com/2021/01/02/SpringMVC%E7%9A%84%E5%88%9D%E8%A7%A3/"/>
    <id>http://example.com/2021/01/02/SpringMVC%E7%9A%84%E5%88%9D%E8%A7%A3/</id>
    <published>2021-01-02T08:24:32.754Z</published>
    <updated>2021-01-02T08:25:33.549Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>SpringMVC是表现层框架，用于接收从持久层，业务层到页面的数据，然后将其显示于页面上。</p></li><li><p>SpringMVC流程：==&gt;model:    javabean   view：jsp   contorller:servlet<br>  （应用于前后端分离）<br>  请求参数–&gt;到达控制器（sevlet）–&gt;封装进javaBean中–&gt;与业务层进行交互–&gt;servlet封装–&gt;javaBean返回数据到view层中</p></li><li><p>SpringMVC是基于java的实现mvc设计模式的请求驱动类型轻量级Web框架，我们通常还需要HTTPservlet请求,而在springmvc中不太需要，只需要一个类就行（注解，resultful编程风格）</p></li><li><p>SpringMVC与Struts2的异同点？<br>  同：都有mvc框架，都离不开原始servletAPI，处理机制都会有核心控制器<br>  异： 1.基于方法设计的，只有一个单例；而struts2还得每次创建 </p><pre><code>  2.springmvc支持异步，  3.struts支持OGNL表达式，执行效率不高。</code></pre></li><li><p>需求：入门程序<br>  请求–&gt;servlet（jsp）–&gt;处理–&gt;返回（显示）</p></li><li><p>前端控制器<br>  web.xml ==&gt;你发任何的请求都会经过这个servlet</p><a id="more"></a><p>  控制你的类调用业务层，springIOC进行类控制，注解扫描一气呵成</p><p>  <context :component-scan base-package="cn.itcast"/>  ==&gt;扫到了形成对象控制</p><p>  在方法上再加一个注解@RequestMapping<br>  加载springmvc.xml配置文件加载，用前端控制器加载，就可以使用注解了<br>  相当于我们执行完以后，可以跳转到自己定义的页面&lt;==（配置视图解析器对象，帮你跳转到想要的页面，需要配置两个属性,1.目录路径 name=”prefix” value =”/WEB-INF/pages/“2.后缀名 name=”suffix”,value=”.jsp”）</p><ol start="7"><li>   最后开启MVC框架注解的支持<br><a href="mvc:annotation-driven/">mvc:annotation-driven/</a></li><li>   启动服务器，RequestMapping是基于controller层的，请求项目名/hello</li><li>流程总结：<br> 1.启动服务器，加在一些配置文件<pre><code> web.xml中配置&lt;load-on-startup&gt;&lt;/oad-on-startup&gt;这个标签，加载DispatcherServlet，这个servlet执行springmvc.xml文件==&gt;注解扫描==&gt;将controller这个类加载成对象（单例）==&gt;视图解析器bean标签，也会变成对象，直接可以工作，跳转页面==&gt;开启SpringMVC注解RequestMapping后，发请求直接找到对象调用方法</code></pre> 2.发送请求，后台处理这个请求<pre><code> 写了一个超链接，帮助我们发送请求（项目名称/hello），第一个执行的就是web.xml里面的ispatcherServlet（因为不管是任何请求都要经过前端控制器&lt;指挥中心&gt;）==&gt;（1）（对应）根据controller里面的注解path ==&gt;目的是：让这个方法去执行，return &quot;success&quot;（2）加载视图解析器,因为配置，帮助咱们跳转success.jsp（总结：springmvc.xml里面只加载注解，形成放对象的容器；而前端控制器则是既支持自动加载，又支持加载springMVC.xml,还加载视图加载器）</code></pre> 3.前端控制器将响应后的结果显示到view层</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SpringMVC是表现层框架，用于接收从持久层，业务层到页面的数据，然后将其显示于页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SpringMVC流程：==&amp;gt;model:    javabean   view：jsp   contorller:servlet&lt;br&gt;  （应用于前后端分离）&lt;br&gt;  请求参数–&amp;gt;到达控制器（sevlet）–&amp;gt;封装进javaBean中–&amp;gt;与业务层进行交互–&amp;gt;servlet封装–&amp;gt;javaBean返回数据到view层中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SpringMVC是基于java的实现mvc设计模式的请求驱动类型轻量级Web框架，我们通常还需要HTTPservlet请求,而在springmvc中不太需要，只需要一个类就行（注解，resultful编程风格）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SpringMVC与Struts2的异同点？&lt;br&gt;  同：都有mvc框架，都离不开原始servletAPI，处理机制都会有核心控制器&lt;br&gt;  异： 1.基于方法设计的，只有一个单例；而struts2还得每次创建 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  2.springmvc支持异步，
  3.struts支持OGNL表达式，执行效率不高。&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需求：入门程序&lt;br&gt;  请求–&amp;gt;servlet（jsp）–&amp;gt;处理–&amp;gt;返回（显示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端控制器&lt;br&gt;  web.xml ==&amp;gt;你发任何的请求都会经过这个servlet&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring事务处理API</title>
    <link href="http://example.com/2020/12/16/spring%E7%9A%84aop%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86API%EF%BC%8C%E4%BB%A3%E6%9B%BF%E4%B9%8B%E5%89%8D%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2020/12/16/spring%E7%9A%84aop%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86API%EF%BC%8C%E4%BB%A3%E6%9B%BF%E4%B9%8B%E5%89%8D%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2020-12-16T10:07:28.869Z</published>
    <updated>2020-12-16T10:49:11.895Z</updated>
    
    <content type="html"><![CDATA[<p>清楚其中事务处理的原理，而后懂API，才能不至于根基不牢，问啥啥不会<br>使用Spring 事务管理API的步骤<br>1、配置事务管理器<br>        2、配置事务的通知<br>                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的<br>                使用tx:advice标签配置事务通知<br>                    属性：<br>                        id：给事务通知起一个唯一标识<br>                        transaction-manager：给事务通知提供一个事务管理器引用<br>        3、配置AOP中的通用切入点表达式<br>        4、建立事务通知和切入点表达式的对应关系<br>        5、配置事务的属性<br>               是在事务的通知tx:advice标签的内部</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xmlns:tx=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置业务层--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;accountService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置账户的持久层--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;accountDao&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;1234&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- spring中基于XML的声明式事务控制配置步骤</span><br><span class="line">        <span class="number">1</span>、配置事务管理器</span><br><span class="line">        <span class="number">2</span>、配置事务的通知</span><br><span class="line">                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的</span><br><span class="line">                使用tx:advice标签配置事务通知</span><br><span class="line">                    属性：</span><br><span class="line">                        id：给事务通知起一个唯一标识</span><br><span class="line">                        transaction-manager：给事务通知提供一个事务管理器引用</span><br><span class="line">        <span class="number">3</span>、配置AOP中的通用切入点表达式</span><br><span class="line">        <span class="number">4</span>、建立事务通知和切入点表达式的对应关系</span><br><span class="line">        <span class="number">5</span>、配置事务的属性</span><br><span class="line">               是在事务的通知tx:advice标签的内部</span><br><span class="line"></span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transactionManager&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置事务的通知--&gt;</span><br><span class="line">    &lt;tx:advice id=<span class="string">&quot;txAdvice&quot;</span> transaction-manager=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 配置事务的属性</span><br><span class="line">                isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</span><br><span class="line">                propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</span><br><span class="line">                read-only：用于指定事务是否只读。只有查询方法才能设置为<span class="keyword">true</span>。默认值是<span class="keyword">false</span>，表示读写。</span><br><span class="line">                timeout：用于指定事务的超时时间，默认值是-<span class="number">1</span>，表示永不超时。如果指定了数值，以秒为单位。</span><br><span class="line">                rollback-<span class="keyword">for</span>：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</span><br><span class="line">                no-rollback-<span class="keyword">for</span>：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">&quot;*&quot;</span> propagation=<span class="string">&quot;REQUIRED&quot;</span> read-only=<span class="string">&quot;false&quot;</span>/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置aop--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- 配置切入点表达式--&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">        &lt;!--建立切入点表达式和事务通知的对应关系 --&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;清楚其中事务处理的原理，而后懂API，才能不至于根基不牢，问啥啥不会&lt;br&gt;使用Spring 事务管理API的步骤&lt;br&gt;1、配置事务管理器&lt;br&gt;        2、配置事务的通知&lt;br&gt;                此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的&lt;br&gt;                使用tx:advice标签配置事务通知&lt;br&gt;                    属性：&lt;br&gt;                        id：给事务通知起一个唯一标识&lt;br&gt;                        transaction-manager：给事务通知提供一个事务管理器引用&lt;br&gt;        3、配置AOP中的通用切入点表达式&lt;br&gt;        4、建立事务通知和切入点表达式的对应关系&lt;br&gt;        5、配置事务的属性&lt;br&gt;               是在事务的通知tx:advice标签的内部&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring AOP</title>
    <link href="http://example.com/2020/12/14/Spring%20AOP-2/"/>
    <id>http://example.com/2020/12/14/Spring%20AOP-2/</id>
    <published>2020-12-14T12:35:04.313Z</published>
    <updated>2020-12-14T12:37:33.704Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行期间，不修改源码对已有方法进行增强<br>优势：<br>    减少重复代码<br>    提高开发效率<br>    维护方便<br>AOP实现方法：<br>    使用动态代理（1.基于接口2.基于子类）</p><p>Spring AOP（基于注解）<br>    通过配置的方式来实现我们前面创建代理的代码<br>    相关术语：<br>        <strong>Joinpoint(连接点)</strong><br>        业务层接口，看到的方法都是连接点（有事务支持）<br>         <strong>Pointcut(切入点)</strong><br>         被增强的方法<br>         Advice（通知）<br>         Introduction(引介)</p><a id="more"></a><p>总结：切面应该是通过注解实现所有事务的执行顺序以及解决重复事务的功能</p><p>我们应该做的：<br>编写核心业务代码（开发主线）：大部分程序员做，要求熟悉业务员需求<br>把公用代码抽取出来，制作成通知。（开发阶段最后来做）：AOP编程人员来做<br>在配置文件中，生命切入点与通知间的关系，即切面</p><p>Spring基于XML的AOP配置<br>    spring任何一个内容，都需要IOC的配置或者注解文件<br>    构想:<br>    创建一个spring项目很简单：<br>    1.三层架构，加上ioc注解<br>    2.aop解决冗余业务层代码问题<br>    3.mybatis解决持久层查询问题（注解or配置文件查询）<br>    注：AOP集成了动态代理<br>通知的其他类型：<br> spring中基于xml的aop步骤<br>        1.把通知的bean也交spring来管理<br>        2.使用aop:config标签表明开始AOP的配置<br>        3.使用aop:aspect标签配置切面<br>            id属性：是给切面提供一个唯一标识<br>            ref属性：指定通知类bean的Id<br>        4.在aop:aspect标签的内部使用对应标签来配置通知的类型<br>            我们现在示例是让printLog方法在切入点方法执行之前执行：所以是前置通知<br>            aop:before：表示配置前置通知<br>                method属性：用于指定Logger类中那个方法是前置通知<br>                pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强<br>            切入点表达式的写法：<br>                关键字：execution(表达式)<br>                表达式：<br>                    访问修饰符 返回值  包名.包名.包名…类名.方法名（参数列表）<br>                     public void com.bjut.service.impl.AccountServiceImpl.saveAccount()<br>                     访问修饰符课省略<br>                     返回值可以使用通配符，表示任意返回值<br>                     包名可以使用通配符，表示任意包<br>                     全通配写法<br>                     * <em>..</em>.<em>(..)<br>                     实际开发中：通常写法：<br>                     切到业务层实现类下的所有方法<br>                      <em>com.bjut.service.impl.</em>.</em>(..)</p><p>可以配置全类名，且可以任意切面使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置切入点表达式 id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span></span><br><span class="line"><span class="comment">              此标签写在aop:aspect标签内部只能当前切面使用。</span></span><br><span class="line"><span class="comment">              它还可以写在aop:aspect外面，此时就变成了所有切面可用</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>环绕通知：<br>配置环绕通知</p><pre><code> * 环绕通知 * 问题： *      当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。 * 分析： *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。 * 解决： *      Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。 *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。 * * spring中的环绕通知： *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。 */</code></pre><p><strong>AOP实际上就是方法增强器！！！！</strong><br>通过注解+代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;logger&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//表示当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundPringLog</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Object[] args = pjp.getArgs();<span class="comment">//得到方法执行所需的参数</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。前置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);<span class="comment">//明确调用业务层方法（切入点方法）</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。后置&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rtValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Logger类中的aroundPringLog方法开始记录日志了。。。最终&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将一些繁琐的重复的代码在切面先行执行！</p><p>环绕通知可以准确的帮程序员实现AOP的提醒顺序<br>放在切入点方法前面就是就是前置通知（同样的，可以提前执行某些方法，不一定是通知）<br>放在切入点方法后面就是后置通知（同样的，可以过后执行某些方法，不一定是通知）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在程序运行期间，不修改源码对已有方法进行增强&lt;br&gt;优势：&lt;br&gt;    减少重复代码&lt;br&gt;    提高开发效率&lt;br&gt;    维护方便&lt;br&gt;AOP实现方法：&lt;br&gt;    使用动态代理（1.基于接口2.基于子类）&lt;/p&gt;
&lt;p&gt;Spring AOP（基于注解）&lt;br&gt;    通过配置的方式来实现我们前面创建代理的代码&lt;br&gt;    相关术语：&lt;br&gt;        &lt;strong&gt;Joinpoint(连接点)&lt;/strong&gt;&lt;br&gt;        业务层接口，看到的方法都是连接点（有事务支持）&lt;br&gt;         &lt;strong&gt;Pointcut(切入点)&lt;/strong&gt;&lt;br&gt;         被增强的方法&lt;br&gt;         Advice（通知）&lt;br&gt;         Introduction(引介)&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring AOP前置，Spring AOP解决的问题和痛点？</title>
    <link href="http://example.com/2020/12/14/Spring%20AOP/"/>
    <id>http://example.com/2020/12/14/Spring%20AOP/</id>
    <published>2020-12-14T06:49:13.991Z</published>
    <updated>2020-12-14T07:00:47.022Z</updated>
    
    <content type="html"><![CDATA[<p>Spring AOP前置，Spring AOP解决的问题和痛点？</p><ol><li>完善account案例</li><li>分析案例中问题</li><li>回顾之前讲过的一个技术：动态代理，proxy</li><li>动态代理另一种实现方式</li><li>解决案例中的问题</li><li>AOP的概念</li><li>spring中的AOP相关术语</li><li>spring中基于xml和注解的AOP配置<a id="more"></a>前面五步:就是我们写代码时需要一直重复的一些问题：动态代理<br>后面三步:我们可以将前面五步集成为一个AOP的切面平台<br>，将业务层彻底简化。<br>这将是我们达到的目的<br>1.案例中将添加转账方法并演示事务问题</li></ol><p>我们需要一个处理事务整体只和数据库连接一次，回滚也可以<br>1.我们建立一个utils包<br>        先将线程独立出来,而后形成一个工具类，因为工具类占用线程池的线程，天然绑定一个连接（事务管理），所以最后要关闭（close）+剔除（remove）<br>        获取线程–&gt;事务控制+remove连接<br><strong>bean.xml配置：</strong><br>1.首先控制线程与数据库连接的工具类只有一个。那就是ConnectionUtils,事务管理bean（业务层service专用）也是connectionUtils的一个延伸，所以要注入connectionUtils</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.utils.TransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入ConnectionUtils --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionUtils&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionUtils&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事务控制成功<br>总结：<br>1.先有线程与数据库连接的工具类<br>2.而后通过线程工具类实现事务可视化控制</p><p>但是有缺点：<br>就是事务控制层的方法调用，太耦合。<br>解决办法：动态代理<br>Java中的动态代理机制<br>    proxy要求必须实现一个借口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">               producer.getClass().getInterfaces(),</span><br></pre></td></tr></table></figure><p>而另一种基于jar包的cglib动态代理机制，可以实现普通java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>总结：<br>1.为了避免线程自动与数据库的数次交互，我们采用了两个工具类，一个摘取线程，一个是在线程的基础上控制事务。<br>2.但是此刻不可避免的遗漏了一个情况：就是每一次事务执行都得配套所有的事务执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.开启事务</span></span><br><span class="line">                            txManager.beginTransaction();</span><br><span class="line">                            <span class="comment">//2.执行操作</span></span><br><span class="line">                            rtValue = method.invoke(accountService, args);</span><br><span class="line">                            <span class="comment">//3.提交事务</span></span><br><span class="line">                            txManager.commit();</span><br><span class="line">                            <span class="comment">//4.返回结果</span></span><br><span class="line">                            <span class="keyword">return</span> rtValue;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//5.回滚操作</span></span><br><span class="line">                            txManager.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//6.释放连接</span></span><br><span class="line">                            txManager.release();</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure><p>所以我们通过动态代理对象形成一个代理处理事务的类，帮助我们处理一系列事务，使得serviceImpl代码清洁，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事务控制应该都是在业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAccountById(accountId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        accountDao.updateAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAccount</span><span class="params">(Integer acccountId)</span> </span>&#123;</span><br><span class="line">        accountDao.deleteAccount(acccountId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Float money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;transfer....&quot;</span>);<span class="comment">//事务处理</span></span><br><span class="line">            <span class="comment">//2.1根据名称查询转出账户</span></span><br><span class="line">            Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">            <span class="comment">//2.2根据名称查询转入账户</span></span><br><span class="line">            Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">            <span class="comment">//2.3转出账户减钱</span></span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            <span class="comment">//2.4转入账户加钱</span></span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            <span class="comment">//2.5更新转出账户</span></span><br><span class="line">            accountDao.updateAccount(source);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            int i=1/0;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.6更新转入账户</span></span><br><span class="line">            accountDao.updateAccount(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是随之而来的配置文件比较头疼：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置代理的service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;proxyAccountService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getAccountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置beanfactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.BeanFactory&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入service --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入事务管理器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以这就是spring aop诞生的原因，即简化了业务层的事务代码，又简化了代理对象的配置文件！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring AOP前置，Spring AOP解决的问题和痛点？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完善account案例&lt;/li&gt;
&lt;li&gt;分析案例中问题&lt;/li&gt;
&lt;li&gt;回顾之前讲过的一个技术：动态代理，proxy&lt;/li&gt;
&lt;li&gt;动态代理另一种实现方式&lt;/li&gt;
&lt;li&gt;解决案例中的问题&lt;/li&gt;
&lt;li&gt;AOP的概念&lt;/li&gt;
&lt;li&gt;spring中的AOP相关术语&lt;/li&gt;
&lt;li&gt;spring中基于xml和注解的AOP配置</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Spring整合junit的配置</title>
    <link href="http://example.com/2020/12/13/Spring%E6%95%B4%E5%90%88junit%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2020/12/13/Spring%E6%95%B4%E5%90%88junit%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2020-12-13T08:24:00.869Z</published>
    <updated>2020-12-13T08:25:50.660Z</updated>
    
    <content type="html"><![CDATA[<p>1.应用程序的入口<br>    main方法<br>2.junit单元测试中，没有main方法也能执行<br>    junit就会判断当前测试类中哪些方法有@Test注解<br>    junit就让有注解的方法执行<br>3.junit不会管我们是否使用了spring框架<br>4.当测试方法执行时，没有IOC容器，就算写@Autowried注解，也会产生空指针异常</p><a id="more"></a><p>解决方法：<br>    Spring整合junit的配置<br>        1.导入Spring整合junit的jar包<br>        2.使用junit提供的一个注解把原有的main方法替换了，替换成spring提供的@Runwith<br>        3.告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置<br>        基于注解的：@ContextConfiguration(classes = SpringConfiguration.class)<br>        基于配置文件的：@ContextConfiguration(locations = “classpath:bean.xml”) </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.应用程序的入口&lt;br&gt;    main方法&lt;br&gt;2.junit单元测试中，没有main方法也能执行&lt;br&gt;    junit就会判断当前测试类中哪些方法有@Test注解&lt;br&gt;    junit就让有注解的方法执行&lt;br&gt;3.junit不会管我们是否使用了spring框架&lt;br&gt;4.当测试方法执行时，没有IOC容器，就算写@Autowried注解，也会产生空指针异常&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之基于Spring的常用注解IOC以及IOC的案例</title>
    <link href="http://example.com/2020/12/13/%E5%9F%BA%E4%BA%8ESpring%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3IOC%E4%BB%A5%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2020/12/13/%E5%9F%BA%E4%BA%8ESpring%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3IOC%E4%BB%A5%E5%8F%8AIOC%E7%9A%84%E6%A1%88%E4%BE%8B/</id>
    <published>2020-12-13T08:02:17.748Z</published>
    <updated>2020-12-13T08:04:38.489Z</updated>
    
    <content type="html"><![CDATA[<p> 基于Spring的常用注解IOC以及IOC的案例<br>     1.SpringIOC的常用注解<br>     2.案例使用xml方式和注解方式实现单表的CRUD操作<br>         持久层技术选择：dbutils<br>     3.改造基于注解的IOC案例，使用纯注解的方式实现<br>         Spring的一些新注解</p><a id="more"></a><p>xml配置与IOC注解配置：<br>    注解分为四类：<br>        1.用于创建对象的<br>        2.用于注入数据的<br>        3.用于改变作用范围的<br>        4.和生命周期相关<br>        @component<br>    注解必须用context的 component-scan base-package=”com.itheima.xxx”<br>    开始扫描所有类上和接口上的注解<br>        xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a><br>    告知spring在创建容器式要扫描的包，配置需要的标签不是在beans标签的约束中，而是在一个名称为context的名称空间和约束中。<br>这些注解是生成实例的：<br>    @controller一般用于表现层<br>    @service 一般用于业务层<br>    @Repository一般用于持久层</p><p>依赖反转+依赖注入</p><p>用于注入数据的：<br>@Autowired（方法）<br>自动按照类型注入，找到数据类型就可以注入（只有唯一一个符合的bean时）。<br>@Qualifier不能独立用，与@Autowired一起使用<br>    但是有一种特殊情况，就是给方法注入时可以单独使用@Qualifier，比如使用不同的数据库源头时。</p><p>@Resource:直接按照bean的id注入，可以独立使用</p><p>以上三个只能进行其他bean类型的数据.<br>基本类型和String类型怎么注入？<br>    用value，有个属性value可以指定数据的值，可以使用spring的spEL表达式<br>        sPEL的写法：${表达式}<br>    用于改变作用范围的Scope<br>    value=singleton  or prototype</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; 基于Spring的常用注解IOC以及IOC的案例&lt;br&gt;     1.SpringIOC的常用注解&lt;br&gt;     2.案例使用xml方式和注解方式实现单表的CRUD操作&lt;br&gt;         持久层技术选择：dbutils&lt;br&gt;     3.改造基于注解的IOC案例，使用纯注解的方式实现&lt;br&gt;         Spring的一些新注解&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之mybatis中的一对多（多表）查询</title>
    <link href="http://example.com/2020/12/08/mybatis%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%A4%9A%E8%A1%A8%EF%BC%89%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/12/08/mybatis%E4%B8%AD%E7%9A%84%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88%E5%A4%9A%E8%A1%A8%EF%BC%89%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-12-08T13:17:38.623Z</published>
    <updated>2020-12-08T13:20:34.927Z</updated>
    
    <content type="html"><![CDATA[<p>mybatis中的一对多（多表）查询<br>  如果拿出每一个订单，他都只能属于一个用户。<br>  所以mybatis就把多对一看成一对一<br>  步骤;<br>      1.用户表和账户表:<br>          一个用户可以有多个账户<br>          一个账户只能属于一个用户<br>      2.建立两个实体类：用户实体类和账户实体类<br>          让用户和账户的实体类都能体现出一对多的关系<br>      3.建立两个配置文件<br>          用户配置文件<br>          账户配置文件<br>      4.实现配置<br>          当我们查询用户时，可以同时得到用户下所包含的账户信息<br>          当我们查询账户时，可以得到账户所属用户信息</p><a id="more"></a><pre><code>  怎么说呢？  学的sql语句没有卵用，还得在实际情况下面学！！！  你比如说account(账户的ID)有个外键就是（userid）  关联子查询：用很多次</code></pre><p>  column是代表从哪获取的</p><p>  一对多关系映射，主表实体应该包含在从表实体的集合引用</p><pre><code>private List&lt;Account&gt; accounts;public List&lt;Account&gt; getAccounts() &#123;    return accounts;&#125;public void setAccounts(List&lt;Account&gt; accounts) &#123;    this.accounts = accounts;&#125;写IuserDao.xml &lt;!-- 定义User的resultMap--&gt;&lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;    &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;    &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;    &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;    &lt;!-- 配置user对象中accounts集合的映射 --&gt;    &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;        &lt;id column=&quot;aid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;        &lt;result column=&quot;uid&quot; property=&quot;uid&quot;&gt;&lt;/result&gt;        &lt;result column=&quot;money&quot; property=&quot;money&quot;&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- 查询所有(修改一下sql语句) --&gt;&lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;    select * from user u left outer join account a on u.id = a.uid&lt;/select&gt;接下来直接查询，就可以将一个用户下的多个账户都查询出来。</code></pre><p> /**<br>     * 测试查询所有<br>     */<br>    @Test<br>    public void testFindAll(){<br>        List<User> users = userDao.findAll();<br>        for(User user : users){<br>            System.out.println(“—–每个用户的信息——“);<br>            System.out.println(user);<br>            System.out.println(user.getAccounts());<br>        }<br>    }</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;mybatis中的一对多（多表）查询&lt;br&gt;  如果拿出每一个订单，他都只能属于一个用户。&lt;br&gt;  所以mybatis就把多对一看成一对一&lt;br&gt;  步骤;&lt;br&gt;      1.用户表和账户表:&lt;br&gt;          一个用户可以有多个账户&lt;br&gt;          一个账户只能属于一个用户&lt;br&gt;      2.建立两个实体类：用户实体类和账户实体类&lt;br&gt;          让用户和账户的实体类都能体现出一对多的关系&lt;br&gt;      3.建立两个配置文件&lt;br&gt;          用户配置文件&lt;br&gt;          账户配置文件&lt;br&gt;      4.实现配置&lt;br&gt;          当我们查询用户时，可以同时得到用户下所包含的账户信息&lt;br&gt;          当我们查询账户时，可以得到账户所属用户信息&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之mybatis的连接池与事务控制（原理部分了解）</title>
    <link href="http://example.com/2020/12/08/mybatis%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2020/12/08/mybatis%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</id>
    <published>2020-12-08T13:10:07.062Z</published>
    <updated>2020-12-08T13:21:19.668Z</updated>
    
    <content type="html"><![CDATA[<p>1.mybatis的连接池与事务控制（原理部分了解）<br>    连接池的使用和分析<br>    mybatis事务控制的分析<br>2.mybatis基于xml配置的动态SQL语句使用<br>    mappers配置文件中的几个标签：</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;if&gt;</span><br><span class="line">&lt;whrere&gt;</span><br><span class="line">&lt;foreach&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryvo&quot;&gt;</span><br><span class="line">        &lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">                &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                    <span class="comment">#&#123;uid&#125;</span></span><br><span class="line">                &lt;/foreach&gt;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>3.mybatis中的多表操作（right/left join on ）<br>        一对多<br>        一对一（？）<br>        多对多<br>回顾：UserDao.xml 就是一个mapper层</p><p>我们实际开发过程中都会使用连接池<br>因为它可以减少我们获取连接所消耗的时间<br>1.pooled:采用传统的javax.sql.datasource的连接池，由明确规范<br>2.unpooled:传统的获取连接方式，并没有使用池的思想，没有容器的概念</p><p>事务的四大特性（mysql）<br>ACID：一个事务就是一个整体<br>原子性：不可分割<br>一致性：事务操作回滚不会破坏约束<br>隔离性：每个事务都是彼此独立，不会受其他事务的约束<br>持久性：事务提交之后对数据的修改是持久性的，数据修改依旧有效</p><p>隔离级别：脏读，幻读，不可重复读，可重复读</p><p>那我做小程序的时候<br>也可以在mapper层，设置if。（定向查找）<br>如果等于“某个id”,那么就直接返回这个id的所有内容，在配合上其他的条件，就在前端显示就完事儿</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;where&gt;</span><br><span class="line">      &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;</span><br><span class="line">            &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uid&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">                    <span class="comment">#&#123;uid&#125;</span></span><br><span class="line">           &lt;/foreach&gt;</span><br><span class="line">       &lt;/if&gt;</span><br><span class="line">&lt;/where&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindInIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">       QueryVo vo = <span class="keyword">new</span> QueryVo();</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       list.add(<span class="number">41</span>);</span><br><span class="line">       list.add(<span class="number">42</span>);</span><br><span class="line">       list.add(<span class="number">46</span>);</span><br><span class="line">       vo.setIds(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.执行查询所有方法</span></span><br><span class="line">       List&lt;User&gt; users = userDao.findUserInIds(vo);</span><br><span class="line">       <span class="keyword">for</span>(User user : users)&#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>筛选</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;</span><br></pre></td></tr></table></figure><p>提取重复代码！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.mybatis的连接池与事务控制（原理部分了解）&lt;br&gt;    连接池的使用和分析&lt;br&gt;    mybatis事务控制的分析&lt;br&gt;2.mybatis基于xml配置的动态SQL语句使用&lt;br&gt;    mappers配置文件中的几个标签：&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Mybatis传递的参数类型：</title>
    <link href="http://example.com/2020/12/08/Mybatis%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/12/08/Mybatis%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-12-08T13:03:38.106Z</published>
    <updated>2020-12-08T13:22:34.661Z</updated>
    
    <content type="html"><![CDATA[<p>Mybatis传递的参数类型：<br>    1.输入类型：parameterType<br>    （1）传递简单类型，传递pojo对象，传递pojo包装对象<br>        OGNL表达式：Object Graphic Navigation Language 对象图导航语言<br>        它是通过对象的取值方法来获取数据<br>        在写法上把get给省略了</p><a id="more"></a><pre><code>    比如:我们获取用户的名称。类中的写法：user.getUsername();                          OGNL表达式写法:user.username     mybatis中为什么能直接写username,而不用user.呢？        因为在parameterType中已经提供了属性所属的类，所以此时不需要写对象名（2）由多个对象组成一个实际的查询条件，可以使用包装对象，外面再套一层        （pojo对象）2.输出类型:resultType （1）int  (2)实体类  解决实体类属性和数据库列明不对应的问题  1.在sql语句的层面上起别名  2.配置查询结果的列名和实体类的属性名的对应关系  &lt;resultMap id =&quot;userMap&quot; type =&quot;com.itheima.domain.User&quot;&gt;       &lt;!--主键字段的对应--&gt;          &lt;id property=&quot;userId&quot; column =&quot;id&quot; &gt;&lt;/id&gt; 前面是从实体类导入的，后面是对应数据库的字段          &lt;!--非主键的对应--&gt;          &lt;result property =&quot;userName&quot; column =&quot;username&quot;&gt;&lt;/result&gt;  &lt;/resultMap&gt;  改完以后所有sql语句的resultType都得改成resultMap，而且id值必须对应</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mybatis传递的参数类型：&lt;br&gt;    1.输入类型：parameterType&lt;br&gt;    （1）传递简单类型，传递pojo对象，传递pojo包装对象&lt;br&gt;        OGNL表达式：Object Graphic Navigation Language 对象图导航语言&lt;br&gt;        它是通过对象的取值方法来获取数据&lt;br&gt;        在写法上把get给省略了&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JSON</title>
    <link href="http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/"/>
    <id>http://example.com/2020/12/01/JSON%E5%B0%8F%E5%B7%A7%E8%BD%BB%E4%BE%BF%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%96%87%E6%9C%AC/</id>
    <published>2020-12-01T10:20:12.365Z</published>
    <updated>2020-12-01T10:21:52.235Z</updated>
    
    <content type="html"><![CDATA[<p>json<br>W3school<br>JSON 是存储和交换文本信息的语法<br>比xml更小，更方便</p><a id="more"></a><p>语法：<br>1.基本规则<br>数据在名称/值对中：由键值对构成。<br>    *键用引号引起来，也可以不使用引号；<br>    *值的取值类型：数字（整数或浮点数）<br>        a.字符串（在双引号中）<br>        b.逻辑值（true 或 false）<br>        c.数组（在方括号中）如：{“persons”:[{},{}]}<br>        d.对象（在花括号中）如：{“address”:{“province”:”陕西”…}}<br>        e.null<br>数据由逗号分隔：多个键值对由逗号分隔<br>花括号保存对象：使用{}定义json格式<br>方括号保存数组<br>2.获取数据<br> *使用json对象.键名<br> *json对象[“键名”]<br> *数组对象[]</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>json数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//1.定义基本格式</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> person =&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(person)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// for(var key in person)&#123;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//     alert(key+&quot;:&quot;+person[key]);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式： 数组[]----&gt;&#123;&#125;Json对象里面有数组</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> persons= &#123;<span class="string">&quot;psersons&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">                                &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;]&#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(persons);</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">//嵌套格式&#123;&#125;--&gt;[]本身就是数组，里面存放json对象</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ps=[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">24</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;,</span></span><br><span class="line"><span class="javascript">            &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">21</span>,<span class="string">&quot;gender&quot;</span>:<span class="literal">true</span>&#125;];</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(ps);</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ps.length;i++</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p =ps[i];</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> key <span class="keyword">in</span> p</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(key+<span class="string">&quot;:&quot;</span>+p[key]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p> Json当做数据的载体，转换为java对象（可以转换为任何对象）</p><p> 1.java转换成JSON<br>  json解析器：jsonlab,Gson,fastjson,jsckson(springmvc)<br> .使用步骤：<br> *导入jackson的相关jar包<br> *创键jackson核心对象ObjectMapper<br> *调用ObjectMapper的WriteValue方法来进行转换</p><p> 2.JSON 转换为 java<br>  readvalue(json,class对象)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package JSON.test;</span><br><span class="line"></span><br><span class="line">import JSON.domain.Person;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Jackson &#123;</span><br><span class="line"></span><br><span class="line">    //java对象转为JSON字符串1.字符串2.键：数组3 数组</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() throws IOException &#123;</span><br><span class="line">        //1.创建几个Person对象</span><br><span class="line">        Person p =new Person();</span><br><span class="line">        p.setName(&quot;张山&quot;);</span><br><span class="line">        p.setAge(23);</span><br><span class="line">        p.setGender(&quot;男&quot;);</span><br><span class="line">        //2.创建Jackson的核心对象  ObjectMapper</span><br><span class="line">        ObjectMapper mapper =new ObjectMapper();</span><br><span class="line">        //3.转换</span><br><span class="line">        /**</span><br><span class="line">         * 转换方法：</span><br><span class="line">         * writevalue (参数1,obj):</span><br><span class="line">         *      参数1：</span><br><span class="line">         *        File:将obj对象转换成JSON字符串，并保存到指定文件中</span><br><span class="line">         *        Writer:将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</span><br><span class="line">         *        OutputStream；将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</span><br><span class="line">         * writeValueAsString(obj):将对象转换为json</span><br><span class="line">         */</span><br><span class="line">        String json = mapper.writeValueAsString(p);</span><br><span class="line">        //System.out.println(json);</span><br><span class="line">        mapper.writeValue(new FileWriter(&quot;/Users/chenwangxin/Desktop/a.txt&quot;),p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        //1.初始化JSON字符串</span><br><span class="line">        String json =&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;age\&quot;:23,\&quot;gender\&quot;:true&#125;&quot;;</span><br><span class="line">        //2.创建objectMapper</span><br><span class="line">        ObjectMapper  ob =new ObjectMapper();</span><br><span class="line">        //3.调用readValue()</span><br><span class="line">        Person person=ob.readValue(json,Person.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;json&lt;br&gt;W3school&lt;br&gt;JSON 是存储和交换文本信息的语法&lt;br&gt;比xml更小，更方便&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JQUERY实现AJAX</title>
    <link href="http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/12/01/AJAX%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-01T10:11:57.504Z</published>
    <updated>2020-12-01T10:22:36.994Z</updated>
    
    <content type="html"><![CDATA[<p>JQUERY实现AJAX:</p><p>AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML<br>1.异步和同步  客户端和服务器端同步通信的基础上<br>2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术<br>提升用户的体验</p><a id="more"></a><p>实现方式：<br>JQuery实现方式<br>1.$.ajax()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//使用$.ajax()发送异步请求</span></span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;ajaxServlet&quot;</span>,<span class="comment">//请求路径</span></span></span><br><span class="line"><span class="javascript">                type:<span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">                    alert(data)</span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//响应成功后的回调函数</span></span></span><br><span class="line"><span class="javascript">                error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;出错啦。。&quot;</span>)</span></span><br><span class="line"><span class="javascript">                &#125;,<span class="comment">//请求响应失败会执行回调函数</span></span></span><br><span class="line"><span class="javascript">                dataType:<span class="string">&quot;text&quot;</span><span class="comment">//设置接受到的响应数据的格式</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.$.get()：发送get请求<br>    参数：<br>    url:请求路径<br>    data:请求参数<br>    callback:回调函数<br>    type：响应结果的类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//定义方法</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">         $.get(<span class="string">&quot;ajaxServlet&quot;</span>,&#123;<span class="attr">username</span>:<span class="string">&quot;rose&quot;</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line">             alert(data);</span><br><span class="line"><span class="javascript">         &#125;,<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.$.post()：发送post请求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JQUERY实现AJAX:&lt;/p&gt;
&lt;p&gt;AJAX :ASynchronous JavaScript And XML 异步的JavaScript 和 XML&lt;br&gt;1.异步和同步  客户端和服务器端同步通信的基础上&lt;br&gt;2.在异步的条件下，在无需加载整个网页的情况下，更新部分网页的技术&lt;br&gt;提升用户的体验&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Jquery</title>
    <link href="http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/"/>
    <id>http://example.com/2020/12/01/JQUERY%E7%AE%80%E8%A7%A3/</id>
    <published>2020-12-01T10:08:20.626Z</published>
    <updated>2020-12-01T10:23:05.575Z</updated>
    
    <content type="html"><![CDATA[<p>Jquery是一个优秀的js框架<br>优化了DOM的操作，事件处理、动画设计、Ajax交互<br>JQuery对象和JS对象区别与转换？<br>divs.html(“bbb”)<br>jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）</p><a id="more"></a><p>转换一下：js—&gt;jq: $(js对象) 就可以转换了<br>             jq—&gt;js: jq对象[索引]或者jq对象.get(索引)<br>选择器:筛选具有相似特征的元素（标签）<br>//jquery入口函数（dom文档加载完成之后执行入口函数）<br>        $(function () {<br>            //$(“#div1”).css(“background-color”,”red”);<br>            $(“#div1”).css(“backgroundColor”,”pink”);</p><pre><code>    &#125;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Jquery是一个优秀的js框架&lt;br&gt;优化了DOM的操作，事件处理、动画设计、Ajax交互&lt;br&gt;JQuery对象和JS对象区别与转换？&lt;br&gt;divs.html(“bbb”)&lt;br&gt;jquery与js方法不通用！！（获取的jq对象本来就是类似于数组一般的存在）&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之HTTPServlet的解释</title>
    <link href="http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>http://example.com/2020/11/27/HTTPServlet%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2020-11-27T10:40:41.376Z</published>
    <updated>2020-11-27T10:43:47.033Z</updated>
    
    <content type="html"><![CDATA[<p>将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象<br>将来定义servlet类时，可以继承GenericServlet，实现service()方法即可</p><a id="more"></a><p>HTTPServlet（有七种解决方式）<br>不用再去判断请求方式，对http协议的一种封装<br>复写doGet(){}方法，浏览器直接请求是get方式<br>复写doPost(){}方法，表单请求是POST方式</p><p>注解配置<br>ServletDemo4<br>一个Servlet可以定义多个访问路径<br>路径定义规则：</p><ol><li> /xxx</li><li> /xxx/xxx:多层路径,目录结构</li><li> *.do<br>调用Servlet，就可以将自己的信息提交到后台了</li></ol><p>基于TCP/IP的高级协议<br>端口号：80<br>基于请求响应模型，一次请求一次响应<br>无状态：每次请求相互独立，不能交互数据</p><p>向服务器发送请求，js  css 图片  都是单独的请求。<br>1.0：每一次请求都会建立新的连接<br>1.1：复用连接（建立连接后，请求完gif图片，等一会儿，没有数据发送了，连接释放掉）</p><p>请求消息数据格式<br>1.请求行<br>2.请求头<br>3.请求空行<br>4.请求体</p><p>请求的是谁？是客户端</p><p>响应消息数据格式<br>GET:1.请求参数在请求行中，在url后  2.请求的url长度有限制  不安全<br>POST: 请求参数在请求体中 2.url长度没有限制，比如文件上传等大文件只能用post</p><p>请求头：浏览器告诉了服务器我个人的一些信息啊<br>告诉服务器使用的浏览器版本信息，可以解决兼容性的问题</p><p>Request:<br>原理：1.tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo的对象<br>2.tomcat服务器，会创建request和response对象，request对象中封装请求消息数据<br>3.tomcat将request和response两个对象传递给Service方法，并且调用service方法<br>代码如下：<br>@WebServlet(“/demo1”)<br>public class ServletDemo1 implements Servlet{<br>    service(servletRequest,servletResponse){<br>    4.程序员可以通过request对象获取请求数据消息，通过response对象设置响应消息数据<br>    }<br>}<br>5.服务器回传响应消息会从response对象中拿程序员设置的响应消息格式、</p><p>继承体系结构：<br>tomcat创建的</p><p>功能：<br>       //1.获取请求方式： GET<br>        String method =req.getMethod();<br>        System.out.println(method);<br>        //2.(*)获取虚拟目录页<br>        String contextPath=req.getContextPath();<br>        System.out.println(contextPath);<br>        //3.获取Servlet路径 ：/demo1<br>        String servletPath=req.getServletPath();<br>        System.out.println(servletPath);<br>        //4.获取get方式请求参数:name=zhangsan<br>        String queryString=req.getQueryString();<br>        System.out.println(queryString);<br>        //5.获取请求URL<br>        String requesURI=req.getRequestURI();<br>        StringBuffer requestURL =req.getRequestURL();<br>        System.out.println(requesURI);<br>        System.out.println(requestURL);<br>        //6.客户的协议和版本<br>        String protocol=req.getProtocol();<br>        System.out.println(protocol);<br>        //7.获取客户机的IP<br>        String remoteAddr=req.getRemoteAddr();<br>        System.out.println(remoteAddr);</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将Servlet接口中的其他的方法做了默认空实现，只将service()方法作为抽象&lt;br&gt;将来定义servlet类时，可以继承GenericServlet，实现service()方法即可&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之JDBC快速抽取工具类</title>
    <link href="http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2020/11/27/JDBC%E5%BF%AB%E9%80%9F%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-27T10:33:21.969Z</published>
    <updated>2020-11-27T10:44:37.774Z</updated>
    
    <content type="html"><![CDATA[<p>jdbc抽取工具类<br>1.注册驱动抽取<br>2.连接对象方法抽取<br>3.释放资源方法抽取</p><a id="more"></a><p>不想传递参数，还得保证工具类的通用性，<br>解决:配置文件<br>src目录下面：<br>public class JDBCUtils{<br>   private static String url;<br>   private static String user;<br>   private static String password;<br>   private static String driver;<br>    文件的读取，只需要读取一次即可拿到这些值，使用静态代码块<br>    static{<br>    1.创建Properties集合类<br>       properties pro =new  properties();<br>    获取src路径下的文件的方式–&gt;ClassLoader类加载器<br>    ClassLoader classloader =JDBCUtils.class.getClassLoader();<br>    URL res =classLoader.getResource(jdbc.properties);<br>    String path =res.getPath();</p><pre><code>2.加载文件  //pro.load(new FileReader(fileNmae:&quot;src/jdbc.properties&quot;));   pro.load(path); 3.获取数据，赋值  url =pro.getProperty(&quot;url&quot;);  user =pro.getProperty(&quot;user&quot;);  password =pro.getProperty(&quot;password&quot;);  driver=pro.getProperty(&quot;driver&quot;);4.获取驱动  Class.forName(&quot;driver&quot;);&#125;</code></pre><p>}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;jdbc抽取工具类&lt;br&gt;1.注册驱动抽取&lt;br&gt;2.连接对象方法抽取&lt;br&gt;3.释放资源方法抽取&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决小伙伴们深度学习时模型训练的硬件问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E4%BC%99%E4%BC%B4%E4%BB%AC%E4%BD%BF%E7%94%A8YOLOv3%E8%AE%AD%E7%BB%83%E6%97%B6%E7%9A%84%E7%A1%AC%E4%BB%B6%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T09:01:35.461Z</published>
    <updated>2020-11-25T09:19:54.219Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习YOLOv3来训练voc模型<br>可想而知一个15年的mac或者老版本的Windows电脑难堪重负。<br>在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！<br><img src="https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。<br>几番抉择后，选择了滴滴云服务器,因为价格！！！<br><a href="https://www.didiyun.com/">https://www.didiyun.com</a></p><a id="more"></a><p>一、大家可以使用云服务器（带GPU）,我顺便搞了个大师码：8996，还给打了⑨折<br>而且最重要的是他家的时间 是按照你用的时间算，你结束时它不会给你计费，意思说你按小时买也特别划算，经济实惠。<br><img src="https://img-blog.csdnimg.cn/20201125163558908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201125164349470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>注：大家如果使用云服务器训练。可以参考这篇博文：<br><a href="https://blog.csdn.net/ForeeverF/article/details/103651924%EF%BC%8C%E6%91%98%E8%87%AA">https://blog.csdn.net/ForeeverF/article/details/103651924，摘自</a> Byronnar博主<br>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</p><p>需要自己配置环境</p><p>二、还可以使用network，这个就很香，你可以直接跑<br><img src="https://img-blog.csdnimg.cn/20201125164852326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020112516504538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我买个4核处理器的GPU云算力，一小时才三块钱，就可以运行我的项目，还不用担心自己电脑宕机，而我们的所有代码操作都可以在本机上操作，将其利用，具体操作请参考。<br><a href="https://help.didiyun.com/hc/kb/section/1151520/">https://help.didiyun.com/hc/kb/section/1151520/</a><br>三、接下来附上我的学习路径，供大家参考<br><strong>这位大佬讲得特别好，利用VOC2012的训练集训练</strong><br>具体代码以及步骤：<a href="https://github.com/cwxprogrammer/deep-learning-for-image-processing.git">https://github.com/cwxprogrammer/deep-learning-for-image-processing.git</a></p><p>视频理论讲解：<br><a href="https://www.bilibili.com/video/BV1yi4y1g7ro?p=1">https://www.bilibili.com/video/BV1yi4y1g7ro?p=1</a><br>源码讲解：<br><a href="https://www.bilibili.com/video/BV1t54y1C7ra?t=250">https://www.bilibili.com/video/BV1t54y1C7ra?t=250</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习YOLOv3来训练voc模型&lt;br&gt;可想而知一个15年的mac或者老版本的Windows电脑难堪重负。&lt;br&gt;在学完理论准备操刀开始部署训练时，才发现GPU是个大难题，而本人是个穷学生，哪有那么多钱买那么贵的显卡！！！&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201125163104563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以我决定启用带GPU的服务器，将我的所有东西都通过云端来搞定训练。&lt;br&gt;几番抉择后，选择了滴滴云服务器,因为价格！！！&lt;br&gt;&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>解决部署前后端分离时运行内存太小的问题</title>
    <link href="http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/11/25/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%A8%E7%BD%B2%E7%B1%BB%E4%BC%BCRUOYI%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%94%B5%E8%84%91%E5%86%85%E5%AD%98%E5%A4%AA%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T07:55:10.290Z</published>
    <updated>2020-11-25T09:18:39.425Z</updated>
    
    <content type="html"><![CDATA[<p>我们通常都会用前后端分离部署我们的项目<br>1.需要使用虚拟机<br>2.内存不够用（因为每个虚拟机最少需要2G内存）<br>3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响<br>4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天</p><p>我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201125155056501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>会自动给你IP<br><img src="https://img-blog.csdnimg.cn/20201125155237451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>重点：我发现云服务器恰好解决了我的燃眉之急，解决了我囊中羞涩不能买高配电脑的痛苦。</p><p>我用的是滴滴云服务器，便宜。<br>你租一个云服务器，自带centos7.6<br>才不到几毛钱。<br>而且买时长，你只要关了就不算时长，很nice。</p><p>解决了硬件问题<br>具体部署视频羊哥已经讲得很详细了：<br>贴个视频链接：<br><a href="https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710">https://www.bilibili.com/video/BV1uK411p7Bp?from=search&amp;seid=12561435874039764710</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们通常都会用前后端分离部署我们的项目&lt;br&gt;1.需要使用虚拟机&lt;br&gt;2.内存不够用（因为每个虚拟机最少需要2G内存）&lt;br&gt;3.勉强装上两个虚拟机后，电脑黑屏，风扇狂响&lt;br&gt;4.最烦人的是CENTOS7安装不成功或者不会安装，查教程又是一天&lt;/p&gt;
&lt;p&gt;我仔细研究了B站CodeSheep（羊哥）前后端部署视频之后，发现它的两个虚拟机相当于另外两台不同IP的lunix电脑。只要输入IP利用xftp软件连入那台lunix主机，我不就可以进行前后端分离部署！！！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>目标检测②传统检测算法</title>
    <link href="http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2020/11/24/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AF%BE%E7%A8%8B%EF%BC%9A%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E2%91%A1%E4%BC%A0%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-11-24T05:49:55.278Z</published>
    <updated>2020-11-24T05:58:14.207Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测实验报告</strong><br>检测所用软硬件+云服务器：<br>硬件：macOS或者windows电脑<br>软件：pycharm+生成的测试集<br>云服务器：滴滴云(<a href="https://www.didiyun.com/">https://www.didiyun.com</a>)<br>输入博主的大师码：8996 ，可以和博主一样9折享受服务</p><p><strong>什么是传统目标检测？</strong><br>首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？<br>传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器</p><a id="more"></a><p>即首先在给定的图像上选择一些候选的区域，然后对这些区域提取特征，最后使用训练的分类器进行分类。下面我们对这三个阶段分别进行介绍</p><p>2.2.1区域选取<br>这一步是为了对目标的位置进行定位。由于目标可能出现在图像的任何位置，而且目标的大小、长宽比例也不确定，所以最初采用滑动窗口的策略对整幅图像进行遍历，而且需要设置不同的尺度，不同的长宽比。这种穷举的策略虽然包含了目标所有可能出现的位置，但是缺点也是显而易见的：时间复杂度太高，产生冗余窗口太多，这也严重影响后续特征提取和分类的速度和性能。（实际上由于受到时间复杂度的问题，滑动窗口的长宽比一般都是固定的设置几个，所以对于长宽比浮动较大的多类别目标检测，即便是滑动窗口遍历也不能得到很好的区域）</p><p>2.2.2特征的设计<br>传统检测方法的特征提取算法主要有两种:HOG特征和lbp算法<br>HOG：方向梯度直方图（Histogram of Oriented Gradient, HOG）。使用梯度直方图来描述的形状特征。主要在行人检测方面。从名字可知，主要将图像中的pixel的方向变化作为特征。因为梯度变化主要是发生在物体边缘，这样就可以知道物体的大致形状。可以进行物体分类或者检测。经典的特征提取一般需要一些超参，比如窗口大小等。<br>提取方法：讲一个image灰度化—&gt;颜色空间的标准化—&gt;计算图像每个像素的梯度        —&gt;将图像划分成小cells—&gt;统计每个cell的梯度直方图    —&gt; 将每几个cell组成一个block—&gt;将图像image内的所有block的HOG特征descriptor串联起来。                                                                                       Lbp算法：LBP（Local Binary Pattern，局部二值模式），反映了局部的纹理特征，跟一个像素的邻域有关。对每个像素的邻域做减法，大于用1表示，否则用0表示则产生了一个二进制数来表示这个像素的局部纹理。这个邻域其实也相当于一个window，window的形状也是可以改变的。</p><p>2.2.3分类器的设计<br>一、利用AdaBoost算法进行训练<br>并不是所有特征都是有用的，AdaBoost特征分类器具有特征选择的能力。<br>AdaBoost 将一系列的弱分类器通过线性组合，构成一个强分类器，<br>如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20201124101332709.gif#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201124101404821.gif#pic_center" alt="在这里插入图片描述"><br>是一个强分类器。</p><p><img src="https://img-blog.csdnimg.cn/2020112410144766.gif#pic_center" alt="在这里插入图片描述">是一个弱分类器，其为一个简单的阈值函数<br><img src="https://img-blog.csdnimg.cn/20201124101601130.gif#pic_center" alt="在这里插入图片描述">为阈值，<br><img src="https://img-blog.csdnimg.cn/20201124101640957.gif#pic_center" alt="在这里插入图片描述">，<br><img src="https://img-blog.csdnimg.cn/20201124101705301.gif#pic_center" alt="在这里插入图片描述">为系数。</p><p>二、训练弱分类器<br>计算所有训练样本的特征值，并将其从小到大排序，随机选取一个特征值作为阈值，把所有元素分为两部分，小于阈值的一部分分类为人脸，大于阈值的一部分分类为非人脸。如下图所示，红色表示人脸，蓝色表示非人脸。</p><p>假如有5个样本，前两个为人脸，后三个为非人脸，用11000表示。如果阈值在第一个之前，通过弱分类器判定为：00000，有两个误差，如果阈值在第一个和第二个之间，通过弱分类器判定为：10000，有1个误差，如果阈值在第二个和第三个之间，通过弱分类器判定为：11000，有0个误差，依次类推，这样共有6个误差，然后从中找到一个误差最小的当成阈值，这样就训练好了一个最优的弱分类器。</p><p><img src="https://img-blog.csdnimg.cn/20201124101841712.gif#pic_center" alt="在这里插入图片描述"><br>三、训练强分类器<br>假设有N个训练样本</p><p><img src="https://img-blog.csdnimg.cn/20201124101922423.gif#pic_center" alt="在这里插入图片描述"><br>,其中有M个正样本，L个负样本，如果<img src="https://img-blog.csdnimg.cn/20201124102024949.gif#pic_center" alt="在这里插入图片描述"></p><p>是人脸图像，则<img src="https://img-blog.csdnimg.cn/20201124102039875.gif#pic_center" alt="在这里插入图片描述"></p><p>, 否则<img src="https://img-blog.csdnimg.cn/20201124102051958.gif#pic_center" alt="在这里插入图片描述"></p><p>其步骤如下：<img src="https://img-blog.csdnimg.cn/20201124102108830.gif#pic_center" alt="在这里插入图片描述"></p><p>每一级分类器使用的训练集中的负样本，都是上一级被错分的，即false positive，误检率或假阳性。这使得下一级分类器更加关注那些更难的（容易被错分的）样本。</p><p>2、2、4 总结：<br>传统检测历史久远，然而一直以来存在着两个主要问题：<br>1）基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余<br>2）手工设计的特征对于多样性的变化没有很好的鲁棒性</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测实验报告&lt;/strong&gt;&lt;br&gt;检测所用软硬件+云服务器：&lt;br&gt;硬件：macOS或者windows电脑&lt;br&gt;软件：pycharm+生成的测试集&lt;br&gt;云服务器：滴滴云(&lt;a href=&quot;https://www.didiyun.com/&quot;&gt;https://www.didiyun.com&lt;/a&gt;)&lt;br&gt;输入博主的大师码：8996 ，可以和博主一样9折享受服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是传统目标检测？&lt;/strong&gt;&lt;br&gt;首先我们先来了解一下什么是目标检测？简单来说就是把存在的目标从图片中找到并识别出来。我们发现这对于我们人来说十分简单，但对于计算机而言，它是怎么做到的呢？&lt;br&gt;传统目标检测方法分为三部分：区域选择 → 特征提取 → 分类器&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
