<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-04T12:40:48.423Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日深耕，勤练不缀之sql99连接查询</title>
    <link href="http://example.com/2020/11/04/sql99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/04/sql99%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-04T12:37:47.709Z</published>
    <updated>2020-11-04T12:40:48.423Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a></p><p><strong>交叉连接</strong>（92中的笛卡尔积）<br>在这里我们使用的是CROSS JOIN<br>代码如下</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure><p>三张表的交叉连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> team_score</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104190150569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>自然连接</strong>（相当于92的等值连接）<br>在92中我们得自己判定两张表相同的属性是什么，而在99中利用 NATURAL JOIN 替代了 WHERE player.team_id=team.team_id<br>会帮你自动查询两张表中所有相同的字段，然后进行等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id ,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player </span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> team</span><br></pre></td></tr></table></figure><p><strong>ON连接</strong>（用来指定我们想要的连接条件）<br>进行等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player.team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team</span><br><span class="line"><span class="keyword">ON</span> player.team_id =team.team_id</span><br></pre></td></tr></table></figure><p>进行非等值连接<br>想要查询球员的身高等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.player_id,a.player_name,a.height,b.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a <span class="keyword">JOIN</span> height_grades <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.height <span class="keyword">BETWEEN</span> b.height_lowest <span class="keyword">AND</span> b.height_highest</span><br></pre></td></tr></table></figure><p><strong>using连接</strong><br>因为自然连接会自动查询相同字段进行连接，我们我们想指定相同字段连接时就得用using</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">USING</span>(team_id)</span><br></pre></td></tr></table></figure><p><strong>外连接</strong></p><p>左外链接<br>右外连接<br>全外连接在mysql中不支持</p><p>内连接：等值连接（自然连接，using连接，ON连接），非等值连接（ON连接）<br>外连接：会返回一个表中的所有记录，以及另一个表中匹配的行，左外连接，右外连接</p><p><strong>SQL99与SQL92的区别</strong><br>SQL92会在from后面放所有表<br>SQL99会放在join后面，每次连接一张表，可以多次使用join连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1和table2的连接条件</span><br><span class="line">        <span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2和table3的连接条件</span><br></pre></td></tr></table></figure><p>查询不同身高级别（对应height_grades）对应的球员数量（对应player表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(player.player_id),b.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> height_grades <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> player.height <span class="keyword">BETWEEN</span> b.height_lowest <span class="keyword">AND</span> b.height_highest</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> b.height_level</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201104203514926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交叉连接&lt;/strong&gt;（92中的笛卡尔积）&lt;br&gt;在这里我们使用的是CROSS JOIN&lt;br&gt;代码如下&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之如何保证集合是线程安全的？</title>
    <link href="http://example.com/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F/"/>
    <id>http://example.com/2020/11/04/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F/</id>
    <published>2020-11-04T09:55:45.658Z</published>
    <updated>2020-11-04T09:55:45.659Z</updated>
    
    <content type="html"><![CDATA[<p>java基本容器工具<br>前面两篇说的是Java容器类，大部分都不是线程安全的</p><p>如何保证集合是线程安全的、？<br>java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等内容容器，还提供了所谓的同步包装器（Synchronnized Wrapper),我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap）,但是他们都利用的粗粒度的同步方式，在高并发情况下，性能比较低下</p><p>更加普遍的选择是利用并发包提供的线程安全容器类，</p><a id="more"></a><p>它提供了：</p><ul><li>各种并发器，比如ConcurrentHashMap,CopyWriteArrayList.</li><li>各种线程安全队列（Queue/Deque）,如ArrayBlockingQueue、SynchronousQueue</li><li>各种有序容器的线程安全版本</li></ul><p>从简单的synchronized方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现<br>总体来说，并发包提供的容器通用场景，远远优于早期</p><p><strong>线程安全和并发的深入考察</strong><br>需要四个方面的解答<br><strong>1.理解基本的线程安全工具</strong><br><strong>2.理解传统集合框架并发编程中Map存在的问题，清楚简单的同步方式的不足</strong><br><strong>3.梳理并发包内，尤其是ConcurrentHashMap采取了哪些方法来提高并发的表现</strong><br><strong>4.最好能掌握ConcurrentHashMap自身的演进</strong></p><p>Hashtable本身比较低效，因为它的实现基本就是将put、get、size等各种方法加上”synchronized”.简单来说，这就导致了所有并发程序都要争一把锁，一个线程进行同步操作时，其他职能等待，导致CPU占用100%的问题。<br>那我们能不能用Collections提供的同步包装器来解决问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronized</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m; <span class="comment">//Backing Map</span></span><br><span class="line"> <span class="keyword">final</span> Object mutex; <span class="comment">//Object on which to synchronized</span></span><br><span class="line"> <span class="comment">//..</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">    <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们发现同步包装器只是利用输入Map构造了另一个同步版本，所有操作虽然不再声明成为Synchronized方法，但还是利用了”this”作为互斥的mutex,无真正意义上的改进。<br>所以，同步包装版本，还是很难适合在高并发场景中</p><p>2.ConcurrentHashMap分析<br>早期ConcurrentHashMap，其实现是基于：</p><ul><li>分离锁，也就是将内部进行分段，里面则是HashEntry的数组，和HashMap类似，哈希值相同的条目也是以链表形式存放</li><li>HashEntry内部使用volatile的value字段来保证可见性，也利用了不可变对象的机制以改进利用Unsafe提供的底层能力，比如volatile access,去直接完成部分操作，以优化性能<br><img src="https://img-blog.csdnimg.cn/20201104161404841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><p>在构造的时候，Segment的数量由所谓的concurrentcyLevel决定，默认是16，也可以在相应构造函数直接指定。注意，Java需要它是2的幂数值，如果输入时类似15这种非幂值，会被自动调整到16</p><p>老版的jdk7 会通过这种方式，下面是get代码，get需要保证的是可见性，所以并没有什么同步逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line"> Segment&lt;K,V&gt; s;</span><br><span class="line"> HashEntry&lt;K,V&gt;[]tab;</span><br><span class="line"> <span class="keyword">int</span>  h=hash(key.hashCode());</span><br><span class="line"> <span class="keyword">long</span> u =(((h&gt;&gt;&gt;segmentShift)&amp;segmentMask)&lt;&lt; SSHIFT)+SBASE;</span><br><span class="line"> <span class="comment">//以segment为单位，进行定位</span></span><br><span class="line"> <span class="comment">//利用Unsafe直接进行volatile access</span></span><br><span class="line"> <span class="keyword">if</span>((s=(Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(setments,u))!=<span class="keyword">null</span>&amp;&amp;(tab =s.table)!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="comment">//省略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>相对于put操作，通过二次哈希避免冲突<br>然后以Unsafe调用方式，直接获取相应的Segment,然后进行线程安全的put操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">  Segment&lt;K,V&gt; s;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span>  NullPointerException</span><br><span class="line">    <span class="comment">//二次哈希，以保证数据的分散性，避免哈希冲突</span></span><br><span class="line">  <span class="keyword">int</span> hash =hash(key.hashCode());</span><br><span class="line">  <span class="keyword">int</span> j =(hash &gt;&gt;&gt;segmentShift)&amp;segmentMask;</span><br><span class="line">  <span class="keyword">if</span>((s =(Segment&lt;K,V&gt;)UNSAFE.getObject(segments,(j &lt;&lt; SSHIFT) + SBASE))==<span class="keyword">null</span>)</span><br><span class="line">  s=ensureSegment(j);</span><br><span class="line">  <span class="keyword">return</span> s.put(key,hash,value,<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其核心实现的逻辑是下面的内部方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// scanAndLockForPut会去查找是否有key相同Node</span></span><br><span class="line">            <span class="comment">// 无论如何，确保获取锁</span></span><br><span class="line">   HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">// 更新已有value...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 放置HashEntry到特定位置，如果超过阈值，进行rehash</span></span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在进行并发写操作时：<br>ConcurrentHashMap会获取再入锁，以保证数据一致性，Segment本身就是基于ReentrantLock的扩展实现，所以在并发修改期间，Segment是被锁定的</p><p>在最初阶段，进行重复性的扫描，以确定相应key值是否已经在数组里面，进而决定是更新还是放置。重复扫描，检测冲突是ConcurrentHashMap的常见技巧</p><p>扩容是单独给Segment扩容</p><p>Map的size方法同样需要关注，它的实现涉及分离锁的副作用，如果不进行同步，简单的计算所有Segment的总值，可能会因为并发put,导致结果不准确，但是直接锁定所有Segment进行计算，会很昂贵。<br>所以，ConcurrentHashMap的实现是通过重试机制<br>（RETRIES_BEFORE_LOCK,指定重试次数2），获取可靠值，如果没有监控到没有发生变化，直接返回。如果监控到变化，获取锁进行操作</p><p><strong>java8以后的ConcurrentHashMap</strong></p><p>总体结构上，它的内部结构与HashMap结构非常相似<br>桶（bucket）数组，然后内部也是一个个链表结构（bin）<br>具体看图<br><img src="https://img-blog.csdnimg.cn/20201104171559549.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>同步的力度更细致一些<br>内部仍有segment定义，为了保证序列化的兼容性，无作用<br>不使用segment,修改为lazy-load<br>数据存储利用volatile保证可见性(声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步)<br>使用了CAS操作，在特定场景进行无锁并发<br>AtomicLong满足大部分性能要求</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;java基本容器工具&lt;br&gt;前面两篇说的是Java容器类，大部分都不是线程安全的&lt;/p&gt;
&lt;p&gt;如何保证集合是线程安全的、？&lt;br&gt;java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等内容容器，还提供了所谓的同步包装器（Synchronnized Wrapper),我们可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap）,但是他们都利用的粗粒度的同步方式，在高并发情况下，性能比较低下&lt;/p&gt;
&lt;p&gt;更加普遍的选择是利用并发包提供的线程安全容器类，&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之ArrayList,LinkedList,Vector的区别?</title>
    <link href="http://example.com/2020/11/04/ArrayList,LinkedList,Vector%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2020/11/04/ArrayList,LinkedList,Vector%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2020-11-04T06:17:04.945Z</published>
    <updated>2020-11-04T06:17:04.946Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList,LinkedList,Vector的区别?<br>高效的管理和操作数据</p><ul><li>三者都是集合框架里的list，即所谓的有序集合。</li><li>  按照位置进行定位，添加和删除的操作  </li><li>都提供<strong>迭代器</strong>以遍历其内容<a id="more"></a>Vector是Java早期的线程安全动态数组，通过我们不断地积累学习（StringBuffer ,StringBuilder,String）,都会知道线程安全有额外开销。<br>Vector内部是使用对象数组来保存数据，根据需要自动增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据</li></ul><p>ArrayList是应用更广泛的动态数组实现，它本身不是线程安全的，性能相对好很多，也可以根据需要调整容量，不过Vector调整一倍，ArrayList增加50%</p><p>LinkedList 顾名思义，就是java提供的双向链表，他不需要调整容量，也不是线程安全的</p><p><strong>考点分析</strong><br><strong>面试官会考察不同容器类型适合的场景？</strong><br>       Vector 和ArrayList作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问，增删的话除非在尾部插入或者删除，其余性能很慢。<br>       而LinkedList作为双向链表，虽然有顺序，但是随机访问性能却是很差，因为其一个数据节点中不仅得存现有节点的数据信息，还得存下一节点的位置信息。<br>       但是增加或删除节点很快，因为不需将其余元素移位，只需将其相关联的位置信息修改就ok</p><p>所以在应用开发中，我们就得提前预估到，应用操作是偏向于访问操作，还是偏向于增删操作，可以有针对性的进行选择</p><p><strong>关于java集合框架？</strong><br>这方面如果展开问，有四个大问题：</p><ul><li>java集合框架的设计结构，至少要有一个整体印象</li><li>java提供的只要容器（集合和Map）类型，了解或掌握对应的<strong>数据结构，算法</strong>，思考具体技术选择</li><li>将问题扩展到性能、并发等领域</li><li>集合框架的演进和发展</li></ul><p>1.狭义的集合框架<br><img src="https://img-blog.csdnimg.cn/20201104112340810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>大家可以看到cellection是集合的根，然后展开提供了三大类集合：</p><ul><li>List ，也就是咱们今天学的有序集合，它提供了方便的访问，插入，删除等操作</li><li>set ，set是不允许重复元素且无序的，这是和List最明显的区别，我们日常开发中很多需要保证元素唯一性的场合都可以用set。在这里说一下，很多set的实现完全依赖于Map的实现，也就是相当于HashMap的马甲</li><li>Queue/Deque,则是java提供的标准队列结构的实现。除了集合的基本功能，它还支持先进先出，后进先出等行为。<br>除了前面提到的，我们还是以现实为例，了解基本特征和典型使用场景</li><li>TreeSet支持自然顺序访问，但是添加、删除、包含等操作相对低效（log(n)时间）</li><li>HashSet则是利用哈希算法，如果哈希散列正常，可以提供常数时间级别的添加、删除、包含等操作，但它不保证有序。</li><li>LinkedHashSet,内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作略低于HashSet，需要维护链表的开销。</li><li>在遍历元素时，HashSet性能受自身容量影响，所以初始化时，不要把初始容量设置太大。而LinkedHashSet遍历性能只和元素多少有关</li></ul><p>2.典型排序算法：内部排序（归并排序，交换排序（冒泡，快排），选择排序，插入排序）<br>外部排序：掌握利用内存和外部存储处理超大数据集，至少要了解过程和思路</p><p>考察算法不一定如何简单，比如：哪些算法是不稳定的（快排，堆排），思考稳定意味着什么？<br>对不同数据集，各种排序的最好和最差情况？<br>从某个角度进一步优化（比如空间占用，假设业务场景需要最小辅助空间，这个角度堆排序就比归并排序优异）</p><p>我们今天介绍的都不是线程安全的，对于java.util.concurrent里面的线程安全容器，后面会介绍</p><p>并不代表这些集合不能支持并发编程的场景，在Collections工具类里，提供了一系列synchronized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span>;</span><br></pre></td></tr></table></figure><p>我们完全可以利用类似方法实现基本的线程安全集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list =collectins.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure><p>它的实现，基本上就是将每个基本方法，比如<br>get,set,add之类，都通过synchronized添加基本的同步支持。<br>注意：这些方法创建的线程安全集合，都符合迭代时fail-fast行为，当发生意外的<strong>并发修改时</strong>，尽早抛出ConcurrentModificationException异常，以避免不可预计的损失</p><p><strong>Java集合默认的排序算法是什么？具体呢？能否解释一下排序方式和设计思路？</strong></p><p>其实说出这句话的面试官都是大佬！！！<br>他想让你解释一下多种情况<br>因为你需要区分是Arrays.sort()还是Collections.sort()<br>(底层是调用Array.sort());具体什么数据类型；多大的数据集？（太小的数据集，复杂排序是没必要的，Java会直接进行二分插入排序）</p><ul><li>对于原始数据类型，目前使用的双轴快速排序，是一种改进快速排序</li><li>对于对象数据类型，目前使用TimSort，思想上也是一种归并和二分插入排序结合的优化排序算法</li><li>另外 java8直接引入了并行排序算法（parallelSort），为了充分利用现代多核处理器的计算能力，底层实现fork-join框架，当处理的数据集比较小的时候，差距不明显。但是，当数据增长到数万到百万以上，提升就是一个量级</li><li>在 java9中，java标准类库提供一系列静态工厂方法，比如 list.of(),set.of(),大大简化了构建晓得容器实例的代码量，采用新的容器静态工厂方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; simpleList =list.of(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>并且保证了不可变性</p><p>讨论一个问题？<br>今天你需要实现一个云计算任务调度系统，希望可以保证VIP客户的任务被优先处理，你可以利用那些数据结构或者标准的集合类型？</p><p>我首先会使用ArrayList来存储对象的姓名（自动开辟新内存），而后采用<br>HashMap来对接对象的任务及处理数据（可以接受NULL值），接下来如果他是VIP，我会考虑到优先级队列，还要额外考虑一下vip再分级，即同等级vip的平权问题，即优先级规则问题，还得考虑同等级多个客户互相不被单一客户大量任务阻塞的问题，调度数据放入redis里面</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArrayList,LinkedList,Vector的区别?&lt;br&gt;高效的管理和操作数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三者都是集合框架里的list，即所谓的有序集合。&lt;/li&gt;
&lt;li&gt;  按照位置进行定位，添加和删除的操作  &lt;/li&gt;
&lt;li&gt;都提供&lt;strong&gt;迭代器&lt;/strong&gt;以遍历其内容</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之SQL连接表的操作</title>
    <link href="http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-03T14:02:24.260Z</published>
    <updated>2020-11-04T01:35:30.915Z</updated>
    
    <content type="html"><![CDATA[<p>SQL92<br>很强大的功能就是在各个数据表之间连接查询<br>JOIN在SQL中的作用<br>五种连接<br><strong>1.笛卡尔积</strong><br>笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能<br>我们假定player表的数据是集合X，先进行SQL查询</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player </span><br></pre></td></tr></table></figure><p>再假定team表的数据为集合Y，同样进行SQL验证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  team</span><br></pre></td></tr></table></figure><p>接下来是笛卡尔积的调用方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player,team</span><br></pre></td></tr></table></figure><p>执行结果<img src="https://img-blog.csdnimg.cn/20201103195856723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2.等值连接<br>两张表的等值连接就是用两张表都存在的列进行连接。我们也可以对多张表进行等值连接<br>而经过我们分析，两张表的等值就是队的ID,因为都存在，我们代码中必须＋表名加以区分<br>所以代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player.team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player,team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103201731217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3.非等值连接<br>我们在进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符都是非等值连接<br>PS：我们知道player表中有身高height字段，如果想要知道每个球员的身高的级别，可以采用非等值连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.player_id,p.player_name,p.height,h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> p,height_grades <span class="keyword">AS</span> h</span><br><span class="line"><span class="keyword">WHERE</span> p.height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20201103202701344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.外连接（左连接，右连接）<br><strong>左外连接</strong>就是指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表<br>相当于SQL99的left join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id(+)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team  <span class="comment">#显示主表的所有行</span></span><br><span class="line"><span class="keyword">ON</span> player.team_id = team.team_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212346387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>右外连接</strong>，当然指的是右边的表为主表，显示右表的所有行，左侧的表为从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> team</span><br><span class="line"><span class="keyword">ON</span> player.team_id =team.team_id <span class="comment"># 显示右表的所有行</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212915704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.自连接<br>自连接可以对多个表进行操作，也可以对同一个表进行操作。也就是说查询条件使用了当前表的字段<br>我们想要查看比，布雷克 ·格里芬身高，高的球员都有谁？以及他们的对应身高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.player_name ,b.height</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a ,player <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.player_name =<span class="string">&#x27;布雷克-格里芬&#x27;</span> <span class="keyword">and</span> a.height &lt; b.height</span><br></pre></td></tr></table></figure><p>这段自连接有点怪，搜出那个名字后，直接可以拿他的身高比就可以了<br>执行结果</p><p><img src="https://img-blog.csdnimg.cn/20201103214329297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>试着做一道题？<br>表格中一共有三支球队，那么现在3支球队需要进行比赛，请用SQL语句写出所有可能的比赛组合<br>分析：根据我的理解，我觉得是笛卡尔积，但是不可能。自己和自己不能比赛<br>那么是不是能笛卡尔积+左连接<br>事实证明我上面的分析都是错的！！！！</p><p>分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(kedui.team_name,<span class="string">&#x27;VS&#x27;</span>,zhudui.team_name) <span class="keyword">AS</span> <span class="string">&#x27;客队vs主队&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> zhudui <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team <span class="keyword">AS</span> kedui</span><br><span class="line"><span class="keyword">ON</span> zhudui.team_id&lt;&gt;kedui.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020110322020619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>不分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.team_name ,b.team_name</span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> a,team <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id&lt;b.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103220216610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL92&lt;br&gt;很强大的功能就是在各个数据表之间连接查询&lt;br&gt;JOIN在SQL中的作用&lt;br&gt;五种连接&lt;br&gt;&lt;strong&gt;1.笛卡尔积&lt;/strong&gt;&lt;br&gt;笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能&lt;br&gt;我们假定player表的数据是集合X，先进行SQL查询&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之equals的基本特性，及自己对wait,notify的理解、join的理解</title>
    <link href="http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-03T10:53:25.158Z</published>
    <updated>2020-11-03T10:58:14.820Z</updated>
    
    <content type="html"><![CDATA[<p>自反性：对于任何非空引用值x,x.equals(x)都应返回true<br>对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true<br>传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.<br>一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值</p><a id="more"></a><p>equals注意事项：<br>对象域，使用equals方法<br>类型安全的枚举，使用equals或者==<br>可能为null的对象域：使用equals或者==<br>数组域，使用Arrays.equals</p><p>有一个问题：notify()会立刻释放锁吗？<br>答案是：不会<br>多个线程之间有互动关系的时候，某个线程得等一会儿wait()，等notify()提醒他，这就是互动模式<br>wait()是让线程等待的方法（线程释放对象锁，进入等待池；所以必须先得获得锁，wait必须写在synchronized代码块中，否则会报异常）<br>notify()是提醒线程该运行的方法（唤醒等待该对象同步锁的线程，放线程进入锁池中，竞争得到对象锁，然后开始执行）<br>notify唤醒的线程，都是随机唤醒的，没有顺序之分<br>notify All唤醒的线程，符合后进先出的原则<br>都是Object方法<br>所以说，notify 和notifyALL并不会立即释放对象锁，必须等到synchronized方法或者语法块执行完才能真正释放锁。然后线程去竞争。<br>贴代码：生产者和消费者<br>消费者：我用三个线程去执行队列里由生产者产生的任务(因为会产生交互，都是执行的一个队列的任务，所以任务队列得加synchronzied锁)<br>生产者：我用100个线程生产任务<br>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTaskCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;T&gt; tasks, <span class="keyword">int</span> maxTaskCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">        <span class="keyword">this</span>.maxTaskCount = maxTaskCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(T task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果这个检查不在synchronized块里会怎么样呢？</span></span><br><span class="line">            <span class="comment">// TODO 如果如果不用while会怎么样呢？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() &gt;= maxTaskCount) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(task);</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;T&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果不用while，用if，会怎么样？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = tasks.poll();</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCKER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; urls = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;&gt;(urls);</span><br><span class="line">        Producer&lt;String&gt; producer = <span class="keyword">new</span> Producer&lt;&gt;(urls, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread consumerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = consumer.consume();</span><br><span class="line">                        processURL(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;消费者-&quot;</span> + i);</span><br><span class="line">            consumerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread producerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = produceURL();</span><br><span class="line">                        producer.produce(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;生产者-&quot;</span> + i);</span><br><span class="line">            producerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 如果想给生产者消费者做一个统计，统计每个生产者消费者所生产/消费的task的数量，应该</span></span><br><span class="line">        <span class="comment">// TODO 1）使用哪种数据结构？</span></span><br><span class="line">        <span class="comment">// TODO 2）如何保证线程安全？</span></span><br><span class="line">        <span class="comment">// TODO 3）怎么将统计结果输出到控制台？</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">produceURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ret.append(<span class="string">&quot;www.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.append(<span class="string">&quot;.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processURL</span><span class="params">(String url)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理：&quot;</span> + url);</span><br><span class="line">        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;处理完成：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>粗略涉及一下join方法<br>join方法同步<br>就涉及范围更广了<br>比如一个线程A.join，<br>那么下一个线程就必须等待A执行完，才能执行<br><strong>我现在理解的多线程是并发执行不同的任务，一些需要交互的用synchronized,wait/notify、join方法保证，整体并发时间肯定比一个个执行线程的时间少</strong><br>下面我贴一个代码！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.join;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; CONTENTS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> WORKING_DURATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainStart = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始抓取网页内容&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                String content = getContentFromWeb();</span><br><span class="line">                <span class="keyword">long</span> threadWorkingDuration = System.currentTimeMillis() - start;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:抓取网页内容结束&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (CONTENTS) &#123;</span><br><span class="line">                    CONTENTS.add(content);</span><br><span class="line">                    WORKING_DURATION += threadWorkingDuration;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO sleep一下，让线程都启动起来</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程开始 join  ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = thread.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程开始join &quot;</span> + name + <span class="string">&quot; ------------ &quot;</span>);</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程join &quot;</span> + name + <span class="string">&quot; 结束 ------------ &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程join结束，获取的内容为： ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        CONTENTS.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.print(s.length() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainWorkDuration = System.currentTimeMillis() - mainStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 多线程的意义就是让工作并发的处理，使用更多的资源（CPU，磁盘，网络等），以便让工作更快的完成。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程累计工作时间：&quot;</span> + WORKING_DURATION);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程工作时间：&quot;</span> + mainWorkDuration);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getContentFromWeb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000000</span>)) % <span class="number">4096</span> + <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工作线程累计工作时间：33466<br>主线程工作时间：6727<br>线程累计时间多，而并发线程时间少！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自反性：对于任何非空引用值x,x.equals(x)都应返回true&lt;br&gt;对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true&lt;br&gt;传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.&lt;br&gt;一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Hashtable、HashMap、TreeMap</title>
    <link href="http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-11-03T05:50:17.860Z</published>
    <updated>2020-11-03T05:55:22.329Z</updated>
    
    <content type="html"><![CDATA[<p>map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现</p><p>Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。</p><a id="more"></a><p>HashMap与Hashtable行为基本上一致，不一样的地方在于HashMap<strong>不是同步</strong>的，<strong>支持null键和值</strong><br>通常，HashMap进行put或者get操作，可以达到常数时间的性能,因此使我们利用键值对存取场景的首选。比如：<br>用户ID –用户信息对应的运行时存储结构</p><p>Treemap是基于红黑树的一种提供<strong>访问顺序</strong>的Map，和HashMap不同，它的get,put,remove的时间复杂度都是O（log(n)）,具体顺序由指定的Comparator来决定，或者由键的自然顺序来判断</p><p><strong>HashMap的设计和实现细节</strong><br>  HashMap扩展了abstractMap，且非常依赖于哈希码的有效性：<br>  1.equals相等，hashcode一定相等<br>  2.hashcode改写以后也要改写equals<br>  3.hashCode需要保持一致性，状态改变返回的哈希值仍然要一致<br>  4.equals的对称，反射，传递等特性（下篇博客写）</p><p> <strong>有序Map</strong><br> LinkedHashMap和TreeMap都可以保证某种顺序<br> 1.linkedHashMap提供的遍历顺序符合插入顺序，它的实现是通过为键值对维护一个双向链表，<br> 通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的put,get,compute都算作“访问”。<br> 场景：构建一个空间占用敏感化的资源池，希望可以自动将最不常被访问的对象释放掉，使用LInkedHashMap来实现<br> 2.对于TreeMap,它的整体顺序是由键的顺序来决定，通过comparator或Comparable（自然顺序：必须符合约定：comparaTo的返回值需要和equals一致）来决定。<br> 代码如下，经常复盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = …</span><br><span class="line">    cmp = k.compareTo(t.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构建一个优先级的调度系统的问题，其本质就是一个典型的有限队列场景，Java标准类库提供了基于二叉堆实现的PriorityQueue,TreeMap和TreeSet也是依赖于此。</p><p><strong>HashMap内部基本点分析</strong><br>可以看作是<strong>数组（Node&lt;K,V&gt;[]table）</strong>和<strong>链表</strong>组成的符合结构<br>数组被分为一个个桶，通过哈希值决定键值对在这个数组的寻址。<br>哈希值相同的键值对，就按照链表形式存储。<br>如果链表超过阈值，就会被改造成树形结构。</p><p>这个数组似乎并没有被初始化好，仅仅设置了一些初始值而已<br>看代码就知道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们认为HashMap也许是按照lazy-load原则，在首次使用时初始化。<br>只有putVal的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evit)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> , i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line">        tab[i] = newNode(hash, key, value, nll);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">        <span class="comment">//  ... </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表格是null,resize就会负责初始化它，这从tab=<br>resize()可以看出</p><p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足要求的时候，进行扩容（resize）</p><p>在放置新的键值对的过程中，如果发生下面这种情况，就会发生扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>具体键值对在哈希表的位置（数组Index）取决于下面的位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>学过数据结构的都知道，它并不是key本身的hashCode,而是来自于HashMap里面的另外一个hash方法。<br><strong>为什么将高位数据移位到低位进行异或运算？</strong><br>计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，这种<strong>处理就可以有效避免类似情况下的哈希碰撞</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> h;</span><br><span class="line">           <span class="keyword">return</span> (key =<span class="keyword">null</span>)?<span class="number">0</span>:(h= key.hashCode())^(h&gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么树化？对链表（bin）进行怎样的处理？</strong></p><p>可以看出，putVal方法本身逻辑非常集中，从初始化，扩容到树化，都有参与<br>依据resize源码，在不考虑极端情况下的（容量理论最大极限由 MAXIMUM_CAPACITY指定，数值为1&lt;&lt;30,即2^30次方）：<br>我们可以归纳为<strong>门限值</strong>=负载因子*容量，我们通常用默认值<br><strong>门限值（就是数组的最大参数）</strong>通常以倍数调整，当元素个数超过门限大小是，即调整Map大小<br>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源</p><p><strong>容量，负载因子，树化？</strong><br>还是数据结构的原理<br>容量和负载因子都是数组的标准条件，相当于当时学过的寻找大于元素数量的最小的素数来当做数组。<br>就相当于桶的数量，太少和占用太满都会影响操作的性能</p><p>负载因子：不超过0.75<br>如果使用太小的负载因子，则用导致更加频繁的扩容，增加开销成本</p><p>树化改造，不外乎对应逻辑就是putVal和treeIfyBin中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> n,index;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> (tab ==<span class="keyword">null</span> ||(n =tab.length)&lt;MIN_TREEIFY_CAPACITY)</span><br><span class="line">               resize();<span class="comment">//创建数组</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>((e=tab[index =(n-<span class="number">1</span>)&amp;hash])! =<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//树化逻辑改造</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>数组判定条件：当bin的数量大于TREEIFY_THRESHOLD（默认是8）的条件下：（一个桶中有8个元素），允许红黑树化<br>—&gt;接下来有判定条件：<br>如果容量小于MIN_TREEIFY_CAPACITY，只会进行简单的扩容<br>如果容量大于MIN_TREEIFY_CAPACITY（最小树形阈值）<br>则进行红黑树化</p><p>本质上是一个安全问题，如果哈希冲突，都会放置同一个桶里，形成链表，我们知道链表是线性的，会影响存取的性能。<br>第二是因为构造哈希冲突的数据并不是非常复杂的事情，恶意代码可以利用这些数据大量与服务器交互，从而让服务器CPU被大量占用，造成崩溃，所以允许树化，再不济进行扩容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现&lt;/p&gt;
&lt;p&gt;Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之sql子查询</title>
    <link href="http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-02T11:40:50.925Z</published>
    <updated>2020-11-02T11:43:39.213Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a><br>查询结果集<br><strong>关联子查询:</strong> 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部</p><a id="more"></a><p>我们想要查找球队中大于平均身高的球员有哪些？并显示他们的球员姓名身高和所在球队ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height,team_id</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height)</span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id =b.team_id)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次查询都得执行一次子语句</p><p>通常关联子查询也会和EXISTS一起使用<br>比如我们想看出场过的球员有哪些？并且显示他们的姓名，id，球队ID</p><p>是否出场可以通过player_score此表来查询，因为在player_score有出场记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,team_id</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> player_id  <span class="keyword">FROM</span> player_score</span><br><span class="line"><span class="keyword">WHERE</span> player.player_id =player_score.player_id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IN和EXISTS虽然查询结果一样，但是效率确不一样，<br>如果A表比B表小，EXISTS效率高，因为查询时可以使用A表对于play_id的索引，反之，则IN效率更高(小表驱动大表更有效率)</p><p>ANY ,ALL<br>举例：<br>想要查询球员表中，比印第安纳步行者team_id=002那只队中任意一个球员身高高的所有球员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ANY</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ALL</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><p><strong>将子查询作为主查询的计算字段（把子查询的结果当做主查询的列）</strong><br>比如我想查询每个球队的球员数，也就是对应那个team_id ,相同的team_id在player这张表中球员数量是多少</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> team_name,(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id)</span><br><span class="line"><span class="keyword">AS</span> player_num</span><br><span class="line"><span class="keyword">FROM</span> team</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS player_num</span><br></pre></td></tr></table></figure><p>是给</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id</span><br></pre></td></tr></table></figure><p>起了个别名，方便我们使用</p><p>最后出个题：<br>编写SQL语句，得到场均得分大于20的球员（场均得分从player_score表中获取，同时你需要输出球员的ID，球员姓名及所在球队的ID信息）<br>我的理解是：<br>1.场均得分大于20，第一场得了40分，第二场得了2分，场均为21分照样满足条件<br>2.一场比赛中，球员可以出现多次<br>解析思路：先得出球员在每场比赛中的总分数，然后对球员按比赛分组，计算球员在所参加比赛中的平均分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t2.player_id,t2.player_name,t2.team_id,t3.v</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> t1.player_id,<span class="keyword">avg</span>(t1.total) <span class="keyword">AS</span> v</span><br><span class="line">     <span class="keyword">FROM</span> </span><br><span class="line">       (<span class="keyword">SELECT</span> player_id,<span class="keyword">SUM</span>(score) <span class="keyword">AS</span> total   <span class="keyword">FROM</span> player_score   <span class="keyword">WHERE</span> game_id <span class="keyword">IN</span>  (<span class="keyword">SELECT</span> game_id <span class="keyword">FROM</span> player_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> game_id) </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> player_id <span class="comment">#对球员进行分组，计算在每场比赛的总分数</span></span><br><span class="line">        )<span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.player_id <span class="comment">#对球员分组，计算每场比赛的均分</span></span><br><span class="line"><span class="keyword">HAVING</span> v&gt;<span class="number">20</span> <span class="comment">#对分组进行筛选</span></span><br><span class="line">)<span class="keyword">AS</span> t3 <span class="keyword">ON</span> t2.player_id =t3.player_id</span><br></pre></td></tr></table></figure><p>本题有点难度！！！！<br>要经常回来复盘！！<br>答案贴在这<br><img src="https://img-blog.csdnimg.cn/20201102193901622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>**非关联子查询:**只作为主查询的条件语句执行一次</p><p>我们想要找nba球员中谁最高？<br>且输出他的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height=(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(height) <span class="keyword">FROM</span> player)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;br&gt;查询结果集&lt;br&gt;&lt;strong&gt;关联子查询:&lt;/strong&gt; 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之动态代理篇</title>
    <link href="http://example.com/2020/11/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://example.com/2020/11/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/</id>
    <published>2020-11-01T08:31:21.555Z</published>
    <updated>2020-11-01T08:54:58.791Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font>编程语言分类角度：1.动态类型和静态类型2.强类型和弱类型<a id="more"></a>在这里我们复习一下JAVA的反射机制反射机制是赋予程序运行时自省（introspect）的能力能通过反射直接操作类和对象1.获取某个对象的类定义2.获取类声明的属性和方法，调用方法和构造方法运行时修改类定义<p>动态代理是一种方便运行时动态构建代理，动态处理代理方法调用的机制，很多场景都是利用类似机制机制做到的<br>用来包装RPC调用，面向切面的编程。</p><p>实现动态代理的方式：<br>1.JDK自身提供的动态代理，反射机制<br>2.更高性能的字节码操作机制，ASM,cglib,javassist</p><p>反射赋予了java语言活力，通过运行时操作元数据或对象，java可以灵活地操作运行时才能确定的信息。</p><p><strong>1.考察你对反射机制的了解及掌握程度？</strong><br>Class 、Field、Method、Constructor 就是操作类和对象的元数据对应，官方API文档：<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">https://docs.oracle.com/javase/tutorial/reflect/index.html</a><br>对于反射，AccessibleObject.setAccessible(boolean flag)<br>其子类也大多重写了这个方法，这个accessible可以修饰成员访问限制，这意味着程序运行时我们照样可以修改成员访问限制。<br>java9以后，加入一个open机制，只有当被反射操作的模块和指定的包对反射调用者Open，才能用setAccessible<br>比如：开发 、测试、依赖注入<br>O/R Mapping框架中，为java实体自动生成getter setter 方法<br>框架可以利用反射做这个事情，而不需要开发者手动写重复代码。<br>使用反射绕开限制，我们日常开发调用内部API去做事情，<br>例如： 自定义的高性能NIO框架显式地释放DirectBuffer<br><strong>2.动态代理解决了什么问题，你在业务系统中的应用场景是什么？</strong><br>代理是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成<br>通过代理可以让调用者和实现者之间解耦，如：RPC调用，框架内部的寻址，序列化，反序列化</p><p><strong>3.JDK动态代理在设计和实现上与cglib等方式有什么不同？如何取舍？</strong><br>ciglib采用的时<strong>创建目标类的子类</strong>的方式，近似使用被调用者本身的效果，在Spring编程中，框架通常会处理这种情况</p><p><strong>JDK Proxy的优势</strong><br>最小化依赖关系<br>平滑进行JDK版本升级，而字节码类库通常还需进行更新<br>代码</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;
编程语言分类角度：1.动态类型和静态类型
2.强类型和弱类型</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之int和interger的区别（续）篇</title>
    <link href="http://example.com/2020/11/01/int%E5%92%8Cinterger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://example.com/2020/11/01/int%E5%92%8Cinterger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%AD%EF%BC%89/</id>
    <published>2020-11-01T08:29:13.202Z</published>
    <updated>2020-11-01T08:57:56.969Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font>原始数据类型为八大类我们先复习一下我们学过的int ：基本数据类型，不用声明直接使用interger：是int的封装类。需要声明，但是JAVA给其自动装箱开箱（抽象为类，new 一个对象）的功能，让其可以自由像int一样自由赋值interger的值缓存，java5提供了静态工厂方法valueof但是有valueof的限制，调用一个缓存机制，interger取值范围在-128—127之间，且只能在这个范围内比较<a id="more"></a><p><strong>问题1：编译阶段、运行时，自动装箱/自动拆箱是发生在什么阶段？</strong><br>自动装箱和开箱其实是一种语法糖，Java平台自动为我们进行了一些转换，保证在编译时生成的字节码是一致的。<br>javac自动把装箱转换成了Interger.valueOf(),把开箱转换成了Interger.intValue(),装箱的时候调用了方法，肯定也应用到了缓存机制<br><strong>问题2：使用静态工厂方法valueof会使用缓存机制，那么自动装箱的时候，缓存机制其作用吗？</strong><br>上一题已经回答了<br>这一种<strong>缓存机制</strong>并不是interger独有，同样存在其他基本类型的包装类：<br>如：1.Boolean,缓存了true/false对应实例，确切说，只会返回两个常量实例Boolean.TRUE/FALSE<br>2.Short,同样缓存了-128—127之间的数值<br>3.Byte 数值有限，所以全部被缓存<br>4.Character,缓存范围’\u0000’—‘\u007F’<br>自动装箱和开箱很酷，有什么需要注意的吗？<br>原则上尽量避免无意识的开箱装箱，尤其是性能敏感的场合，创建10万个java对象是相对于创建10万个整数的是高量级，不管是内存占用还是处理时速度都会变慢<br><strong>问题3：为什么我们需要原始数据类型，Java的对象似乎也很高效，应用中具体会产生哪些差异？</strong><br> 使用原始数据类型，数组甚至本地代码实现。在性能极度敏感的场景，用其替换掉包装类，动态数组<br><strong>问题4：阅读过Interger源码吗？分析下类或者某些方法的设计要点</strong><br>虽然interger的默认缓存值为-128-127，但是我们也可以根据需要调整，调整代码为：</p><p>-XX：AutoBoxCacheMax=N<br>这些都体现在java.lang.Interger的静态代码初始块里</p><p><strong>Interger等包装类，定义了SIZE或者BYTES这样的常量，</strong>这样的设计考虑是因为在32或者64位中JDK中，不需要移植工作。</p><p><strong>原始类型线程安全</strong><br><strong>java原始数据类型和引用类型局限性</strong><br>原始数据类型并不能和泛型一起使用<br>java的对象都是引用类型，如果一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，往往分散于存储堆的不同位置，这种设计虽然带了极大的灵活性，也导致了数据操作的低效。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;
原始数据类型为八大类
我们先复习一下我们学过的
int ：基本数据类型，不用声明直接使用
interger：是int的封装类。需要声明，但是JAVA给其自动装箱开箱（抽象为类，new 一个对象）的功能，让其可以自由像int一样自由赋值
interger的值缓存，java5提供了静态工厂方法valueof
但是有valueof的限制，调用一个缓存机制，interger取值范围在-128—127之间，且只能在这个范围内比较</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RUOYI项目初级涉猎篇</title>
    <link href="http://example.com/2020/11/01/RUOYI%20Spring%20boot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%201/"/>
    <id>http://example.com/2020/11/01/RUOYI%20Spring%20boot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%201/</id>
    <published>2020-11-01T07:29:01.416Z</published>
    <updated>2020-11-01T07:29:01.416Z</updated>
    
    <content type="html"><![CDATA[<p>@[cwxprogrammer</p><h1 id="项目场景：ruoyi-spring-boot项目打怪升级"><a href="#项目场景：ruoyi-spring-boot项目打怪升级" class="headerlink" title="项目场景：ruoyi spring boot项目打怪升级"></a>项目场景：ruoyi spring boot项目打怪升级</h1><h1 id="学习目标：掌握其中的一些知识，分享给一起努力的人"><a href="#学习目标：掌握其中的一些知识，分享给一起努力的人" class="headerlink" title="学习目标：掌握其中的一些知识，分享给一起努力的人"></a>学习目标：掌握其中的一些知识，分享给一起努力的人</h1><font color=#999AAA >两天把ruoyi部署起来，根据文档会打点理解其中模块的作用和实现原理<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><font color=#999AAA ><p>大家先理解一下Spring boot的意思，极大解放了广大程序员，利用maven依赖的繁琐，利用web.xml加载Spring,以及最终的tomcat部署，这是最令人绝望的，而Spring boot使xml -bean的历史彻底过去，使用了各种Starter,配置方面完全自动配置，自动注入，部署有内嵌tomcat,非常香。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习时间："><a href="#学习时间：" class="headerlink" title="学习时间："></a>学习时间：</h1><font color=#999AAA ><p>1、 周一至周五晚上 7 点—晚上9点<br>2、 周六上午 9 点-上午 11 点<br>3、 周日下午 3 点-下午 6 点</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习产出："><a href="#学习产出：" class="headerlink" title="学习产出："></a>学习产出：</h1><p><font color=#999AAA >提示：这里统计学习计划的总量<br>例如：<br>1、 技术笔记 2 遍<br>2、个人 技术博客 1篇<br>3、 学习的 vlog 视频 1 个</p><font color=#999AAA >RuoYi是一款基于SpringBoot+Bootstrap的极速后台开发框架。</font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>1.<img src="https://img-blog.csdnimg.cn/20201008144322646.png#pic_center" alt="在这里插入图片描述"><br>2.<br>java.sql.SQLNonTransientConnectionException: CLIENT_PLUGIN_AUTH is required</p> </font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">css<a id="more"></a># 原因分析：<font color=#999AAA >第一个好解决，看以下截图</font><p><img src="https://img-blog.csdnimg.cn/2020101010413597.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201010104218397.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201010104252672.png#pic_center" alt="把这个勾子点去"><br><font color=#999AAA ><br>第二个问题本来不应该算问题，我的电脑MYSQL安装的是5.0，但我却误认为8.0.19，导致自己JAR包导错，导致数据库连接失败，给新手一个提示，虽然有可能你的内存中装着两个数据库，但一定要看哪个起作用，从navicat最右面中间位置，看截图<br></font><br><img src="https://img-blog.csdnimg.cn/20201010105041517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="项目场景："><a href="#项目场景：" class="headerlink" title="项目场景："></a>项目场景：</h1><font color=#999AAA >1.还有一个问题值得注意 ，就是大家一定要多看RUOYI文件包里面自带的文档，就那个DOC文件包。2.如果想要前后端分离的系统，那就得先准备虚拟机节点，在虚拟机上面装一个lunix系统，具体我也是看B站CodeSheep弄的，保姆级教程，前后端分离的RUOYI需要花费时间。</font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h1><font color=#999AAA >值得注意的是，大家都是普通人，如果一个软件在耗费你时间两个小时的基础上都装不好的话，那就试试借助外力，比如淘宝网，当然我鼓励大家自己装，但是要算对账。</font>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[cwxprogrammer&lt;/p&gt;
&lt;h1 id=&quot;项目场景：ruoyi-spring-boot项目打怪升级&quot;&gt;&lt;a href=&quot;#项目场景：ruoyi-spring-boot项目打怪升级&quot; class=&quot;headerlink&quot; title=&quot;项目场景：ruoyi spring boot项目打怪升级&quot;&gt;&lt;/a&gt;项目场景：ruoyi spring boot项目打怪升级&lt;/h1&gt;&lt;h1 id=&quot;学习目标：掌握其中的一些知识，分享给一起努力的人&quot;&gt;&lt;a href=&quot;#学习目标：掌握其中的一些知识，分享给一起努力的人&quot; class=&quot;headerlink&quot; title=&quot;学习目标：掌握其中的一些知识，分享给一起努力的人&quot;&gt;&lt;/a&gt;学习目标：掌握其中的一些知识，分享给一起努力的人&lt;/h1&gt;&lt;font color=#999AAA &gt;
两天把ruoyi部署起来，根据文档会打点理解其中模块的作用和实现原理
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习内容：&quot;&gt;&lt;a href=&quot;#学习内容：&quot; class=&quot;headerlink&quot; title=&quot;学习内容：&quot;&gt;&lt;/a&gt;学习内容：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;大家先理解一下Spring boot的意思，极大解放了广大程序员，利用maven依赖的繁琐，利用web.xml加载Spring,以及最终的tomcat部署，这是最令人绝望的，而Spring boot使xml -bean的历史彻底过去，使用了各种Starter,配置方面完全自动配置，自动注入，部署有内嵌tomcat,非常香。&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习时间：&quot;&gt;&lt;a href=&quot;#学习时间：&quot; class=&quot;headerlink&quot; title=&quot;学习时间：&quot;&gt;&lt;/a&gt;学习时间：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;1、 周一至周五晚上 7 点—晚上9点&lt;br&gt;2、 周六上午 9 点-上午 11 点&lt;br&gt;3、 周日下午 3 点-下午 6 点&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习产出：&quot;&gt;&lt;a href=&quot;#学习产出：&quot; class=&quot;headerlink&quot; title=&quot;学习产出：&quot;&gt;&lt;/a&gt;学习产出：&lt;/h1&gt;&lt;p&gt;&lt;font color=#999AAA &gt;提示：这里统计学习计划的总量&lt;br&gt;例如：&lt;br&gt;1、 技术笔记 2 遍&lt;br&gt;2、个人 技术博客 1篇&lt;br&gt;3、 学习的 vlog 视频 1 个&lt;/p&gt;
&lt;font color=#999AAA &gt;
RuoYi是一款基于SpringBoot+Bootstrap的极速后台开发框架。
&lt;/font&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h1&gt;&lt;p&gt;1.&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008144322646.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;2.&lt;br&gt;java.sql.SQLNonTransientConnectionException: CLIENT_PLUGIN_AUTH is required&lt;/p&gt;
 &lt;/font&gt;


&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;
css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之反射篇</title>
    <link href="http://example.com/2020/11/01/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2020/11/01/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-11-01T07:29:01.159Z</published>
    <updated>2020-11-01T07:29:01.159Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><h1 id="本节的内容是反射（reflection）"><a href="#本节的内容是反射（reflection）" class="headerlink" title="本节的内容是反射（reflection）"></a>本节的内容是反射（reflection）</h1><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><a id="more"></a><p>Class(注意大写)，是类的类<br>Class clazz =MerchandiseV2.class</p><p><img src="https://img-blog.csdnimg.cn/20201025155334840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此处string[ ]是一个变长函数，可以自定义变长。</p><p><strong>使用反射（reflection）访问属性</strong><br>          Field countField = clazz.getField(“count”);<br>          System.out.println(countField.get(m100));<br>          countField.set(m100,888);<br>          System.out.println(countField.get(m100));<br>          System.out.println(m100.count);<br>也许通过这段代码你可以理解Field 的意义，Field代表在Class clazz定义的那个类里的所有成员变量。<br>所以才会有这句<br> Field <strong>countField</strong> = clazz.getField(“<strong>count</strong>“);<br>下面我们可以通过遍历更加了解Field<br><img src="https://img-blog.csdnimg.cn/20201025164134960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这是另一种调用方法。<br>我们还可以调用静态变量<br>Field field =clazz.getField(name:”STATIC_MEMBER”);<br>System.out.println(field.get(null));</p><p>通过反射调用成员变量和静态变量</p><p>当然，我们需要清楚我们定义的clazz必须是这个类本类或者是这个类的父类才行。</p><p>接下来呢，我们要利用反射来调用clazz这个类中的方法：</p><p><img src="https://img-blog.csdnimg.cn/20201025172049961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201025172351230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来<br>我们演示一下<br><strong>反射能做到，平常调用做不到的方法</strong><br>调用private 的方法和属性<br><img src="https://img-blog.csdnimg.cn/20201025172638221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201025173407495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="调入private的属性"><br><img src="https://img-blog.csdnimg.cn/20201025173454859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="调用private的方法"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射一个高级语言里的 通用功能，通过这样一种方式动态的来执行一些方法<br>比如：你不知道一个地方的经纬度，也能调用它的属性方法，不需要精确，但必须知道有这么个实例。<br>但是有一点就是反射比较慢，找的时候慢，执行方法速度一样。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;本节的内容是反射（reflection）&quot;&gt;&lt;a href=&quot;#本节的内容是反射（reflection）&quot; class=&quot;headerlink&quot; title=&quot;本节的内容是反射（reflection）&quot;&gt;&lt;/a&gt;本节的内容是反射（reflection）&lt;/h1&gt;&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Iterator篇</title>
    <link href="http://example.com/2020/11/01/Iterator%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2020/11/01/Iterator%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-11-01T07:29:00.379Z</published>
    <updated>2020-11-01T07:29:00.379Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >**Iterator接口**<a id="more"></a>点两下shfit 就可以查找class 类型  符号 从Java4以后就有了hasNext()next()Iterable接口，实现这个接口就可以支持forEach循环，只有一个方法Iterator()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pointer &lt; size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (T) elements[pointer++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">addElementsToCollection</span><span class="params">(Collection collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collection.add(<span class="string">&quot;str&quot;</span> + (i % <span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection collection)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;输出&quot;</span> + collection.getClass() + <span class="string">&quot;中的元素，共&quot;</span> + collection.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object element : collection) &#123;</span><br><span class="line">                System.out.println(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后存入一个集合里头的元素，利用iterator将其输出出来</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
**Iterator接口**</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java9大基础类型</title>
    <link href="http://example.com/2020/11/01/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/11/01/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-11-01T07:29:00.347Z</published>
    <updated>2020-11-01T07:29:00.347Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？"><a href="#一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？" class="headerlink" title="一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？"></a>一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？</h1><a id="more"></a><p>我先说Java九大类型，byte(1)  short(2)  int(4)    long(8)<br>float(4)   double(8)  char(2)  boolean  void<br>对应的封装类： Byte  Short  interger  Long  Float<br>Double Character  Boolean Void</p><p>1.int是基本数据类型，interger 是封装类型<br>2.前者默认值是0,后者默认值为null。所以可以从侧面判断interger数值为0，还是没赋值<br>3.前者不用实例化，后者需要实例化，且有自动开箱功能。如：4.interger a =1;相当于 interger a =new interger(1);<br>5.前者可以和后者直接比较：两个数值相等就为相等<br>6.在-128 –127数值范围内，interger是可以比较的，越过这个范围，interger就会重新new.</p><font color=#999AAA ><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color=#999AAA ><p>以上就是今天要分享的内容，老生常谈，写出来也许看的人不会，但是你分享过后，你肯定会了！！</p><p>css<!--more--></p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;h1 id=&quot;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot;&gt;&lt;a href=&quot;#一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot; class=&quot;headerlink&quot; title=&quot;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot;&gt;&lt;/a&gt;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之jdk和GC篇</title>
    <link href="http://example.com/2020/11/01/jrejdk%20gc/"/>
    <id>http://example.com/2020/11/01/jrejdk%20gc/</id>
    <published>2020-11-01T07:29:00.300Z</published>
    <updated>2020-11-01T07:29:00.300Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、1-谈谈你对java平台的理解？"><a href="#一、1-谈谈你对java平台的理解？" class="headerlink" title="一、1.谈谈你对java平台的理解？"></a>一、1.谈谈你对java平台的理解？</h1><a id="more"></a><p>书写一次，到处执行。<br>JDK是Java Development Kit  ,是Java的开发套件<br>JRE是 Java Runtime Environment，是运行java的环境<br>JDK包含了JRE，而且还包含了很多和开发调试程序相关的工具<br>1.Javac编译成为字节码，再通过JVM内嵌的解释器将字节码转换为最终的机器码<br>2.JVM会通过类加载器（class -Loader）加载字节码，解释或者编译执行<br> Jsut in time 简称 JIT<br>Jdk9引入了AOT将字节码编译成机器代码</p><h1 id="二、垃圾收集（Garbage-Collection）"><a href="#二、垃圾收集（Garbage-Collection）" class="headerlink" title="二、垃圾收集（Garbage Collection）"></a>二、垃圾收集（Garbage Collection）</h1><p>Java通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收<br>最常用的垃圾收集：SerialGC  、Parallel GC 、CMS 、G1</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>都是些零碎的小知识，大家要见谅，也不要嘲笑，都是深耕。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;


&lt;h1 id=&quot;一、1-谈谈你对java平台的理解？&quot;&gt;&lt;a href=&quot;#一、1-谈谈你对java平台的理解？&quot; class=&quot;headerlink&quot; title=&quot;一、1.谈谈你对java平台的理解？&quot;&gt;&lt;/a&gt;一、1.谈谈你对java平台的理解？&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MYSQL MAP</title>
    <link href="http://example.com/2020/11/01/mySQL%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://example.com/2020/11/01/mySQL%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2020-11-01T07:29:00.262Z</published>
    <updated>2020-11-01T07:29:00.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h1><font color=#999AAA ><p>学习时候用的思维导图<br>分享给大家</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><font color=#999AAA ><p>01丨了解SQL：一门半衰期很长的语言<br>02丨DBMS的前世今生<br>03丨学会用数据库的方式思考SQL是如何执行的<br>04丨使用DDL创建数据库&amp;数据表时需要注意什么？<br>05丨检索数据：你还在SELECT * 么？<br>06丨数据过滤：SQL数据过滤都有哪些方法？<br>07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？<br>08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">css<a id="more"></a># 学习时间：<font color=#999AAA ><p>1、 周一至周五晚上 7 点—晚上9点<br>2、 周六上午 9 点-上午 11 点<br>3、 周日下午 3 点-下午 6 点</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习产出："><a href="#学习产出：" class="headerlink" title="学习产出："></a>学习产出：</h1><font color=#999AAA ><p>1、 技术笔记 1 篇<br>2、CSDN 技术博客 1篇<br>3、 学习的 vlog 视频 1 个</p><p>Markdown<br><img src="https://img-blog.csdnimg.cn/2020101109291567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020101109291529.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914837.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914844.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914802.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;学习目标：&quot;&gt;&lt;a href=&quot;#学习目标：&quot; class=&quot;headerlink&quot; title=&quot;学习目标：&quot;&gt;&lt;/a&gt;学习目标：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;学习时候用的思维导图&lt;br&gt;分享给大家&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习内容：&quot;&gt;&lt;a href=&quot;#学习内容：&quot; class=&quot;headerlink&quot; title=&quot;学习内容：&quot;&gt;&lt;/a&gt;学习内容：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;01丨了解SQL：一门半衰期很长的语言&lt;br&gt;02丨DBMS的前世今生&lt;br&gt;03丨学会用数据库的方式思考SQL是如何执行的&lt;br&gt;04丨使用DDL创建数据库&amp;amp;数据表时需要注意什么？&lt;br&gt;05丨检索数据：你还在SELECT * 么？&lt;br&gt;06丨数据过滤：SQL数据过滤都有哪些方法？&lt;br&gt;07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？&lt;br&gt;08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;
css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/11/01/hello-world/"/>
    <id>http://example.com/2020/11/01/hello-world/</id>
    <published>2020-11-01T07:28:59.214Z</published>
    <updated>2020-11-01T07:28:59.215Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>css<a id="more"></a><br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之HashMap篇</title>
    <link href="http://example.com/2020/11/01/HashMap/"/>
    <id>http://example.com/2020/11/01/HashMap/</id>
    <published>2020-11-01T07:28:59.128Z</published>
    <updated>2020-11-01T07:28:59.128Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >**HashMap**<a id="more"></a>数组  通过一个Key的hashcode （mod） 数组长一个值就叫索引数组+链表实现数据分布，数据结构创建Map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">createMap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; ret = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// TODO put的第一个为key，第二个为value</span></span><br><span class="line">            ret.put(<span class="string">&quot;key&quot;</span> + i, String.valueOf(Math.random()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;--------------删除key--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">       String keyToRemove = <span class="string">&quot;key9&quot;</span>;</span><br><span class="line">       System.out.println(keyToRemove + <span class="string">&quot;对应的值是：&quot;</span> + map.get(keyToRemove));</span><br><span class="line">       map.remove(keyToRemove);</span><br><span class="line">       System.out.println(<span class="string">&quot;执行删除操作后，&quot;</span> + keyToRemove + <span class="string">&quot;对应的值是：&quot;</span> + map.get(keyToRemove));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历key和value--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;key为：&quot;</span> + entry.getKey() + <span class="string">&quot;，value为：&quot;</span> + entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历value--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">           System.out.println(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历key--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">           System.out.println(key);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>遍历是没有顺序的 entrySet<br>大家记忆一下：<br> map.remove(keyToRemove);<br> Map.Entry&lt;String, String&gt; entry : map.entrySet()<br> entry.getKey() + “，value为：” + entry.getValue()<br>  map.values()<br>  map.keySet()<br>  为什么Hashmap可以实现Hashset呢？<br>  <strong>不管value，那么key不就是一个HashSet嘛！！</strong></p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
**HashMap**</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Hashcode和equals篇</title>
    <link href="http://example.com/2020/11/01/hashCode%E5%92%8Cequals/"/>
    <id>http://example.com/2020/11/01/hashCode%E5%92%8Cequals/</id>
    <published>2020-11-01T07:28:58.807Z</published>
    <updated>2020-11-01T07:28:58.807Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><h1 id="HashCode-和equals方法"><a href="#HashCode-和equals方法" class="headerlink" title="HashCode 和equals方法"></a>HashCode 和equals方法</h1><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><p>hashCode可以翻译为哈希码，或者散列码。应该是一个表示对象的特征值的int整数。</p><a id="more"></a><p>创建一个值以后，缓存中有个行有个列，行+列 =hash码<br>equals方法应该用来判断两个对象从<strong>逻辑</strong>上是否相等<br>ps:(引用的==就代表两个引用是否在指向同一个对象)<br>如果eauals是true ,hashCode就应该相等<br>如果hashCode 相等，equals不一定为true</p><p><strong>String下的equals方法</strong><br><img src="https://img-blog.csdnimg.cn/20201024175535483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>因为java的优化，就相当于“永久代”，固定的存储空间（不了解的可以翻看我前面那一篇关于String类的解读）<br>所以当s2运行后，就自动会将s2存入s1的位置，所以“==”就为true。<br>“==”只有当字符串足够长时，java不会优化，也不会放在同一个位置，就会为false.<br>而equals()则会一个一个字符的相比，所以就一定为true</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次面试，对hashCode很是陌生，大家一定要对java基础有着一定的了解，一定要熟悉专属名词，“==”永远是比位置，看是否指向同一个对象，而equals在引用中是指逻辑上是否一致，在Sting中则是体现值是否相等！！</p><p>PEACE!!!!</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashCode-和equals方法&quot;&gt;&lt;a href=&quot;#HashCode-和equals方法&quot; class=&quot;headerlink&quot; title=&quot;HashCode 和equals方法&quot;&gt;&lt;/a&gt;HashCode 和equals方法&lt;/h1&gt;&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;p&gt;hashCode可以翻译为哈希码，或者散列码。应该是一个表示对象的特征值的int整数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在springmvc项目中CURD测试集分享</title>
    <link href="http://example.com/2020/11/01/CURD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://example.com/2020/11/01/CURD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</id>
    <published>2020-11-01T07:28:58.484Z</published>
    <updated>2020-11-01T07:28:58.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="一-想要对service层进行测试用例"><a href="#一-想要对service层进行测试用例" class="headerlink" title="一.想要对service层进行测试用例"></a>一.想要对service层进行测试用例</h2><p>1.首先将service层中的interface 中的方法进行重写<br><img src="https://img-blog.csdnimg.cn/20201014180321955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>css<a id="more"></a><br>2.然后实现此接口的类就会要求你实现此方法。<br><img src="https://img-blog.csdnimg.cn/20201014180331850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3.通过此类中的 entityDao方法进入DAO层，增加创建方法<br><img src="https://img-blog.csdnimg.cn/20201014180341608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.其中引用了application.xml中的自动匹配app-servlet中的mapper,进入编写增删查改SQL语句的底层。<br><img src="https://img-blog.csdnimg.cn/20201014180400924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>此刻基本已经编写完毕，基本上还是根据springMVC的基本原理进行<br>而后编写测试总类：<br><img src="https://img-blog.csdnimg.cn/20201014180412975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>通过运行application.xml，使用扫描注入所有@service 的类注入容器，搜寻authUserServiceImpl，开始创建对象，调用方法，按照刚刚上面写的示例走一遍业务，就可以实现创建对象。</p><p>PEACE！！！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;测试用例&quot;&gt;&lt;a href=&quot;#测试用例&quot; class=&quot;headerlink&quot; title=&quot;测试用例&quot;&gt;&lt;/a&gt;测试用例&lt;/h1&gt;&lt;h2 id=&quot;一-想要对service层进行测试用例&quot;&gt;&lt;a href=&quot;#一-想要对service层进行测试用例&quot; class=&quot;headerlink&quot; title=&quot;一.想要对service层进行测试用例&quot;&gt;&lt;/a&gt;一.想要对service层进行测试用例&lt;/h2&gt;&lt;p&gt;1.首先将service层中的interface 中的方法进行重写&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201014180321955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于ruoyi前后端分离部署的所思所想</title>
    <link href="http://example.com/2020/11/01/%E5%85%B3%E4%BA%8Eruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%20(1)/"/>
    <id>http://example.com/2020/11/01/%E5%85%B3%E4%BA%8Eruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%20(1)/</id>
    <published>2020-11-01T07:28:58.410Z</published>
    <updated>2020-11-01T07:28:58.410Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>前后端分离对于你命令行的锻炼，对lunix系统长期适应有着非常重要的作用<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、为什么要挑战前后端分离？"><a href="#一、为什么要挑战前后端分离？" class="headerlink" title="一、为什么要挑战前后端分离？"></a>一、为什么要挑战前后端分离？</h1><font color=#999AAA ><p>只是为了一种成就感，虚无缥缈的东西，让我能一直学习下去，通过配置后端软件，学到了很多lunix命令。这是意外收获，不败不馁，控制脾气。lunix系统在CENTOS7上顺利运行的时候我是非常高兴的，每次都在装载软件中卡住，但渐渐也终于熟悉，熟练，很高兴通过命令部署了一个前后端在不同主机运行的项目，我想这是一个程序员必备的东西吧。</p><p>css<a id="more"></a></p><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-引入文章，引自CodeSheep"><a href="#1-引入文章，引自CodeSheep" class="headerlink" title="1.引入文章，引自CodeSheep"></a>1.引入文章，引自CodeSheep</h2><font color=#999AAA >!<p><img src="https://img-blog.csdnimg.cn/20201012172904949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201012172931325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-来源"><a href="#2-来源" class="headerlink" title="2.来源"></a>2.来源</h2><font color=#999AAA >想要的可以去CodeSheep公众号去找<font color=#999AAA ><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color=#999AAA >我在这里想和大家说nginx这个软件一定要学会进入它的conf来配置，一次不成两次，学习DOS命令是一个很烦的过程，但是你熟练后悔对你未来有所帮助。mvn打包，jar包直接部署，确实是最简单的方式，前后端呼应的那一瞬间感觉真的很好。<p>感谢主！！！</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;/font&gt;




&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;前后端分离对于你命令行的锻炼，对lunix系统长期适应有着非常重要的作用&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;h1 id=&quot;一、为什么要挑战前后端分离？&quot;&gt;&lt;a href=&quot;#一、为什么要挑战前后端分离？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要挑战前后端分离？&quot;&gt;&lt;/a&gt;一、为什么要挑战前后端分离？&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;只是为了一种成就感，虚无缥缈的东西，让我能一直学习下去，通过配置后端软件，学到了很多lunix命令。这是意外收获，不败不馁，控制脾气。lunix系统在CENTOS7上顺利运行的时候我是非常高兴的，每次都在装载软件中卡住，但渐渐也终于熟悉，熟练，很高兴通过命令部署了一个前后端在不同主机运行的项目，我想这是一个程序员必备的东西吧。&lt;/p&gt;
&lt;p&gt;css</summary>
    
    
    
    
  </entry>
  
</feed>
