<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-04T01:35:30.915Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日深耕，勤练不缀之SQL连接表的操作</title>
    <link href="http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/11/03/SQL%E8%BF%9E%E6%8E%A5%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-03T14:02:24.260Z</published>
    <updated>2020-11-04T01:35:30.915Z</updated>
    
    <content type="html"><![CDATA[<p>SQL92<br>很强大的功能就是在各个数据表之间连接查询<br>JOIN在SQL中的作用<br>五种连接<br><strong>1.笛卡尔积</strong><br>笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能<br>我们假定player表的数据是集合X，先进行SQL查询</p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player </span><br></pre></td></tr></table></figure><p>再假定team表的数据为集合Y，同样进行SQL验证</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span>  team</span><br></pre></td></tr></table></figure><p>接下来是笛卡尔积的调用方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player,team</span><br></pre></td></tr></table></figure><p>执行结果<img src="https://img-blog.csdnimg.cn/20201103195856723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2.等值连接<br>两张表的等值连接就是用两张表都存在的列进行连接。我们也可以对多张表进行等值连接<br>而经过我们分析，两张表的等值就是队的ID,因为都存在，我们代码中必须＋表名加以区分<br>所以代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player.team_id,player_name,height,team_name</span><br><span class="line"><span class="keyword">FROM</span> player,team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103201731217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3.非等值连接<br>我们在进行多表查询的时候，如果连接多个表的条件是等号时，就是等值连接，其他的运算符都是非等值连接<br>PS：我们知道player表中有身高height字段，如果想要知道每个球员的身高的级别，可以采用非等值连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.player_id,p.player_name,p.height,h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> p,height_grades <span class="keyword">AS</span> h</span><br><span class="line"><span class="keyword">WHERE</span> p.height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://img-blog.csdnimg.cn/20201103202701344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.外连接（左连接，右连接）<br><strong>左外连接</strong>就是指左边的表是主表，需要显示左边表的全部行，而右侧的表是从表，（+）表示哪个是从表<br>相当于SQL99的left join</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player team </span><br><span class="line"><span class="keyword">WHERE</span> player.team_id = team.team_id(+)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  </span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team  <span class="comment">#显示主表的所有行</span></span><br><span class="line"><span class="keyword">ON</span> player.team_id = team.team_id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212346387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>右外连接</strong>，当然指的是右边的表为主表，显示右表的所有行，左侧的表为从表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> team</span><br><span class="line"><span class="keyword">ON</span> player.team_id =team.team_id <span class="comment"># 显示右表的所有行</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103212915704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.自连接<br>自连接可以对多个表进行操作，也可以对同一个表进行操作。也就是说查询条件使用了当前表的字段<br>我们想要查看比，布雷克 ·格里芬身高，高的球员都有谁？以及他们的对应身高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b.player_name ,b.height</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a ,player <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.player_name =<span class="string">&#x27;布雷克-格里芬&#x27;</span> <span class="keyword">and</span> a.height &lt; b.height</span><br></pre></td></tr></table></figure><p>这段自连接有点怪，搜出那个名字后，直接可以拿他的身高比就可以了<br>执行结果</p><p><img src="https://img-blog.csdnimg.cn/20201103214329297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>试着做一道题？<br>表格中一共有三支球队，那么现在3支球队需要进行比赛，请用SQL语句写出所有可能的比赛组合<br>分析：根据我的理解，我觉得是笛卡尔积，但是不可能。自己和自己不能比赛<br>那么是不是能笛卡尔积+左连接<br>事实证明我上面的分析都是错的！！！！</p><p>分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(kedui.team_name,<span class="string">&#x27;VS&#x27;</span>,zhudui.team_name) <span class="keyword">AS</span> <span class="string">&#x27;客队vs主队&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> zhudui <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> team <span class="keyword">AS</span> kedui</span><br><span class="line"><span class="keyword">ON</span> zhudui.team_id&lt;&gt;kedui.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020110322020619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>不分主客队</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.team_name ,b.team_name</span><br><span class="line"><span class="keyword">FROM</span> team <span class="keyword">AS</span> a,team <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id&lt;b.team_id</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201103220216610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SQL92&lt;br&gt;很强大的功能就是在各个数据表之间连接查询&lt;br&gt;JOIN在SQL中的作用&lt;br&gt;五种连接&lt;br&gt;&lt;strong&gt;1.笛卡尔积&lt;/strong&gt;&lt;br&gt;笛卡尔积是个数学运算。假设我有两个集合X和Y ，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能&lt;br&gt;我们假定player表的数据是集合X，先进行SQL查询&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之equals的基本特性，及自己对wait,notify的理解、join的理解</title>
    <link href="http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2020/11/03/equals%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%8C%E5%8F%8A%E8%87%AA%E5%B7%B1%E5%AF%B9wait,notify%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81join%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-03T10:53:25.158Z</published>
    <updated>2020-11-03T10:58:14.820Z</updated>
    
    <content type="html"><![CDATA[<p>自反性：对于任何非空引用值x,x.equals(x)都应返回true<br>对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true<br>传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.<br>一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值</p><a id="more"></a><p>equals注意事项：<br>对象域，使用equals方法<br>类型安全的枚举，使用equals或者==<br>可能为null的对象域：使用equals或者==<br>数组域，使用Arrays.equals</p><p>有一个问题：notify()会立刻释放锁吗？<br>答案是：不会<br>多个线程之间有互动关系的时候，某个线程得等一会儿wait()，等notify()提醒他，这就是互动模式<br>wait()是让线程等待的方法（线程释放对象锁，进入等待池；所以必须先得获得锁，wait必须写在synchronized代码块中，否则会报异常）<br>notify()是提醒线程该运行的方法（唤醒等待该对象同步锁的线程，放线程进入锁池中，竞争得到对象锁，然后开始执行）<br>notify唤醒的线程，都是随机唤醒的，没有顺序之分<br>notify All唤醒的线程，符合后进先出的原则<br>都是Object方法<br>所以说，notify 和notifyALL并不会立即释放对象锁，必须等到synchronized方法或者语法块执行完才能真正释放锁。然后线程去竞争。<br>贴代码：生产者和消费者<br>消费者：我用三个线程去执行队列里由生产者产生的任务(因为会产生交互，都是执行的一个队列的任务，所以任务队列得加synchronzied锁)<br>生产者：我用100个线程生产任务<br>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mport java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTaskCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;T&gt; tasks, <span class="keyword">int</span> maxTaskCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">        <span class="keyword">this</span>.maxTaskCount = maxTaskCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(T task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果这个检查不在synchronized块里会怎么样呢？</span></span><br><span class="line">            <span class="comment">// TODO 如果如果不用while会怎么样呢？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() &gt;= maxTaskCount) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(task);</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue&lt;T&gt; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks = tasks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果不用while，用if，会怎么样？</span></span><br><span class="line">            <span class="keyword">while</span> (tasks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者线程进入等待：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// &gt;&gt; TODO wait方法会释放monitor</span></span><br><span class="line">                tasks.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = tasks.poll();</span><br><span class="line">            <span class="comment">// &gt;&gt; TODO 调用notify或者notifyAll的时候，必须已经获得对象的monitor，也就是在对象的synchronized块中</span></span><br><span class="line">            tasks.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object LOCKER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; urls = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;&gt;(urls);</span><br><span class="line">        Producer&lt;String&gt; producer = <span class="keyword">new</span> Producer&lt;&gt;(urls, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread consumerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = consumer.consume();</span><br><span class="line">                        processURL(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;消费者-&quot;</span> + i);</span><br><span class="line">            consumerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread producerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String url = produceURL();</span><br><span class="line">                        producer.produce(url);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;生产者-&quot;</span> + i);</span><br><span class="line">            producerThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 如果想给生产者消费者做一个统计，统计每个生产者消费者所生产/消费的task的数量，应该</span></span><br><span class="line">        <span class="comment">// TODO 1）使用哪种数据结构？</span></span><br><span class="line">        <span class="comment">// TODO 2）如何保证线程安全？</span></span><br><span class="line">        <span class="comment">// TODO 3）怎么将统计结果输出到控制台？</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">produceURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ret.append(<span class="string">&quot;www.&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.append(<span class="string">&quot;.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processURL</span><span class="params">(String url)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理：&quot;</span> + url);</span><br><span class="line">        Thread.sleep(TimeUnit.SECONDS.toMillis(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;处理完成：&quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>粗略涉及一下join方法<br>join方法同步<br>就涉及范围更广了<br>比如一个线程A.join，<br>那么下一个线程就必须等待A执行完，才能执行<br><strong>我现在理解的多线程是并发执行不同的任务，一些需要交互的用synchronized,wait/notify、join方法保证，整体并发时间肯定比一个个执行线程的时间少</strong><br>下面我贴一个代码！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.geekbang.join;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinAppMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; CONTENTS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> WORKING_DURATION = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainStart = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:开始抓取网页内容&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                String content = getContentFromWeb();</span><br><span class="line">                <span class="keyword">long</span> threadWorkingDuration = System.currentTimeMillis() - start;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:抓取网页内容结束&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (CONTENTS) &#123;</span><br><span class="line">                    CONTENTS.add(content);</span><br><span class="line">                    WORKING_DURATION += threadWorkingDuration;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;线程&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO sleep一下，让线程都启动起来</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程开始 join  ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String name = thread.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程开始join &quot;</span> + name + <span class="string">&quot; ------------ &quot;</span>);</span><br><span class="line">                thread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot; ------------ 主线程join &quot;</span> + name + <span class="string">&quot; 结束 ------------ &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; ------------ 主线程join结束，获取的内容为： ------------ &quot;</span>);</span><br><span class="line"></span><br><span class="line">        CONTENTS.forEach(s -&gt; &#123;</span><br><span class="line">            System.out.print(s.length() + <span class="string">&quot;：&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> mainWorkDuration = System.currentTimeMillis() - mainStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 多线程的意义就是让工作并发的处理，使用更多的资源（CPU，磁盘，网络等），以便让工作更快的完成。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程累计工作时间：&quot;</span> + WORKING_DURATION);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程工作时间：&quot;</span> + mainWorkDuration);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getContentFromWeb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000000</span>)) % <span class="number">4096</span> + <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = ((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>)) % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (rand + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ret.append(ch);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工作线程累计工作时间：33466<br>主线程工作时间：6727<br>线程累计时间多，而并发线程时间少！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自反性：对于任何非空引用值x,x.equals(x)都应返回true&lt;br&gt;对称性：对于任何非空引用值x和y,当且仅当y.equals(x)返回true时，x.equals（y）才应返回true&lt;br&gt;传递性：对于任何非空引用值x,y和z,如果x.equals(y)返回true,,并且y.equals(z)返回true,那么x.equals(z)应返回true.&lt;br&gt;一致性：对于任何非空引用值x和y,多次调用x.equals(y)或者y.equals(x)都返回同一逻辑值&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Hashtable、HashMap、TreeMap</title>
    <link href="http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/"/>
    <id>http://example.com/2020/11/03/Hashtable%E3%80%81HashMap%E3%80%81TreeMap%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F/</id>
    <published>2020-11-03T05:50:17.860Z</published>
    <updated>2020-11-03T05:55:22.329Z</updated>
    
    <content type="html"><![CDATA[<p>map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现</p><p>Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。</p><a id="more"></a><p>HashMap与Hashtable行为基本上一致，不一样的地方在于HashMap<strong>不是同步</strong>的，<strong>支持null键和值</strong><br>通常，HashMap进行put或者get操作，可以达到常数时间的性能,因此使我们利用键值对存取场景的首选。比如：<br>用户ID –用户信息对应的运行时存储结构</p><p>Treemap是基于红黑树的一种提供<strong>访问顺序</strong>的Map，和HashMap不同，它的get,put,remove的时间复杂度都是O（log(n)）,具体顺序由指定的Comparator来决定，或者由键的自然顺序来判断</p><p><strong>HashMap的设计和实现细节</strong><br>  HashMap扩展了abstractMap，且非常依赖于哈希码的有效性：<br>  1.equals相等，hashcode一定相等<br>  2.hashcode改写以后也要改写equals<br>  3.hashCode需要保持一致性，状态改变返回的哈希值仍然要一致<br>  4.equals的对称，反射，传递等特性（下篇博客写）</p><p> <strong>有序Map</strong><br> LinkedHashMap和TreeMap都可以保证某种顺序<br> 1.linkedHashMap提供的遍历顺序符合插入顺序，它的实现是通过为键值对维护一个双向链表，<br> 通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的put,get,compute都算作“访问”。<br> 场景：构建一个空间占用敏感化的资源池，希望可以自动将最不常被访问的对象释放掉，使用LInkedHashMap来实现<br> 2.对于TreeMap,它的整体顺序是由键的顺序来决定，通过comparator或Comparable（自然顺序：必须符合约定：comparaTo的返回值需要和equals一致）来决定。<br> 代码如下，经常复盘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = …</span><br><span class="line">    cmp = k.compareTo(t.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        t = t.left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">        t = t.right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>构建一个优先级的调度系统的问题，其本质就是一个典型的有限队列场景，Java标准类库提供了基于二叉堆实现的PriorityQueue,TreeMap和TreeSet也是依赖于此。</p><p><strong>HashMap内部基本点分析</strong><br>可以看作是<strong>数组（Node&lt;K,V&gt;[]table）</strong>和<strong>链表</strong>组成的符合结构<br>数组被分为一个个桶，通过哈希值决定键值对在这个数组的寻址。<br>哈希值相同的键值对，就按照链表形式存储。<br>如果链表超过阈值，就会被改造成树形结构。</p><p>这个数组似乎并没有被初始化好，仅仅设置了一些初始值而已<br>看代码就知道</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;  </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们认为HashMap也许是按照lazy-load原则，在首次使用时初始化。<br>只有putVal的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evit)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> , i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line">        tab[i] = newNode(hash, key, value, nll);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for first </span></span><br><span class="line">           treeifyBin(tab, hash);</span><br><span class="line">        <span class="comment">//  ... </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表格是null,resize就会负责初始化它，这从tab=<br>resize()可以看出</p><p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足要求的时候，进行扩容（resize）</p><p>在放置新的键值对的过程中，如果发生下面这种情况，就会发生扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>具体键值对在哈希表的位置（数组Index）取决于下面的位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>学过数据结构的都知道，它并不是key本身的hashCode,而是来自于HashMap里面的另外一个hash方法。<br><strong>为什么将高位数据移位到低位进行异或运算？</strong><br>计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，这种<strong>处理就可以有效避免类似情况下的哈希碰撞</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> h;</span><br><span class="line">           <span class="keyword">return</span> (key =<span class="keyword">null</span>)?<span class="number">0</span>:(h= key.hashCode())^(h&gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>为什么树化？对链表（bin）进行怎样的处理？</strong></p><p>可以看出，putVal方法本身逻辑非常集中，从初始化，扩容到树化，都有参与<br>依据resize源码，在不考虑极端情况下的（容量理论最大极限由 MAXIMUM_CAPACITY指定，数值为1&lt;&lt;30,即2^30次方）：<br>我们可以归纳为<strong>门限值</strong>=负载因子*容量，我们通常用默认值<br><strong>门限值（就是数组的最大参数）</strong>通常以倍数调整，当元素个数超过门限大小是，即调整Map大小<br>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源</p><p><strong>容量，负载因子，树化？</strong><br>还是数据结构的原理<br>容量和负载因子都是数组的标准条件，相当于当时学过的寻找大于元素数量的最小的素数来当做数组。<br>就相当于桶的数量，太少和占用太满都会影响操作的性能</p><p>负载因子：不超过0.75<br>如果使用太小的负载因子，则用导致更加频繁的扩容，增加开销成本</p><p>树化改造，不外乎对应逻辑就是putVal和treeIfyBin中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">           <span class="keyword">int</span> n,index;</span><br><span class="line">           Node&lt;K,V&gt; e;</span><br><span class="line">           <span class="keyword">if</span> (tab ==<span class="keyword">null</span> ||(n =tab.length)&lt;MIN_TREEIFY_CAPACITY)</span><br><span class="line">               resize();<span class="comment">//创建数组</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>((e=tab[index =(n-<span class="number">1</span>)&amp;hash])! =<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//树化逻辑改造</span></span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>数组判定条件：当bin的数量大于TREEIFY_THRESHOLD（默认是8）的条件下：（一个桶中有8个元素），允许红黑树化<br>—&gt;接下来有判定条件：<br>如果容量小于MIN_TREEIFY_CAPACITY，只会进行简单的扩容<br>如果容量大于MIN_TREEIFY_CAPACITY（最小树形阈值）<br>则进行红黑树化</p><p>本质上是一个安全问题，如果哈希冲突，都会放置同一个桶里，形成链表，我们知道链表是线性的，会影响存取的性能。<br>第二是因为构造哈希冲突的数据并不是非常复杂的事情，恶意代码可以利用这些数据大量与服务器交互，从而让服务器CPU被大量占用，造成崩溃，所以允许树化，再不济进行扩容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;map我们都知道来源于key-value的认识。以键值对的形式存储和操作数据的容器类型。而上面的这些都是Map的常见实现&lt;/p&gt;
&lt;p&gt;Hashtable 是早期java类库类库提供的一个哈希表实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，不推荐使用。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之sql子查询</title>
    <link href="http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    <id>http://example.com/2020/11/02/sql%E5%AD%90%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-11-02T11:40:50.925Z</published>
    <updated>2020-11-02T11:43:39.213Z</updated>
    
    <content type="html"><![CDATA[<p>本文应用sql数据均从github上下载<br>需要的小伙伴自取<a href="https://github.com/cystanford/sql_nba_data.git">https://github.com/cystanford/sql_nba_data.git</a><br>查询结果集<br><strong>关联子查询:</strong> 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部</p><a id="more"></a><p>我们想要查找球队中大于平均身高的球员有哪些？并显示他们的球员姓名身高和所在球队ID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height,team_id</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(height)</span><br><span class="line"><span class="keyword">FROM</span> player  <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.team_id =b.team_id)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次查询都得执行一次子语句</p><p>通常关联子查询也会和EXISTS一起使用<br>比如我们想看出场过的球员有哪些？并且显示他们的姓名，id，球队ID</p><p>是否出场可以通过player_score此表来查询，因为在player_score有出场记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,team_id</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> player_id  <span class="keyword">FROM</span> player_score</span><br><span class="line"><span class="keyword">WHERE</span> player.player_id =player_score.player_id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IN和EXISTS虽然查询结果一样，但是效率确不一样，<br>如果A表比B表小，EXISTS效率高，因为查询时可以使用A表对于play_id的索引，反之，则IN效率更高(小表驱动大表更有效率)</p><p>ANY ,ALL<br>举例：<br>想要查询球员表中，比印第安纳步行者team_id=002那只队中任意一个球员身高高的所有球员信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ANY</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id,player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height &gt;</span><br><span class="line"><span class="keyword">ALL</span> (<span class="keyword">SELECT</span> height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> team_id =<span class="number">1002</span>)</span><br></pre></td></tr></table></figure><p><strong>将子查询作为主查询的计算字段（把子查询的结果当做主查询的列）</strong><br>比如我想查询每个球队的球员数，也就是对应那个team_id ,相同的team_id在player这张表中球员数量是多少</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> team_name,(<span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id)</span><br><span class="line"><span class="keyword">AS</span> player_num</span><br><span class="line"><span class="keyword">FROM</span> team</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AS player_num</span><br></pre></td></tr></table></figure><p>是给</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id=team.team_id</span><br></pre></td></tr></table></figure><p>起了个别名，方便我们使用</p><p>最后出个题：<br>编写SQL语句，得到场均得分大于20的球员（场均得分从player_score表中获取，同时你需要输出球员的ID，球员姓名及所在球队的ID信息）<br>我的理解是：<br>1.场均得分大于20，第一场得了40分，第二场得了2分，场均为21分照样满足条件<br>2.一场比赛中，球员可以出现多次<br>解析思路：先得出球员在每场比赛中的总分数，然后对球员按比赛分组，计算球员在所参加比赛中的平均分数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t2.player_id,t2.player_name,t2.team_id,t3.v</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> t1.player_id,<span class="keyword">avg</span>(t1.total) <span class="keyword">AS</span> v</span><br><span class="line">     <span class="keyword">FROM</span> </span><br><span class="line">       (<span class="keyword">SELECT</span> player_id,<span class="keyword">SUM</span>(score) <span class="keyword">AS</span> total   <span class="keyword">FROM</span> player_score   <span class="keyword">WHERE</span> game_id <span class="keyword">IN</span>  (<span class="keyword">SELECT</span> game_id <span class="keyword">FROM</span> player_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> game_id) </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> player_id <span class="comment">#对球员进行分组，计算在每场比赛的总分数</span></span><br><span class="line">        )<span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t1.player_id <span class="comment">#对球员分组，计算每场比赛的均分</span></span><br><span class="line"><span class="keyword">HAVING</span> v&gt;<span class="number">20</span> <span class="comment">#对分组进行筛选</span></span><br><span class="line">)<span class="keyword">AS</span> t3 <span class="keyword">ON</span> t2.player_id =t3.player_id</span><br></pre></td></tr></table></figure><p>本题有点难度！！！！<br>要经常回来复盘！！<br>答案贴在这<br><img src="https://img-blog.csdnimg.cn/20201102193901622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>**非关联子查询:**只作为主查询的条件语句执行一次</p><p>我们想要找nba球员中谁最高？<br>且输出他的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height=(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(height) <span class="keyword">FROM</span> player)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文应用sql数据均从github上下载&lt;br&gt;需要的小伙伴自取&lt;a href=&quot;https://github.com/cystanford/sql_nba_data.git&quot;&gt;https://github.com/cystanford/sql_nba_data.git&lt;/a&gt;&lt;br&gt;查询结果集&lt;br&gt;&lt;strong&gt;关联子查询:&lt;/strong&gt; 子查询需要执行多次，采用循环的方式，先从外部查询开始，每次传入子查询进行查询，再将结果反馈给外部&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之动态代理篇</title>
    <link href="http://example.com/2020/11/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>http://example.com/2020/11/01/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F/</id>
    <published>2020-11-01T08:31:21.555Z</published>
    <updated>2020-11-01T08:54:58.791Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font>编程语言分类角度：1.动态类型和静态类型2.强类型和弱类型<a id="more"></a>在这里我们复习一下JAVA的反射机制反射机制是赋予程序运行时自省（introspect）的能力能通过反射直接操作类和对象1.获取某个对象的类定义2.获取类声明的属性和方法，调用方法和构造方法运行时修改类定义<p>动态代理是一种方便运行时动态构建代理，动态处理代理方法调用的机制，很多场景都是利用类似机制机制做到的<br>用来包装RPC调用，面向切面的编程。</p><p>实现动态代理的方式：<br>1.JDK自身提供的动态代理，反射机制<br>2.更高性能的字节码操作机制，ASM,cglib,javassist</p><p>反射赋予了java语言活力，通过运行时操作元数据或对象，java可以灵活地操作运行时才能确定的信息。</p><p><strong>1.考察你对反射机制的了解及掌握程度？</strong><br>Class 、Field、Method、Constructor 就是操作类和对象的元数据对应，官方API文档：<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">https://docs.oracle.com/javase/tutorial/reflect/index.html</a><br>对于反射，AccessibleObject.setAccessible(boolean flag)<br>其子类也大多重写了这个方法，这个accessible可以修饰成员访问限制，这意味着程序运行时我们照样可以修改成员访问限制。<br>java9以后，加入一个open机制，只有当被反射操作的模块和指定的包对反射调用者Open，才能用setAccessible<br>比如：开发 、测试、依赖注入<br>O/R Mapping框架中，为java实体自动生成getter setter 方法<br>框架可以利用反射做这个事情，而不需要开发者手动写重复代码。<br>使用反射绕开限制，我们日常开发调用内部API去做事情，<br>例如： 自定义的高性能NIO框架显式地释放DirectBuffer<br><strong>2.动态代理解决了什么问题，你在业务系统中的应用场景是什么？</strong><br>代理是对调用目标的一个包装，这样我们对目标代码的调用不是直接发生的，而是通过代理完成<br>通过代理可以让调用者和实现者之间解耦，如：RPC调用，框架内部的寻址，序列化，反序列化</p><p><strong>3.JDK动态代理在设计和实现上与cglib等方式有什么不同？如何取舍？</strong><br>ciglib采用的时<strong>创建目标类的子类</strong>的方式，近似使用被调用者本身的效果，在Spring编程中，框架通常会处理这种情况</p><p><strong>JDK Proxy的优势</strong><br>最小化依赖关系<br>平滑进行JDK版本升级，而字节码类库通常还需进行更新<br>代码</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;
编程语言分类角度：1.动态类型和静态类型
2.强类型和弱类型</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之int和interger的区别（续）篇</title>
    <link href="http://example.com/2020/11/01/int%E5%92%8Cinterger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://example.com/2020/11/01/int%E5%92%8Cinterger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E7%BB%AD%EF%BC%89/</id>
    <published>2020-11-01T08:29:13.202Z</published>
    <updated>2020-11-01T08:57:56.969Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font>原始数据类型为八大类我们先复习一下我们学过的int ：基本数据类型，不用声明直接使用interger：是int的封装类。需要声明，但是JAVA给其自动装箱开箱（抽象为类，new 一个对象）的功能，让其可以自由像int一样自由赋值interger的值缓存，java5提供了静态工厂方法valueof但是有valueof的限制，调用一个缓存机制，interger取值范围在-128—127之间，且只能在这个范围内比较<a id="more"></a><p><strong>问题1：编译阶段、运行时，自动装箱/自动拆箱是发生在什么阶段？</strong><br>自动装箱和开箱其实是一种语法糖，Java平台自动为我们进行了一些转换，保证在编译时生成的字节码是一致的。<br>javac自动把装箱转换成了Interger.valueOf(),把开箱转换成了Interger.intValue(),装箱的时候调用了方法，肯定也应用到了缓存机制<br><strong>问题2：使用静态工厂方法valueof会使用缓存机制，那么自动装箱的时候，缓存机制其作用吗？</strong><br>上一题已经回答了<br>这一种<strong>缓存机制</strong>并不是interger独有，同样存在其他基本类型的包装类：<br>如：1.Boolean,缓存了true/false对应实例，确切说，只会返回两个常量实例Boolean.TRUE/FALSE<br>2.Short,同样缓存了-128—127之间的数值<br>3.Byte 数值有限，所以全部被缓存<br>4.Character,缓存范围’\u0000’—‘\u007F’<br>自动装箱和开箱很酷，有什么需要注意的吗？<br>原则上尽量避免无意识的开箱装箱，尤其是性能敏感的场合，创建10万个java对象是相对于创建10万个整数的是高量级，不管是内存占用还是处理时速度都会变慢<br><strong>问题3：为什么我们需要原始数据类型，Java的对象似乎也很高效，应用中具体会产生哪些差异？</strong><br> 使用原始数据类型，数组甚至本地代码实现。在性能极度敏感的场景，用其替换掉包装类，动态数组<br><strong>问题4：阅读过Interger源码吗？分析下类或者某些方法的设计要点</strong><br>虽然interger的默认缓存值为-128-127，但是我们也可以根据需要调整，调整代码为：</p><p>-XX：AutoBoxCacheMax=N<br>这些都体现在java.lang.Interger的静态代码初始块里</p><p><strong>Interger等包装类，定义了SIZE或者BYTES这样的常量，</strong>这样的设计考虑是因为在32或者64位中JDK中，不需要移植工作。</p><p><strong>原始类型线程安全</strong><br><strong>java原始数据类型和引用类型局限性</strong><br>原始数据类型并不能和泛型一起使用<br>java的对象都是引用类型，如果一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，往往分散于存储堆的不同位置，这种设计虽然带了极大的灵活性，也导致了数据操作的低效。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;
原始数据类型为八大类
我们先复习一下我们学过的
int ：基本数据类型，不用声明直接使用
interger：是int的封装类。需要声明，但是JAVA给其自动装箱开箱（抽象为类，new 一个对象）的功能，让其可以自由像int一样自由赋值
interger的值缓存，java5提供了静态工厂方法valueof
但是有valueof的限制，调用一个缓存机制，interger取值范围在-128—127之间，且只能在这个范围内比较</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>RUOYI项目初级涉猎篇</title>
    <link href="http://example.com/2020/11/01/RUOYI%20Spring%20boot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%201/"/>
    <id>http://example.com/2020/11/01/RUOYI%20Spring%20boot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%201/</id>
    <published>2020-11-01T07:29:01.416Z</published>
    <updated>2020-11-01T07:29:01.416Z</updated>
    
    <content type="html"><![CDATA[<p>@[cwxprogrammer</p><h1 id="项目场景：ruoyi-spring-boot项目打怪升级"><a href="#项目场景：ruoyi-spring-boot项目打怪升级" class="headerlink" title="项目场景：ruoyi spring boot项目打怪升级"></a>项目场景：ruoyi spring boot项目打怪升级</h1><h1 id="学习目标：掌握其中的一些知识，分享给一起努力的人"><a href="#学习目标：掌握其中的一些知识，分享给一起努力的人" class="headerlink" title="学习目标：掌握其中的一些知识，分享给一起努力的人"></a>学习目标：掌握其中的一些知识，分享给一起努力的人</h1><font color=#999AAA >两天把ruoyi部署起来，根据文档会打点理解其中模块的作用和实现原理<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><font color=#999AAA ><p>大家先理解一下Spring boot的意思，极大解放了广大程序员，利用maven依赖的繁琐，利用web.xml加载Spring,以及最终的tomcat部署，这是最令人绝望的，而Spring boot使xml -bean的历史彻底过去，使用了各种Starter,配置方面完全自动配置，自动注入，部署有内嵌tomcat,非常香。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习时间："><a href="#学习时间：" class="headerlink" title="学习时间："></a>学习时间：</h1><font color=#999AAA ><p>1、 周一至周五晚上 7 点—晚上9点<br>2、 周六上午 9 点-上午 11 点<br>3、 周日下午 3 点-下午 6 点</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习产出："><a href="#学习产出：" class="headerlink" title="学习产出："></a>学习产出：</h1><p><font color=#999AAA >提示：这里统计学习计划的总量<br>例如：<br>1、 技术笔记 2 遍<br>2、个人 技术博客 1篇<br>3、 学习的 vlog 视频 1 个</p><font color=#999AAA >RuoYi是一款基于SpringBoot+Bootstrap的极速后台开发框架。</font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>1.<img src="https://img-blog.csdnimg.cn/20201008144322646.png#pic_center" alt="在这里插入图片描述"><br>2.<br>java.sql.SQLNonTransientConnectionException: CLIENT_PLUGIN_AUTH is required</p> </font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">css<a id="more"></a># 原因分析：<font color=#999AAA >第一个好解决，看以下截图</font><p><img src="https://img-blog.csdnimg.cn/2020101010413597.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201010104218397.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201010104252672.png#pic_center" alt="把这个勾子点去"><br><font color=#999AAA ><br>第二个问题本来不应该算问题，我的电脑MYSQL安装的是5.0，但我却误认为8.0.19，导致自己JAR包导错，导致数据库连接失败，给新手一个提示，虽然有可能你的内存中装着两个数据库，但一定要看哪个起作用，从navicat最右面中间位置，看截图<br></font><br><img src="https://img-blog.csdnimg.cn/20201010105041517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="项目场景："><a href="#项目场景：" class="headerlink" title="项目场景："></a>项目场景：</h1><font color=#999AAA >1.还有一个问题值得注意 ，就是大家一定要多看RUOYI文件包里面自带的文档，就那个DOC文件包。2.如果想要前后端分离的系统，那就得先准备虚拟机节点，在虚拟机上面装一个lunix系统，具体我也是看B站CodeSheep弄的，保姆级教程，前后端分离的RUOYI需要花费时间。</font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h1><font color=#999AAA >值得注意的是，大家都是普通人，如果一个软件在耗费你时间两个小时的基础上都装不好的话，那就试试借助外力，比如淘宝网，当然我鼓励大家自己装，但是要算对账。</font>]]></content>
    
    
    <summary type="html">&lt;p&gt;@[cwxprogrammer&lt;/p&gt;
&lt;h1 id=&quot;项目场景：ruoyi-spring-boot项目打怪升级&quot;&gt;&lt;a href=&quot;#项目场景：ruoyi-spring-boot项目打怪升级&quot; class=&quot;headerlink&quot; title=&quot;项目场景：ruoyi spring boot项目打怪升级&quot;&gt;&lt;/a&gt;项目场景：ruoyi spring boot项目打怪升级&lt;/h1&gt;&lt;h1 id=&quot;学习目标：掌握其中的一些知识，分享给一起努力的人&quot;&gt;&lt;a href=&quot;#学习目标：掌握其中的一些知识，分享给一起努力的人&quot; class=&quot;headerlink&quot; title=&quot;学习目标：掌握其中的一些知识，分享给一起努力的人&quot;&gt;&lt;/a&gt;学习目标：掌握其中的一些知识，分享给一起努力的人&lt;/h1&gt;&lt;font color=#999AAA &gt;
两天把ruoyi部署起来，根据文档会打点理解其中模块的作用和实现原理
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习内容：&quot;&gt;&lt;a href=&quot;#学习内容：&quot; class=&quot;headerlink&quot; title=&quot;学习内容：&quot;&gt;&lt;/a&gt;学习内容：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;大家先理解一下Spring boot的意思，极大解放了广大程序员，利用maven依赖的繁琐，利用web.xml加载Spring,以及最终的tomcat部署，这是最令人绝望的，而Spring boot使xml -bean的历史彻底过去，使用了各种Starter,配置方面完全自动配置，自动注入，部署有内嵌tomcat,非常香。&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习时间：&quot;&gt;&lt;a href=&quot;#学习时间：&quot; class=&quot;headerlink&quot; title=&quot;学习时间：&quot;&gt;&lt;/a&gt;学习时间：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;1、 周一至周五晚上 7 点—晚上9点&lt;br&gt;2、 周六上午 9 点-上午 11 点&lt;br&gt;3、 周日下午 3 点-下午 6 点&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习产出：&quot;&gt;&lt;a href=&quot;#学习产出：&quot; class=&quot;headerlink&quot; title=&quot;学习产出：&quot;&gt;&lt;/a&gt;学习产出：&lt;/h1&gt;&lt;p&gt;&lt;font color=#999AAA &gt;提示：这里统计学习计划的总量&lt;br&gt;例如：&lt;br&gt;1、 技术笔记 2 遍&lt;br&gt;2、个人 技术博客 1篇&lt;br&gt;3、 学习的 vlog 视频 1 个&lt;/p&gt;
&lt;font color=#999AAA &gt;
RuoYi是一款基于SpringBoot+Bootstrap的极速后台开发框架。
&lt;/font&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h1&gt;&lt;p&gt;1.&lt;img src=&quot;https://img-blog.csdnimg.cn/20201008144322646.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;2.&lt;br&gt;java.sql.SQLNonTransientConnectionException: CLIENT_PLUGIN_AUTH is required&lt;/p&gt;
 &lt;/font&gt;


&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;
css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之反射篇</title>
    <link href="http://example.com/2020/11/01/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://example.com/2020/11/01/java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/</id>
    <published>2020-11-01T07:29:01.159Z</published>
    <updated>2020-11-01T07:29:01.159Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><h1 id="本节的内容是反射（reflection）"><a href="#本节的内容是反射（reflection）" class="headerlink" title="本节的内容是反射（reflection）"></a>本节的内容是反射（reflection）</h1><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><a id="more"></a><p>Class(注意大写)，是类的类<br>Class clazz =MerchandiseV2.class</p><p><img src="https://img-blog.csdnimg.cn/20201025155334840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此处string[ ]是一个变长函数，可以自定义变长。</p><p><strong>使用反射（reflection）访问属性</strong><br>          Field countField = clazz.getField(“count”);<br>          System.out.println(countField.get(m100));<br>          countField.set(m100,888);<br>          System.out.println(countField.get(m100));<br>          System.out.println(m100.count);<br>也许通过这段代码你可以理解Field 的意义，Field代表在Class clazz定义的那个类里的所有成员变量。<br>所以才会有这句<br> Field <strong>countField</strong> = clazz.getField(“<strong>count</strong>“);<br>下面我们可以通过遍历更加了解Field<br><img src="https://img-blog.csdnimg.cn/20201025164134960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这是另一种调用方法。<br>我们还可以调用静态变量<br>Field field =clazz.getField(name:”STATIC_MEMBER”);<br>System.out.println(field.get(null));</p><p>通过反射调用成员变量和静态变量</p><p>当然，我们需要清楚我们定义的clazz必须是这个类本类或者是这个类的父类才行。</p><p>接下来呢，我们要利用反射来调用clazz这个类中的方法：</p><p><img src="https://img-blog.csdnimg.cn/20201025172049961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201025172351230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来<br>我们演示一下<br><strong>反射能做到，平常调用做不到的方法</strong><br>调用private 的方法和属性<br><img src="https://img-blog.csdnimg.cn/20201025172638221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201025173407495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="调入private的属性"><br><img src="https://img-blog.csdnimg.cn/20201025173454859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="调用private的方法"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>反射一个高级语言里的 通用功能，通过这样一种方式动态的来执行一些方法<br>比如：你不知道一个地方的经纬度，也能调用它的属性方法，不需要精确，但必须知道有这么个实例。<br>但是有一点就是反射比较慢，找的时候慢，执行方法速度一样。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;本节的内容是反射（reflection）&quot;&gt;&lt;a href=&quot;#本节的内容是反射（reflection）&quot; class=&quot;headerlink&quot; title=&quot;本节的内容是反射（reflection）&quot;&gt;&lt;/a&gt;本节的内容是反射（reflection）&lt;/h1&gt;&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Iterator篇</title>
    <link href="http://example.com/2020/11/01/Iterator%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2020/11/01/Iterator%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-11-01T07:29:00.379Z</published>
    <updated>2020-11-01T07:29:00.379Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >**Iterator接口**<a id="more"></a>点两下shfit 就可以查找class 类型  符号 从Java4以后就有了hasNext()next()Iterable接口，实现这个接口就可以支持forEach循环，只有一个方法Iterator()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pointer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pointer &lt; size();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (T) elements[pointer++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">addElementsToCollection</span><span class="params">(Collection collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            collection.add(<span class="string">&quot;str&quot;</span> + (i % <span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection collection)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;输出&quot;</span> + collection.getClass() + <span class="string">&quot;中的元素，共&quot;</span> + collection.size() + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object element : collection) &#123;</span><br><span class="line">                System.out.println(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后存入一个集合里头的元素，利用iterator将其输出出来</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
**Iterator接口**</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之java9大基础类型</title>
    <link href="http://example.com/2020/11/01/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/11/01/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-11-01T07:29:00.347Z</published>
    <updated>2020-11-01T07:29:00.347Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？"><a href="#一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？" class="headerlink" title="一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？"></a>一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？</h1><a id="more"></a><p>我先说Java九大类型，byte(1)  short(2)  int(4)    long(8)<br>float(4)   double(8)  char(2)  boolean  void<br>对应的封装类： Byte  Short  interger  Long  Float<br>Double Character  Boolean Void</p><p>1.int是基本数据类型，interger 是封装类型<br>2.前者默认值是0,后者默认值为null。所以可以从侧面判断interger数值为0，还是没赋值<br>3.前者不用实例化，后者需要实例化，且有自动开箱功能。如：4.interger a =1;相当于 interger a =new interger(1);<br>5.前者可以和后者直接比较：两个数值相等就为相等<br>6.在-128 –127数值范围内，interger是可以比较的，越过这个范围，interger就会重新new.</p><font color=#999AAA ><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color=#999AAA ><p>以上就是今天要分享的内容，老生常谈，写出来也许看的人不会，但是你分享过后，你肯定会了！！</p><p>css<!--more--></p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;h1 id=&quot;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot;&gt;&lt;a href=&quot;#一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot; class=&quot;headerlink&quot; title=&quot;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&quot;&gt;&lt;/a&gt;一、int和interger的区别？顺便说说java九大基本类型，以及他们的封装类？&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之jdk和GC篇</title>
    <link href="http://example.com/2020/11/01/jrejdk%20gc/"/>
    <id>http://example.com/2020/11/01/jrejdk%20gc/</id>
    <published>2020-11-01T07:29:00.300Z</published>
    <updated>2020-11-01T07:29:00.300Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、1-谈谈你对java平台的理解？"><a href="#一、1-谈谈你对java平台的理解？" class="headerlink" title="一、1.谈谈你对java平台的理解？"></a>一、1.谈谈你对java平台的理解？</h1><a id="more"></a><p>书写一次，到处执行。<br>JDK是Java Development Kit  ,是Java的开发套件<br>JRE是 Java Runtime Environment，是运行java的环境<br>JDK包含了JRE，而且还包含了很多和开发调试程序相关的工具<br>1.Javac编译成为字节码，再通过JVM内嵌的解释器将字节码转换为最终的机器码<br>2.JVM会通过类加载器（class -Loader）加载字节码，解释或者编译执行<br> Jsut in time 简称 JIT<br>Jdk9引入了AOT将字节码编译成机器代码</p><h1 id="二、垃圾收集（Garbage-Collection）"><a href="#二、垃圾收集（Garbage-Collection）" class="headerlink" title="二、垃圾收集（Garbage Collection）"></a>二、垃圾收集（Garbage Collection）</h1><p>Java通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收<br>最常用的垃圾收集：SerialGC  、Parallel GC 、CMS 、G1</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>都是些零碎的小知识，大家要见谅，也不要嘲笑，都是深耕。</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;


&lt;h1 id=&quot;一、1-谈谈你对java平台的理解？&quot;&gt;&lt;a href=&quot;#一、1-谈谈你对java平台的理解？&quot; class=&quot;headerlink&quot; title=&quot;一、1.谈谈你对java平台的理解？&quot;&gt;&lt;/a&gt;一、1.谈谈你对java平台的理解？&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MYSQL MAP</title>
    <link href="http://example.com/2020/11/01/mySQL%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://example.com/2020/11/01/mySQL%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2020-11-01T07:29:00.262Z</published>
    <updated>2020-11-01T07:29:00.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h1><font color=#999AAA ><p>学习时候用的思维导图<br>分享给大家</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><font color=#999AAA ><p>01丨了解SQL：一门半衰期很长的语言<br>02丨DBMS的前世今生<br>03丨学会用数据库的方式思考SQL是如何执行的<br>04丨使用DDL创建数据库&amp;数据表时需要注意什么？<br>05丨检索数据：你还在SELECT * 么？<br>06丨数据过滤：SQL数据过滤都有哪些方法？<br>07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？<br>08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">css<a id="more"></a># 学习时间：<font color=#999AAA ><p>1、 周一至周五晚上 7 点—晚上9点<br>2、 周六上午 9 点-上午 11 点<br>3、 周日下午 3 点-下午 6 点</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="学习产出："><a href="#学习产出：" class="headerlink" title="学习产出："></a>学习产出：</h1><font color=#999AAA ><p>1、 技术笔记 1 篇<br>2、CSDN 技术博客 1篇<br>3、 学习的 vlog 视频 1 个</p><p>Markdown<br><img src="https://img-blog.csdnimg.cn/2020101109291567.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020101109291529.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914837.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914844.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914810.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914802.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092914439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201011092913785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;学习目标：&quot;&gt;&lt;a href=&quot;#学习目标：&quot; class=&quot;headerlink&quot; title=&quot;学习目标：&quot;&gt;&lt;/a&gt;学习目标：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;学习时候用的思维导图&lt;br&gt;分享给大家&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;学习内容：&quot;&gt;&lt;a href=&quot;#学习内容：&quot; class=&quot;headerlink&quot; title=&quot;学习内容：&quot;&gt;&lt;/a&gt;学习内容：&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;01丨了解SQL：一门半衰期很长的语言&lt;br&gt;02丨DBMS的前世今生&lt;br&gt;03丨学会用数据库的方式思考SQL是如何执行的&lt;br&gt;04丨使用DDL创建数据库&amp;amp;数据表时需要注意什么？&lt;br&gt;05丨检索数据：你还在SELECT * 么？&lt;br&gt;06丨数据过滤：SQL数据过滤都有哪些方法？&lt;br&gt;07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？&lt;br&gt;08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;
css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/11/01/hello-world/"/>
    <id>http://example.com/2020/11/01/hello-world/</id>
    <published>2020-11-01T07:28:59.214Z</published>
    <updated>2020-11-01T07:28:59.215Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>css<a id="more"></a><br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之HashMap篇</title>
    <link href="http://example.com/2020/11/01/HashMap/"/>
    <id>http://example.com/2020/11/01/HashMap/</id>
    <published>2020-11-01T07:28:59.128Z</published>
    <updated>2020-11-01T07:28:59.128Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >**HashMap**<a id="more"></a>数组  通过一个Key的hashcode （mod） 数组长一个值就叫索引数组+链表实现数据分布，数据结构创建Map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">createMap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; ret = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// TODO put的第一个为key，第二个为value</span></span><br><span class="line">            ret.put(<span class="string">&quot;key&quot;</span> + i, String.valueOf(Math.random()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;--------------删除key--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">       String keyToRemove = <span class="string">&quot;key9&quot;</span>;</span><br><span class="line">       System.out.println(keyToRemove + <span class="string">&quot;对应的值是：&quot;</span> + map.get(keyToRemove));</span><br><span class="line">       map.remove(keyToRemove);</span><br><span class="line">       System.out.println(<span class="string">&quot;执行删除操作后，&quot;</span> + keyToRemove + <span class="string">&quot;对应的值是：&quot;</span> + map.get(keyToRemove));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历key和value--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;key为：&quot;</span> + entry.getKey() + <span class="string">&quot;，value为：&quot;</span> + entry.getValue());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历value--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">           System.out.println(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;--------------遍历key--------------&quot;</span>);</span><br><span class="line">       <span class="comment">// TODO 通过Entry类遍历Map</span></span><br><span class="line">       <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">           System.out.println(key);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>遍历是没有顺序的 entrySet<br>大家记忆一下：<br> map.remove(keyToRemove);<br> Map.Entry&lt;String, String&gt; entry : map.entrySet()<br> entry.getKey() + “，value为：” + entry.getValue()<br>  map.values()<br>  map.keySet()<br>  为什么Hashmap可以实现Hashset呢？<br>  <strong>不管value，那么key不就是一个HashSet嘛！！</strong></p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
**HashMap**</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之Hashcode和equals篇</title>
    <link href="http://example.com/2020/11/01/hashCode%E5%92%8Cequals/"/>
    <id>http://example.com/2020/11/01/hashCode%E5%92%8Cequals/</id>
    <published>2020-11-01T07:28:58.807Z</published>
    <updated>2020-11-01T07:28:58.807Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><h1 id="HashCode-和equals方法"><a href="#HashCode-和equals方法" class="headerlink" title="HashCode 和equals方法"></a>HashCode 和equals方法</h1><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><p>hashCode可以翻译为哈希码，或者散列码。应该是一个表示对象的特征值的int整数。</p><a id="more"></a><p>创建一个值以后，缓存中有个行有个列，行+列 =hash码<br>equals方法应该用来判断两个对象从<strong>逻辑</strong>上是否相等<br>ps:(引用的==就代表两个引用是否在指向同一个对象)<br>如果eauals是true ,hashCode就应该相等<br>如果hashCode 相等，equals不一定为true</p><p><strong>String下的equals方法</strong><br><img src="https://img-blog.csdnimg.cn/20201024175535483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>因为java的优化，就相当于“永久代”，固定的存储空间（不了解的可以翻看我前面那一篇关于String类的解读）<br>所以当s2运行后，就自动会将s2存入s1的位置，所以“==”就为true。<br>“==”只有当字符串足够长时，java不会优化，也不会放在同一个位置，就会为false.<br>而equals()则会一个一个字符的相比，所以就一定为true</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一次面试，对hashCode很是陌生，大家一定要对java基础有着一定的了解，一定要熟悉专属名词，“==”永远是比位置，看是否指向同一个对象，而equals在引用中是指逻辑上是否一致，在Sting中则是体现值是否相等！！</p><p>PEACE!!!!</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;HashCode-和equals方法&quot;&gt;&lt;a href=&quot;#HashCode-和equals方法&quot; class=&quot;headerlink&quot; title=&quot;HashCode 和equals方法&quot;&gt;&lt;/a&gt;HashCode 和equals方法&lt;/h1&gt;&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;p&gt;hashCode可以翻译为哈希码，或者散列码。应该是一个表示对象的特征值的int整数。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在springmvc项目中CURD测试集分享</title>
    <link href="http://example.com/2020/11/01/CURD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://example.com/2020/11/01/CURD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</id>
    <published>2020-11-01T07:28:58.484Z</published>
    <updated>2020-11-01T07:28:58.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="一-想要对service层进行测试用例"><a href="#一-想要对service层进行测试用例" class="headerlink" title="一.想要对service层进行测试用例"></a>一.想要对service层进行测试用例</h2><p>1.首先将service层中的interface 中的方法进行重写<br><img src="https://img-blog.csdnimg.cn/20201014180321955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>css<a id="more"></a><br>2.然后实现此接口的类就会要求你实现此方法。<br><img src="https://img-blog.csdnimg.cn/20201014180331850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3.通过此类中的 entityDao方法进入DAO层，增加创建方法<br><img src="https://img-blog.csdnimg.cn/20201014180341608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>4.其中引用了application.xml中的自动匹配app-servlet中的mapper,进入编写增删查改SQL语句的底层。<br><img src="https://img-blog.csdnimg.cn/20201014180400924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>此刻基本已经编写完毕，基本上还是根据springMVC的基本原理进行<br>而后编写测试总类：<br><img src="https://img-blog.csdnimg.cn/20201014180412975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>通过运行application.xml，使用扫描注入所有@service 的类注入容器，搜寻authUserServiceImpl，开始创建对象，调用方法，按照刚刚上面写的示例走一遍业务，就可以实现创建对象。</p><p>PEACE！！！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;测试用例&quot;&gt;&lt;a href=&quot;#测试用例&quot; class=&quot;headerlink&quot; title=&quot;测试用例&quot;&gt;&lt;/a&gt;测试用例&lt;/h1&gt;&lt;h2 id=&quot;一-想要对service层进行测试用例&quot;&gt;&lt;a href=&quot;#一-想要对service层进行测试用例&quot; class=&quot;headerlink&quot; title=&quot;一.想要对service层进行测试用例&quot;&gt;&lt;/a&gt;一.想要对service层进行测试用例&lt;/h2&gt;&lt;p&gt;1.首先将service层中的interface 中的方法进行重写&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201014180321955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于ruoyi前后端分离部署的所思所想</title>
    <link href="http://example.com/2020/11/01/%E5%85%B3%E4%BA%8Eruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%20(1)/"/>
    <id>http://example.com/2020/11/01/%E5%85%B3%E4%BA%8Eruoyi%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%83%A8%E7%BD%B2%E7%9A%84%E6%89%80%E6%80%9D%E6%89%80%E6%83%B3%20(1)/</id>
    <published>2020-11-01T07:28:58.410Z</published>
    <updated>2020-11-01T07:28:58.410Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>前后端分离对于你命令行的锻炼，对lunix系统长期适应有着非常重要的作用<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA ><h1 id="一、为什么要挑战前后端分离？"><a href="#一、为什么要挑战前后端分离？" class="headerlink" title="一、为什么要挑战前后端分离？"></a>一、为什么要挑战前后端分离？</h1><font color=#999AAA ><p>只是为了一种成就感，虚无缥缈的东西，让我能一直学习下去，通过配置后端软件，学到了很多lunix命令。这是意外收获，不败不馁，控制脾气。lunix系统在CENTOS7上顺利运行的时候我是非常高兴的，每次都在装载软件中卡住，但渐渐也终于熟悉，熟练，很高兴通过命令部署了一个前后端在不同主机运行的项目，我想这是一个程序员必备的东西吧。</p><p>css<a id="more"></a></p><h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-引入文章，引自CodeSheep"><a href="#1-引入文章，引自CodeSheep" class="headerlink" title="1.引入文章，引自CodeSheep"></a>1.引入文章，引自CodeSheep</h2><font color=#999AAA >!<p><img src="https://img-blog.csdnimg.cn/20201012172904949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201012172931325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-来源"><a href="#2-来源" class="headerlink" title="2.来源"></a>2.来源</h2><font color=#999AAA >想要的可以去CodeSheep公众号去找<font color=#999AAA ><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><font color=#999AAA >我在这里想和大家说nginx这个软件一定要学会进入它的conf来配置，一次不成两次，学习DOS命令是一个很烦的过程，但是你熟练后悔对你未来有所帮助。mvn打包，jar包直接部署，确实是最简单的方式，前后端呼应的那一瞬间感觉真的很好。<p>感谢主！！！</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;/font&gt;




&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;前后端分离对于你命令行的锻炼，对lunix系统长期适应有着非常重要的作用&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;

&lt;h1 id=&quot;一、为什么要挑战前后端分离？&quot;&gt;&lt;a href=&quot;#一、为什么要挑战前后端分离？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要挑战前后端分离？&quot;&gt;&lt;/a&gt;一、为什么要挑战前后端分离？&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;只是为了一种成就感，虚无缥缈的东西，让我能一直学习下去，通过配置后端软件，学到了很多lunix命令。这是意外收获，不败不馁，控制脾气。lunix系统在CENTOS7上顺利运行的时候我是非常高兴的，每次都在装载软件中卡住，但渐渐也终于熟悉，熟练，很高兴通过命令部署了一个前后端在不同主机运行的项目，我想这是一个程序员必备的东西吧。&lt;/p&gt;
&lt;p&gt;css</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之引用篇</title>
    <link href="http://example.com/2020/11/01/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%20(1)/"/>
    <id>http://example.com/2020/11/01/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%20(1)/</id>
    <published>2020-11-01T07:28:56.646Z</published>
    <updated>2020-11-01T07:28:56.647Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font> **强引用、软引用、弱引用、幻象引用有什么区别？**在java语言中，除了原始数据类型的变量，其他所有都是常用的引用类型，指向各种不同的对象，理解引用对于掌握java对象生命周期和jvm内部机关机制有着重要的作用<a id="more"></a>不同的引用类型，主要区别是：对象不同的可达性状态和对垃圾收集的影响所谓**强引用**就是咱们普通的引用，只要还有强引用指向一个对象，就表明该对象还活着，垃圾收集器不会碰这样的对象，对于一个普通的引用，只要超过了引用的作用域且显式的将引用赋值为null,就可以被垃圾收集了**软引用**就是相对于强引用的弱化一些的 引用，可以让对象豁免一些 垃圾收集，只有Jvm认为内存不足时，才会试图回收软引用指向的对象。软引用指向的对象（或者实现的是）通常是些敏感的缓存，如果还有空闲内存，可以暂时保留缓存，如果系统快要抛出oom异常的时候，就要删除软引用来保证内存存在**弱引用** 并不能是对象豁免垃圾收集，，仅仅是提供一种访问在弱引用状态下对象的途径。维护一种非强制性的映射关系。如果试图获取的对象还在，就使用它，否则就重新实例。同样是许多缓存实现的选择**幻象引用** 虚引用，不能通过它访问对象。幻想引用仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。比如：上一节的Post-Mortem清理机制，java平台自身Claeaner机制等利用幻想引用监控对象的创建和销毁<p>诊断MySql connector -j 驱动在特定模式下（useCompression =true）的内存泄露问题</p><p><strong>扩展</strong><br><strong>强可达</strong>：就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如:我们创建一个对象，创建它的线程对它就是强可达<br><strong>软可达</strong>：就是我们只能通过软引用才能访问到的对象的状态<br><strong>弱可达</strong>：无法通过强引用和软引用访问，只能通过弱引用访问到的状态，十分临进finalize状态的时机<br><strong>幻象可达</strong>：与上述三种引用均无关联，只是在finalize后，只有幻象可达指向这个对象<br><strong>不可达</strong>： 意味着对象可以被清除了</p><p><strong>判断对象可达性，是JVM垃圾收集器决定如何让处理对象的一部分考虑</strong></p><p>所有引用类型，都是抽象类java.lang.ref.Reference的子类，它提供了get方法：<br>除了幻象引用外，如果对象还没有被销毁，都可以通过get方法获取原有对象。这意味着，通过软引用和弱引用，我们都可以将访问到的对象，重新指向强引用。</p><p><strong>引用队列（ReferenceQueue）的使用</strong><br>我们创建各种引用并关联到相应对象时，我们可以选择是否需要关联到引用队列，JVM会在特定时机将引用enqueue到队列里，我们可以从队列里获取引用（remove）<br>尤其是幻想引用，get方法也获取不到，如果再不指定引用队列，那基本上是毫无用处了。处于幻象可达状态时，执行以下处理逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object counter = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue refQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; p = <span class="keyword">new</span> PhantomReference&lt;&gt;(counter, refQueue);</span><br><span class="line">counter = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Remove是一个阻塞方法，可以指定timeout，或者选择一直阻塞</span></span><br><span class="line">    Reference&lt;Object&gt; ref = refQueue.remove(<span class="number">1000L</span>);</span><br><span class="line">    <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// Handle it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显式的影响软引用垃圾收集</strong><br>对于软引用，我们一直对其垃圾收集机制飘忽不定，我们可以用什么方法来影响垃圾收集？<br>软引用通常都会在最后一次引用后，还能保存一段时间，默认值是以剩余空间计算的。<br>我们可以以毫秒来单位设置：<br>-XX:SoftRefLRUPolicyMSPerMB=3000<br><strong>如果你怀疑引用（finalize）导致的回收问题</strong><br>可以通过PrintReferebceGC去获取相关信息<br>jdk8使用ParrllelGC日志，各种引用非常清晰可查</p><p><strong>Reachability Fence</strong><br>我们可以通过底层API来达到强引用的效果<br>考虑一下这样一种情况：<br>如果某一个引用不是强引用，就符合垃圾处理机制，但是某些属性还在被使用，这是就需要某个机制通知JVM这个对象是在被使用的，这就是Reachablity Fence的作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> ExternalResource[] externalResourceArray = ...</span><br><span class="line"> <span class="keyword">int</span> myIndex; Resource(...) &#123;</span><br><span class="line">     myIndex = ...</span><br><span class="line">     externalResourceArray[myIndex] = ...;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     externalResourceArray[myIndex] = <span class="keyword">null</span>;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 需要被保护的代码</span></span><br><span class="line">     <span class="keyword">int</span> i = myIndex;</span><br><span class="line">     Resource.update(externalResourceArray[i]);</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">// 调用reachbilityFence，明确保障对象strongly reachable</span></span><br><span class="line">     Reference.reachabilityFence(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ExternalResource ext)</span> </span>&#123;</span><br><span class="line">    ext.status = ...;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>通过finally明确表示对象强可达</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;
 **强引用、软引用、弱引用、幻象引用有什么区别？**
在java语言中，除了原始数据类型的变量，其他所有都是常用的引用类型，指向各种不同的对象，理解引用对于掌握java对象生命周期和jvm内部机关机制有着重要的作用</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之注解篇</title>
    <link href="http://example.com/2020/11/01/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2020/11/01/%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-01T07:28:56.639Z</published>
    <updated>2020-11-01T07:28:56.639Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >annotation<p>@override（重写）<br>@Deprecated(过时)<br>告诉编译器<br>@service<br>@controller<br>都是Spring中必不可少的</p><a id="more"></a><p><strong>从现在开始我来教你们自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 注解可以被用在哪个/哪些元素上</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">retention表明自己会保留到多久</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="comment">// TODO 给annotation里的属性赋值的方式</span></span><br><span class="line">    <span class="meta">@PrimaryProperty(defaultValue = &quot;testbggg&quot;, targetClass = TestUseAnnotation.class,</span></span><br><span class="line"><span class="meta">        abc = 9, defaultValues = &#123;&quot;aaa&quot;, &quot;bbb&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>比如在Spring中</p><p><img src="https://img-blog.csdnimg.cn/20201026165415852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzYyODI0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>@contorller就是告诉 servlet 来遍历所有的contorller类<br>然后通过@RequestMapping找到那个  .html ，然后加载它<br>通过Spring容器自动注入这些bean</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
annotation

&lt;p&gt;@override（重写）&lt;br&gt;@Deprecated(过时)&lt;br&gt;告诉编译器&lt;br&gt;@service&lt;br&gt;@controller&lt;br&gt;都是Spring中必不可少的&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>每日深耕，勤练不缀之异常篇</title>
    <link href="http://example.com/2020/11/01/%E5%BC%82%E5%B8%B8%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89/"/>
    <id>http://example.com/2020/11/01/%E5%BC%82%E5%B8%B8%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89/</id>
    <published>2020-11-01T07:28:56.633Z</published>
    <updated>2020-11-01T07:28:56.633Z</updated>
    
    <content type="html"><![CDATA[<font color=#999AAA ><p>有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><font color=#999AAA ><p>每个java小白都会遇到的阵痛，我写下来。<br>一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。</p></font><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >error（系统级的错误，我们处理不了，只能查错）<a id="more"></a>Exception又分为两种：RuntimeException为UncheckedException另一类为CheckedException,如classNotFoundException,必须try ..catch 或者throw掉的异常抛出异常的语法throwsjava异常的传递在方法调用之间传递，直至被Catch解决掉程序是一层一层往里调用而异常则是一层层往外抛，直至抛到main方法还没有人解决就报错<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          caller2.call3Exception();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;got exception in Caller1: &quot;</span>+ex.getMessage());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>自定义异常</strong><br>catch语句是根据异常类型匹配来捕捉相应类型的异常的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         Class.forName(<span class="string">&quot;com.neverland.Rabbit&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;&quot;</span>, ex);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这就是checkedException<br>如果catch一个并没有被抛出的checked Exception，Java就会报错。因为java明确知道这个异常不会发生。<br>catch一个uncheckedException,不会报错<br>而且thorow谁（并没有被抛出的）都不会报错</p>]]></content>
    
    
    <summary type="html">&lt;font color=#999AAA &gt;

&lt;p&gt;有一个想法，就是将自己每天对技术的感悟写下来，有时候我们弄通一个小技术，感觉太丢人了，这么小的东西怎么写。但是我就要写，因为我以后会用到，大家以后也会用到。&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;font color=#999AAA &gt;

&lt;p&gt;每个java小白都会遇到的阵痛，我写下来。&lt;br&gt;一句古语：秦人不暇自哀而后人哀之，后人哀之而不鉴之，亦使后人复哀后人也。&lt;/p&gt;
&lt;/font&gt;

&lt;hr style=&quot; border:solid; width:100px; height:1px;&quot; color=#000000 size=1&quot;&gt;

&lt;font color=#999AAA &gt;
error（系统级的错误，我们处理不了，只能查错）</summary>
    
    
    
    
  </entry>
  
</feed>
